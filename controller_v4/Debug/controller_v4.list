
controller_v4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00009748  080001f8  080001f8  000101f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000e8  08009940  08009940  00019940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08009a28  08009a28  00022068  2**0
                  CONTENTS
  4 .ARM          00000008  08009a28  08009a28  00019a28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08009a30  08009a30  00022068  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08009a30  08009a30  00019a30  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08009a34  08009a34  00019a34  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00002068  20000000  08009a38  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000675d8  20002068  0800baa0  00022068  2**3
                  ALLOC
 10 ._user_heap_stack 00000600  20069640  0800baa0  00029640  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  00022068  2**0
                  CONTENTS, READONLY
 12 .debug_info   00031cb6  00000000  00000000  00022096  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000658c  00000000  00000000  00053d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00019cda  00000000  00000000  0005a2d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 000014c8  00000000  00000000  00073fb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00004538  00000000  00000000  00075480  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  0002c3d1  00000000  00000000  000799b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0001d96a  00000000  00000000  000a5d89  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00104b26  00000000  00000000  000c36f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  001c8219  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00004698  00000000  00000000  001c8294  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001f8 <__do_global_dtors_aux>:
 80001f8:	b510      	push	{r4, lr}
 80001fa:	4c05      	ldr	r4, [pc, #20]	; (8000210 <__do_global_dtors_aux+0x18>)
 80001fc:	7823      	ldrb	r3, [r4, #0]
 80001fe:	b933      	cbnz	r3, 800020e <__do_global_dtors_aux+0x16>
 8000200:	4b04      	ldr	r3, [pc, #16]	; (8000214 <__do_global_dtors_aux+0x1c>)
 8000202:	b113      	cbz	r3, 800020a <__do_global_dtors_aux+0x12>
 8000204:	4804      	ldr	r0, [pc, #16]	; (8000218 <__do_global_dtors_aux+0x20>)
 8000206:	f3af 8000 	nop.w
 800020a:	2301      	movs	r3, #1
 800020c:	7023      	strb	r3, [r4, #0]
 800020e:	bd10      	pop	{r4, pc}
 8000210:	20002068 	.word	0x20002068
 8000214:	00000000 	.word	0x00000000
 8000218:	08009928 	.word	0x08009928

0800021c <frame_dummy>:
 800021c:	b508      	push	{r3, lr}
 800021e:	4b03      	ldr	r3, [pc, #12]	; (800022c <frame_dummy+0x10>)
 8000220:	b11b      	cbz	r3, 800022a <frame_dummy+0xe>
 8000222:	4903      	ldr	r1, [pc, #12]	; (8000230 <frame_dummy+0x14>)
 8000224:	4803      	ldr	r0, [pc, #12]	; (8000234 <frame_dummy+0x18>)
 8000226:	f3af 8000 	nop.w
 800022a:	bd08      	pop	{r3, pc}
 800022c:	00000000 	.word	0x00000000
 8000230:	2000206c 	.word	0x2000206c
 8000234:	08009928 	.word	0x08009928

08000238 <__aeabi_uldivmod>:
 8000238:	b953      	cbnz	r3, 8000250 <__aeabi_uldivmod+0x18>
 800023a:	b94a      	cbnz	r2, 8000250 <__aeabi_uldivmod+0x18>
 800023c:	2900      	cmp	r1, #0
 800023e:	bf08      	it	eq
 8000240:	2800      	cmpeq	r0, #0
 8000242:	bf1c      	itt	ne
 8000244:	f04f 31ff 	movne.w	r1, #4294967295
 8000248:	f04f 30ff 	movne.w	r0, #4294967295
 800024c:	f000 b972 	b.w	8000534 <__aeabi_idiv0>
 8000250:	f1ad 0c08 	sub.w	ip, sp, #8
 8000254:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000258:	f000 f806 	bl	8000268 <__udivmoddi4>
 800025c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000260:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000264:	b004      	add	sp, #16
 8000266:	4770      	bx	lr

08000268 <__udivmoddi4>:
 8000268:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800026c:	9e08      	ldr	r6, [sp, #32]
 800026e:	4604      	mov	r4, r0
 8000270:	4688      	mov	r8, r1
 8000272:	2b00      	cmp	r3, #0
 8000274:	d14b      	bne.n	800030e <__udivmoddi4+0xa6>
 8000276:	428a      	cmp	r2, r1
 8000278:	4615      	mov	r5, r2
 800027a:	d967      	bls.n	800034c <__udivmoddi4+0xe4>
 800027c:	fab2 f282 	clz	r2, r2
 8000280:	b14a      	cbz	r2, 8000296 <__udivmoddi4+0x2e>
 8000282:	f1c2 0720 	rsb	r7, r2, #32
 8000286:	fa01 f302 	lsl.w	r3, r1, r2
 800028a:	fa20 f707 	lsr.w	r7, r0, r7
 800028e:	4095      	lsls	r5, r2
 8000290:	ea47 0803 	orr.w	r8, r7, r3
 8000294:	4094      	lsls	r4, r2
 8000296:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800029a:	0c23      	lsrs	r3, r4, #16
 800029c:	fbb8 f7fe 	udiv	r7, r8, lr
 80002a0:	fa1f fc85 	uxth.w	ip, r5
 80002a4:	fb0e 8817 	mls	r8, lr, r7, r8
 80002a8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80002ac:	fb07 f10c 	mul.w	r1, r7, ip
 80002b0:	4299      	cmp	r1, r3
 80002b2:	d909      	bls.n	80002c8 <__udivmoddi4+0x60>
 80002b4:	18eb      	adds	r3, r5, r3
 80002b6:	f107 30ff 	add.w	r0, r7, #4294967295
 80002ba:	f080 811b 	bcs.w	80004f4 <__udivmoddi4+0x28c>
 80002be:	4299      	cmp	r1, r3
 80002c0:	f240 8118 	bls.w	80004f4 <__udivmoddi4+0x28c>
 80002c4:	3f02      	subs	r7, #2
 80002c6:	442b      	add	r3, r5
 80002c8:	1a5b      	subs	r3, r3, r1
 80002ca:	b2a4      	uxth	r4, r4
 80002cc:	fbb3 f0fe 	udiv	r0, r3, lr
 80002d0:	fb0e 3310 	mls	r3, lr, r0, r3
 80002d4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80002d8:	fb00 fc0c 	mul.w	ip, r0, ip
 80002dc:	45a4      	cmp	ip, r4
 80002de:	d909      	bls.n	80002f4 <__udivmoddi4+0x8c>
 80002e0:	192c      	adds	r4, r5, r4
 80002e2:	f100 33ff 	add.w	r3, r0, #4294967295
 80002e6:	f080 8107 	bcs.w	80004f8 <__udivmoddi4+0x290>
 80002ea:	45a4      	cmp	ip, r4
 80002ec:	f240 8104 	bls.w	80004f8 <__udivmoddi4+0x290>
 80002f0:	3802      	subs	r0, #2
 80002f2:	442c      	add	r4, r5
 80002f4:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80002f8:	eba4 040c 	sub.w	r4, r4, ip
 80002fc:	2700      	movs	r7, #0
 80002fe:	b11e      	cbz	r6, 8000308 <__udivmoddi4+0xa0>
 8000300:	40d4      	lsrs	r4, r2
 8000302:	2300      	movs	r3, #0
 8000304:	e9c6 4300 	strd	r4, r3, [r6]
 8000308:	4639      	mov	r1, r7
 800030a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800030e:	428b      	cmp	r3, r1
 8000310:	d909      	bls.n	8000326 <__udivmoddi4+0xbe>
 8000312:	2e00      	cmp	r6, #0
 8000314:	f000 80eb 	beq.w	80004ee <__udivmoddi4+0x286>
 8000318:	2700      	movs	r7, #0
 800031a:	e9c6 0100 	strd	r0, r1, [r6]
 800031e:	4638      	mov	r0, r7
 8000320:	4639      	mov	r1, r7
 8000322:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000326:	fab3 f783 	clz	r7, r3
 800032a:	2f00      	cmp	r7, #0
 800032c:	d147      	bne.n	80003be <__udivmoddi4+0x156>
 800032e:	428b      	cmp	r3, r1
 8000330:	d302      	bcc.n	8000338 <__udivmoddi4+0xd0>
 8000332:	4282      	cmp	r2, r0
 8000334:	f200 80fa 	bhi.w	800052c <__udivmoddi4+0x2c4>
 8000338:	1a84      	subs	r4, r0, r2
 800033a:	eb61 0303 	sbc.w	r3, r1, r3
 800033e:	2001      	movs	r0, #1
 8000340:	4698      	mov	r8, r3
 8000342:	2e00      	cmp	r6, #0
 8000344:	d0e0      	beq.n	8000308 <__udivmoddi4+0xa0>
 8000346:	e9c6 4800 	strd	r4, r8, [r6]
 800034a:	e7dd      	b.n	8000308 <__udivmoddi4+0xa0>
 800034c:	b902      	cbnz	r2, 8000350 <__udivmoddi4+0xe8>
 800034e:	deff      	udf	#255	; 0xff
 8000350:	fab2 f282 	clz	r2, r2
 8000354:	2a00      	cmp	r2, #0
 8000356:	f040 808f 	bne.w	8000478 <__udivmoddi4+0x210>
 800035a:	1b49      	subs	r1, r1, r5
 800035c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000360:	fa1f f885 	uxth.w	r8, r5
 8000364:	2701      	movs	r7, #1
 8000366:	fbb1 fcfe 	udiv	ip, r1, lr
 800036a:	0c23      	lsrs	r3, r4, #16
 800036c:	fb0e 111c 	mls	r1, lr, ip, r1
 8000370:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000374:	fb08 f10c 	mul.w	r1, r8, ip
 8000378:	4299      	cmp	r1, r3
 800037a:	d907      	bls.n	800038c <__udivmoddi4+0x124>
 800037c:	18eb      	adds	r3, r5, r3
 800037e:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000382:	d202      	bcs.n	800038a <__udivmoddi4+0x122>
 8000384:	4299      	cmp	r1, r3
 8000386:	f200 80cd 	bhi.w	8000524 <__udivmoddi4+0x2bc>
 800038a:	4684      	mov	ip, r0
 800038c:	1a59      	subs	r1, r3, r1
 800038e:	b2a3      	uxth	r3, r4
 8000390:	fbb1 f0fe 	udiv	r0, r1, lr
 8000394:	fb0e 1410 	mls	r4, lr, r0, r1
 8000398:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800039c:	fb08 f800 	mul.w	r8, r8, r0
 80003a0:	45a0      	cmp	r8, r4
 80003a2:	d907      	bls.n	80003b4 <__udivmoddi4+0x14c>
 80003a4:	192c      	adds	r4, r5, r4
 80003a6:	f100 33ff 	add.w	r3, r0, #4294967295
 80003aa:	d202      	bcs.n	80003b2 <__udivmoddi4+0x14a>
 80003ac:	45a0      	cmp	r8, r4
 80003ae:	f200 80b6 	bhi.w	800051e <__udivmoddi4+0x2b6>
 80003b2:	4618      	mov	r0, r3
 80003b4:	eba4 0408 	sub.w	r4, r4, r8
 80003b8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80003bc:	e79f      	b.n	80002fe <__udivmoddi4+0x96>
 80003be:	f1c7 0c20 	rsb	ip, r7, #32
 80003c2:	40bb      	lsls	r3, r7
 80003c4:	fa22 fe0c 	lsr.w	lr, r2, ip
 80003c8:	ea4e 0e03 	orr.w	lr, lr, r3
 80003cc:	fa01 f407 	lsl.w	r4, r1, r7
 80003d0:	fa20 f50c 	lsr.w	r5, r0, ip
 80003d4:	fa21 f30c 	lsr.w	r3, r1, ip
 80003d8:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80003dc:	4325      	orrs	r5, r4
 80003de:	fbb3 f9f8 	udiv	r9, r3, r8
 80003e2:	0c2c      	lsrs	r4, r5, #16
 80003e4:	fb08 3319 	mls	r3, r8, r9, r3
 80003e8:	fa1f fa8e 	uxth.w	sl, lr
 80003ec:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80003f0:	fb09 f40a 	mul.w	r4, r9, sl
 80003f4:	429c      	cmp	r4, r3
 80003f6:	fa02 f207 	lsl.w	r2, r2, r7
 80003fa:	fa00 f107 	lsl.w	r1, r0, r7
 80003fe:	d90b      	bls.n	8000418 <__udivmoddi4+0x1b0>
 8000400:	eb1e 0303 	adds.w	r3, lr, r3
 8000404:	f109 30ff 	add.w	r0, r9, #4294967295
 8000408:	f080 8087 	bcs.w	800051a <__udivmoddi4+0x2b2>
 800040c:	429c      	cmp	r4, r3
 800040e:	f240 8084 	bls.w	800051a <__udivmoddi4+0x2b2>
 8000412:	f1a9 0902 	sub.w	r9, r9, #2
 8000416:	4473      	add	r3, lr
 8000418:	1b1b      	subs	r3, r3, r4
 800041a:	b2ad      	uxth	r5, r5
 800041c:	fbb3 f0f8 	udiv	r0, r3, r8
 8000420:	fb08 3310 	mls	r3, r8, r0, r3
 8000424:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000428:	fb00 fa0a 	mul.w	sl, r0, sl
 800042c:	45a2      	cmp	sl, r4
 800042e:	d908      	bls.n	8000442 <__udivmoddi4+0x1da>
 8000430:	eb1e 0404 	adds.w	r4, lr, r4
 8000434:	f100 33ff 	add.w	r3, r0, #4294967295
 8000438:	d26b      	bcs.n	8000512 <__udivmoddi4+0x2aa>
 800043a:	45a2      	cmp	sl, r4
 800043c:	d969      	bls.n	8000512 <__udivmoddi4+0x2aa>
 800043e:	3802      	subs	r0, #2
 8000440:	4474      	add	r4, lr
 8000442:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000446:	fba0 8902 	umull	r8, r9, r0, r2
 800044a:	eba4 040a 	sub.w	r4, r4, sl
 800044e:	454c      	cmp	r4, r9
 8000450:	46c2      	mov	sl, r8
 8000452:	464b      	mov	r3, r9
 8000454:	d354      	bcc.n	8000500 <__udivmoddi4+0x298>
 8000456:	d051      	beq.n	80004fc <__udivmoddi4+0x294>
 8000458:	2e00      	cmp	r6, #0
 800045a:	d069      	beq.n	8000530 <__udivmoddi4+0x2c8>
 800045c:	ebb1 050a 	subs.w	r5, r1, sl
 8000460:	eb64 0403 	sbc.w	r4, r4, r3
 8000464:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000468:	40fd      	lsrs	r5, r7
 800046a:	40fc      	lsrs	r4, r7
 800046c:	ea4c 0505 	orr.w	r5, ip, r5
 8000470:	e9c6 5400 	strd	r5, r4, [r6]
 8000474:	2700      	movs	r7, #0
 8000476:	e747      	b.n	8000308 <__udivmoddi4+0xa0>
 8000478:	f1c2 0320 	rsb	r3, r2, #32
 800047c:	fa20 f703 	lsr.w	r7, r0, r3
 8000480:	4095      	lsls	r5, r2
 8000482:	fa01 f002 	lsl.w	r0, r1, r2
 8000486:	fa21 f303 	lsr.w	r3, r1, r3
 800048a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800048e:	4338      	orrs	r0, r7
 8000490:	0c01      	lsrs	r1, r0, #16
 8000492:	fbb3 f7fe 	udiv	r7, r3, lr
 8000496:	fa1f f885 	uxth.w	r8, r5
 800049a:	fb0e 3317 	mls	r3, lr, r7, r3
 800049e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004a2:	fb07 f308 	mul.w	r3, r7, r8
 80004a6:	428b      	cmp	r3, r1
 80004a8:	fa04 f402 	lsl.w	r4, r4, r2
 80004ac:	d907      	bls.n	80004be <__udivmoddi4+0x256>
 80004ae:	1869      	adds	r1, r5, r1
 80004b0:	f107 3cff 	add.w	ip, r7, #4294967295
 80004b4:	d22f      	bcs.n	8000516 <__udivmoddi4+0x2ae>
 80004b6:	428b      	cmp	r3, r1
 80004b8:	d92d      	bls.n	8000516 <__udivmoddi4+0x2ae>
 80004ba:	3f02      	subs	r7, #2
 80004bc:	4429      	add	r1, r5
 80004be:	1acb      	subs	r3, r1, r3
 80004c0:	b281      	uxth	r1, r0
 80004c2:	fbb3 f0fe 	udiv	r0, r3, lr
 80004c6:	fb0e 3310 	mls	r3, lr, r0, r3
 80004ca:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004ce:	fb00 f308 	mul.w	r3, r0, r8
 80004d2:	428b      	cmp	r3, r1
 80004d4:	d907      	bls.n	80004e6 <__udivmoddi4+0x27e>
 80004d6:	1869      	adds	r1, r5, r1
 80004d8:	f100 3cff 	add.w	ip, r0, #4294967295
 80004dc:	d217      	bcs.n	800050e <__udivmoddi4+0x2a6>
 80004de:	428b      	cmp	r3, r1
 80004e0:	d915      	bls.n	800050e <__udivmoddi4+0x2a6>
 80004e2:	3802      	subs	r0, #2
 80004e4:	4429      	add	r1, r5
 80004e6:	1ac9      	subs	r1, r1, r3
 80004e8:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80004ec:	e73b      	b.n	8000366 <__udivmoddi4+0xfe>
 80004ee:	4637      	mov	r7, r6
 80004f0:	4630      	mov	r0, r6
 80004f2:	e709      	b.n	8000308 <__udivmoddi4+0xa0>
 80004f4:	4607      	mov	r7, r0
 80004f6:	e6e7      	b.n	80002c8 <__udivmoddi4+0x60>
 80004f8:	4618      	mov	r0, r3
 80004fa:	e6fb      	b.n	80002f4 <__udivmoddi4+0x8c>
 80004fc:	4541      	cmp	r1, r8
 80004fe:	d2ab      	bcs.n	8000458 <__udivmoddi4+0x1f0>
 8000500:	ebb8 0a02 	subs.w	sl, r8, r2
 8000504:	eb69 020e 	sbc.w	r2, r9, lr
 8000508:	3801      	subs	r0, #1
 800050a:	4613      	mov	r3, r2
 800050c:	e7a4      	b.n	8000458 <__udivmoddi4+0x1f0>
 800050e:	4660      	mov	r0, ip
 8000510:	e7e9      	b.n	80004e6 <__udivmoddi4+0x27e>
 8000512:	4618      	mov	r0, r3
 8000514:	e795      	b.n	8000442 <__udivmoddi4+0x1da>
 8000516:	4667      	mov	r7, ip
 8000518:	e7d1      	b.n	80004be <__udivmoddi4+0x256>
 800051a:	4681      	mov	r9, r0
 800051c:	e77c      	b.n	8000418 <__udivmoddi4+0x1b0>
 800051e:	3802      	subs	r0, #2
 8000520:	442c      	add	r4, r5
 8000522:	e747      	b.n	80003b4 <__udivmoddi4+0x14c>
 8000524:	f1ac 0c02 	sub.w	ip, ip, #2
 8000528:	442b      	add	r3, r5
 800052a:	e72f      	b.n	800038c <__udivmoddi4+0x124>
 800052c:	4638      	mov	r0, r7
 800052e:	e708      	b.n	8000342 <__udivmoddi4+0xda>
 8000530:	4637      	mov	r7, r6
 8000532:	e6e9      	b.n	8000308 <__udivmoddi4+0xa0>

08000534 <__aeabi_idiv0>:
 8000534:	4770      	bx	lr
 8000536:	bf00      	nop

08000538 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000538:	4a0e      	ldr	r2, [pc, #56]	; (8000574 <HAL_InitTick+0x3c>)
 800053a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800053e:	490e      	ldr	r1, [pc, #56]	; (8000578 <HAL_InitTick+0x40>)
 8000540:	7812      	ldrb	r2, [r2, #0]
 8000542:	fbb3 f3f2 	udiv	r3, r3, r2
{
 8000546:	b510      	push	{r4, lr}
 8000548:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800054a:	6808      	ldr	r0, [r1, #0]
 800054c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000550:	f000 fee2 	bl	8001318 <HAL_SYSTICK_Config>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000554:	b908      	cbnz	r0, 800055a <HAL_InitTick+0x22>
 8000556:	2c0f      	cmp	r4, #15
 8000558:	d901      	bls.n	800055e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800055a:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 800055c:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800055e:	2200      	movs	r2, #0
 8000560:	4621      	mov	r1, r4
 8000562:	f04f 30ff 	mov.w	r0, #4294967295
 8000566:	f000 fe93 	bl	8001290 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800056a:	4b04      	ldr	r3, [pc, #16]	; (800057c <HAL_InitTick+0x44>)
 800056c:	2000      	movs	r0, #0
 800056e:	601c      	str	r4, [r3, #0]
}
 8000570:	bd10      	pop	{r4, pc}
 8000572:	bf00      	nop
 8000574:	20000000 	.word	0x20000000
 8000578:	20001f48 	.word	0x20001f48
 800057c:	20000004 	.word	0x20000004

08000580 <HAL_Init>:
{
 8000580:	b508      	push	{r3, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000582:	2003      	movs	r0, #3
 8000584:	f000 fe70 	bl	8001268 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000588:	2000      	movs	r0, #0
 800058a:	f7ff ffd5 	bl	8000538 <HAL_InitTick>
  HAL_MspInit();
 800058e:	f005 fd23 	bl	8005fd8 <HAL_MspInit>
}
 8000592:	2000      	movs	r0, #0
 8000594:	bd08      	pop	{r3, pc}
 8000596:	bf00      	nop

08000598 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000598:	4a03      	ldr	r2, [pc, #12]	; (80005a8 <HAL_IncTick+0x10>)
 800059a:	4b04      	ldr	r3, [pc, #16]	; (80005ac <HAL_IncTick+0x14>)
 800059c:	6811      	ldr	r1, [r2, #0]
 800059e:	781b      	ldrb	r3, [r3, #0]
 80005a0:	440b      	add	r3, r1
 80005a2:	6013      	str	r3, [r2, #0]
}
 80005a4:	4770      	bx	lr
 80005a6:	bf00      	nop
 80005a8:	200020fc 	.word	0x200020fc
 80005ac:	20000000 	.word	0x20000000

080005b0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80005b0:	4b01      	ldr	r3, [pc, #4]	; (80005b8 <HAL_GetTick+0x8>)
 80005b2:	6818      	ldr	r0, [r3, #0]
}
 80005b4:	4770      	bx	lr
 80005b6:	bf00      	nop
 80005b8:	200020fc 	.word	0x200020fc

080005bc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80005bc:	b538      	push	{r3, r4, r5, lr}
 80005be:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80005c0:	f7ff fff6 	bl	80005b0 <HAL_GetTick>
 80005c4:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80005c6:	1c63      	adds	r3, r4, #1
 80005c8:	d002      	beq.n	80005d0 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 80005ca:	4b04      	ldr	r3, [pc, #16]	; (80005dc <HAL_Delay+0x20>)
 80005cc:	781b      	ldrb	r3, [r3, #0]
 80005ce:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80005d0:	f7ff ffee 	bl	80005b0 <HAL_GetTick>
 80005d4:	1b40      	subs	r0, r0, r5
 80005d6:	42a0      	cmp	r0, r4
 80005d8:	d3fa      	bcc.n	80005d0 <HAL_Delay+0x14>
  {
  }
}
 80005da:	bd38      	pop	{r3, r4, r5, pc}
 80005dc:	20000000 	.word	0x20000000

080005e0 <HAL_ADC_Init>:
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 80005e0:	2800      	cmp	r0, #0
 80005e2:	f000 8092 	beq.w	800070a <HAL_ADC_Init+0x12a>
{
 80005e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 80005e8:	6c05      	ldr	r5, [r0, #64]	; 0x40
 80005ea:	4604      	mov	r4, r0
 80005ec:	2d00      	cmp	r5, #0
 80005ee:	f000 8082 	beq.w	80006f6 <HAL_ADC_Init+0x116>
    hadc->Lock = HAL_UNLOCKED;
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80005f2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80005f4:	06db      	lsls	r3, r3, #27
 80005f6:	d504      	bpl.n	8000602 <HAL_ADC_Init+0x22>
  {
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80005f8:	2300      	movs	r3, #0
    tmp_hal_status = HAL_ERROR;
 80005fa:	2001      	movs	r0, #1
  __HAL_UNLOCK(hadc);
 80005fc:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  /* Return function status */
  return tmp_hal_status;
}
 8000600:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ADC_STATE_CLR_SET(hadc->State,
 8000602:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000604:	4a4e      	ldr	r2, [pc, #312]	; (8000740 <HAL_ADC_Init+0x160>)
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8000606:	494f      	ldr	r1, [pc, #316]	; (8000744 <HAL_ADC_Init+0x164>)
    ADC_STATE_CLR_SET(hadc->State,
 8000608:	401a      	ands	r2, r3
  ADC->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800060a:	6823      	ldr	r3, [r4, #0]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800060c:	4d4e      	ldr	r5, [pc, #312]	; (8000748 <HAL_ADC_Init+0x168>)
    ADC_STATE_CLR_SET(hadc->State,
 800060e:	f042 0202 	orr.w	r2, r2, #2
 8000612:	6422      	str	r2, [r4, #64]	; 0x40
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8000614:	684a      	ldr	r2, [r1, #4]
 8000616:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800061a:	604a      	str	r2, [r1, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 800061c:	684a      	ldr	r2, [r1, #4]
 800061e:	6860      	ldr	r0, [r4, #4]
 8000620:	4302      	orrs	r2, r0
 8000622:	604a      	str	r2, [r1, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8000624:	685a      	ldr	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8000626:	6921      	ldr	r1, [r4, #16]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8000628:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800062c:	f8d4 c008 	ldr.w	ip, [r4, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8000630:	68e7      	ldr	r7, [r4, #12]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8000632:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8000634:	6858      	ldr	r0, [r3, #4]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000636:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8000638:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800063c:	42ae      	cmp	r6, r5
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800063e:	6058      	str	r0, [r3, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8000640:	6858      	ldr	r0, [r3, #4]
 8000642:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 8000646:	6058      	str	r0, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8000648:	6859      	ldr	r1, [r3, #4]
 800064a:	ea41 010c 	orr.w	r1, r1, ip
 800064e:	6059      	str	r1, [r3, #4]
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8000650:	6899      	ldr	r1, [r3, #8]
 8000652:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 8000656:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8000658:	689a      	ldr	r2, [r3, #8]
 800065a:	ea42 0207 	orr.w	r2, r2, r7
 800065e:	609a      	str	r2, [r3, #8]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000660:	d055      	beq.n	800070e <HAL_ADC_Init+0x12e>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8000662:	6899      	ldr	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8000664:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8000666:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 800066a:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 800066c:	689a      	ldr	r2, [r3, #8]
 800066e:	4316      	orrs	r6, r2
 8000670:	609e      	str	r6, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8000672:	6899      	ldr	r1, [r3, #8]
 8000674:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8000678:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 800067a:	689a      	ldr	r2, [r3, #8]
 800067c:	4302      	orrs	r2, r0
 800067e:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000680:	6899      	ldr	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8000682:	69a5      	ldr	r5, [r4, #24]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000684:	f021 0102 	bic.w	r1, r1, #2
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8000688:	f894 0020 	ldrb.w	r0, [r4, #32]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 800068c:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 800068e:	689a      	ldr	r2, [r3, #8]
 8000690:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8000694:	609a      	str	r2, [r3, #8]
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8000696:	2800      	cmp	r0, #0
 8000698:	d142      	bne.n	8000720 <HAL_ADC_Init+0x140>
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 800069a:	685a      	ldr	r2, [r3, #4]
 800069c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80006a0:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80006a2:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    ADC_CLEAR_ERRORCODE(hadc);
 80006a4:	2600      	movs	r6, #0
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80006a6:	69e5      	ldr	r5, [r4, #28]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80006a8:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 80006ac:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80006b0:	1e6a      	subs	r2, r5, #1
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80006b2:	6967      	ldr	r7, [r4, #20]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80006b4:	62d8      	str	r0, [r3, #44]	; 0x2c
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80006b6:	4630      	mov	r0, r6
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80006b8:	6add      	ldr	r5, [r3, #44]	; 0x2c
 80006ba:	ea45 5502 	orr.w	r5, r5, r2, lsl #20
 80006be:	62dd      	str	r5, [r3, #44]	; 0x2c
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80006c0:	689d      	ldr	r5, [r3, #8]
 80006c2:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 80006c6:	609d      	str	r5, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 80006c8:	6899      	ldr	r1, [r3, #8]
 80006ca:	ea41 214c 	orr.w	r1, r1, ip, lsl #9
 80006ce:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80006d0:	6899      	ldr	r1, [r3, #8]
 80006d2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80006d6:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80006d8:	689a      	ldr	r2, [r3, #8]
 80006da:	ea42 2287 	orr.w	r2, r2, r7, lsl #10
 80006de:	609a      	str	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 80006e0:	6466      	str	r6, [r4, #68]	; 0x44
    ADC_STATE_CLR_SET(hadc->State,
 80006e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80006e4:	f023 0303 	bic.w	r3, r3, #3
 80006e8:	f043 0301 	orr.w	r3, r3, #1
 80006ec:	6423      	str	r3, [r4, #64]	; 0x40
  __HAL_UNLOCK(hadc);
 80006ee:	2300      	movs	r3, #0
 80006f0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80006f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
 80006f6:	f005 fc87 	bl	8006008 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 80006fa:	6465      	str	r5, [r4, #68]	; 0x44
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80006fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
    hadc->Lock = HAL_UNLOCKED;
 80006fe:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8000702:	06db      	lsls	r3, r3, #27
 8000704:	f53f af78 	bmi.w	80005f8 <HAL_ADC_Init+0x18>
 8000708:	e77b      	b.n	8000602 <HAL_ADC_Init+0x22>
    return HAL_ERROR;
 800070a:	2001      	movs	r0, #1
}
 800070c:	4770      	bx	lr
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 800070e:	689a      	ldr	r2, [r3, #8]
 8000710:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8000714:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8000716:	689a      	ldr	r2, [r3, #8]
 8000718:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800071c:	609a      	str	r2, [r3, #8]
 800071e:	e7af      	b.n	8000680 <HAL_ADC_Init+0xa0>
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8000720:	6858      	ldr	r0, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8000722:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8000724:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8000728:	1e51      	subs	r1, r2, #1
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 800072a:	6058      	str	r0, [r3, #4]
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 800072c:	685a      	ldr	r2, [r3, #4]
 800072e:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8000732:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8000734:	685a      	ldr	r2, [r3, #4]
 8000736:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 800073a:	605a      	str	r2, [r3, #4]
 800073c:	e7b1      	b.n	80006a2 <HAL_ADC_Init+0xc2>
 800073e:	bf00      	nop
 8000740:	ffffeefd 	.word	0xffffeefd
 8000744:	40012300 	.word	0x40012300
 8000748:	0f000001 	.word	0x0f000001

0800074c <HAL_ADC_Start>:
  __HAL_LOCK(hadc);
 800074c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  __IO uint32_t counter = 0;
 8000750:	2200      	movs	r2, #0
{
 8000752:	b410      	push	{r4}
  __HAL_LOCK(hadc);
 8000754:	2b01      	cmp	r3, #1
{
 8000756:	b083      	sub	sp, #12
  __IO uint32_t counter = 0;
 8000758:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800075a:	d070      	beq.n	800083e <HAL_ADC_Start+0xf2>
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 800075c:	6802      	ldr	r2, [r0, #0]
  __HAL_LOCK(hadc);
 800075e:	2101      	movs	r1, #1
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8000760:	6893      	ldr	r3, [r2, #8]
  __HAL_LOCK(hadc);
 8000762:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8000766:	07d9      	lsls	r1, r3, #31
 8000768:	d414      	bmi.n	8000794 <HAL_ADC_Start+0x48>
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800076a:	4b37      	ldr	r3, [pc, #220]	; (8000848 <HAL_ADC_Start+0xfc>)
 800076c:	4c37      	ldr	r4, [pc, #220]	; (800084c <HAL_ADC_Start+0x100>)
 800076e:	681b      	ldr	r3, [r3, #0]
    __HAL_ADC_ENABLE(hadc);
 8000770:	6891      	ldr	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8000772:	fba4 4303 	umull	r4, r3, r4, r3
    __HAL_ADC_ENABLE(hadc);
 8000776:	f041 0101 	orr.w	r1, r1, #1
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800077a:	0c9b      	lsrs	r3, r3, #18
    __HAL_ADC_ENABLE(hadc);
 800077c:	6091      	str	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800077e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8000782:	9301      	str	r3, [sp, #4]
    while(counter != 0)
 8000784:	9b01      	ldr	r3, [sp, #4]
 8000786:	b12b      	cbz	r3, 8000794 <HAL_ADC_Start+0x48>
      counter--;
 8000788:	9b01      	ldr	r3, [sp, #4]
 800078a:	3b01      	subs	r3, #1
 800078c:	9301      	str	r3, [sp, #4]
    while(counter != 0)
 800078e:	9b01      	ldr	r3, [sp, #4]
 8000790:	2b00      	cmp	r3, #0
 8000792:	d1f9      	bne.n	8000788 <HAL_ADC_Start+0x3c>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 8000794:	6893      	ldr	r3, [r2, #8]
 8000796:	07db      	lsls	r3, r3, #31
 8000798:	d524      	bpl.n	80007e4 <HAL_ADC_Start+0x98>
    ADC_STATE_CLR_SET(hadc->State,
 800079a:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800079c:	4b2c      	ldr	r3, [pc, #176]	; (8000850 <HAL_ADC_Start+0x104>)
 800079e:	400b      	ands	r3, r1
 80007a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80007a4:	6403      	str	r3, [r0, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80007a6:	6853      	ldr	r3, [r2, #4]
 80007a8:	055c      	lsls	r4, r3, #21
 80007aa:	d505      	bpl.n	80007b8 <HAL_ADC_Start+0x6c>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80007ac:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80007ae:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80007b2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80007b6:	6403      	str	r3, [r0, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80007b8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80007ba:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
 80007be:	d028      	beq.n	8000812 <HAL_ADC_Start+0xc6>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80007c0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80007c2:	f023 0306 	bic.w	r3, r3, #6
 80007c6:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 80007c8:	f06f 0122 	mvn.w	r1, #34	; 0x22
    __HAL_UNLOCK(hadc);
 80007cc:	2400      	movs	r4, #0
    if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 80007ce:	4b21      	ldr	r3, [pc, #132]	; (8000854 <HAL_ADC_Start+0x108>)
    __HAL_UNLOCK(hadc);
 80007d0:	f880 403c 	strb.w	r4, [r0, #60]	; 0x3c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 80007d4:	6011      	str	r1, [r2, #0]
    if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 80007d6:	6859      	ldr	r1, [r3, #4]
 80007d8:	06c9      	lsls	r1, r1, #27
 80007da:	d108      	bne.n	80007ee <HAL_ADC_Start+0xa2>
      if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 80007dc:	6890      	ldr	r0, [r2, #8]
 80007de:	f010 5040 	ands.w	r0, r0, #805306368	; 0x30000000
 80007e2:	d018      	beq.n	8000816 <HAL_ADC_Start+0xca>
  return HAL_OK;
 80007e4:	2000      	movs	r0, #0
}
 80007e6:	b003      	add	sp, #12
 80007e8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007ec:	4770      	bx	lr
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80007ee:	491a      	ldr	r1, [pc, #104]	; (8000858 <HAL_ADC_Start+0x10c>)
 80007f0:	428a      	cmp	r2, r1
 80007f2:	d018      	beq.n	8000826 <HAL_ADC_Start+0xda>
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 80007f4:	685b      	ldr	r3, [r3, #4]
        if((hadc->Instance == ADC3) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80007f6:	06db      	lsls	r3, r3, #27
 80007f8:	d4f4      	bmi.n	80007e4 <HAL_ADC_Start+0x98>
 80007fa:	4918      	ldr	r1, [pc, #96]	; (800085c <HAL_ADC_Start+0x110>)
 80007fc:	428a      	cmp	r2, r1
 80007fe:	d1f1      	bne.n	80007e4 <HAL_ADC_Start+0x98>
 8000800:	6888      	ldr	r0, [r1, #8]
 8000802:	f010 5040 	ands.w	r0, r0, #805306368	; 0x30000000
 8000806:	d1ed      	bne.n	80007e4 <HAL_ADC_Start+0x98>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8000808:	688b      	ldr	r3, [r1, #8]
 800080a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800080e:	608b      	str	r3, [r1, #8]
 8000810:	e7e9      	b.n	80007e6 <HAL_ADC_Start+0x9a>
      ADC_CLEAR_ERRORCODE(hadc);
 8000812:	6443      	str	r3, [r0, #68]	; 0x44
 8000814:	e7d8      	b.n	80007c8 <HAL_ADC_Start+0x7c>
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8000816:	6893      	ldr	r3, [r2, #8]
 8000818:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800081c:	6093      	str	r3, [r2, #8]
}
 800081e:	b003      	add	sp, #12
 8000820:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000824:	4770      	bx	lr
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8000826:	6893      	ldr	r3, [r2, #8]
 8000828:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 800082c:	d103      	bne.n	8000836 <HAL_ADC_Start+0xea>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 800082e:	6893      	ldr	r3, [r2, #8]
 8000830:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000834:	6093      	str	r3, [r2, #8]
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 8000836:	4b07      	ldr	r3, [pc, #28]	; (8000854 <HAL_ADC_Start+0x108>)
  return HAL_OK;
 8000838:	2000      	movs	r0, #0
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 800083a:	685b      	ldr	r3, [r3, #4]
 800083c:	e7d3      	b.n	80007e6 <HAL_ADC_Start+0x9a>
  __HAL_LOCK(hadc);
 800083e:	2002      	movs	r0, #2
}
 8000840:	b003      	add	sp, #12
 8000842:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000846:	4770      	bx	lr
 8000848:	20001f48 	.word	0x20001f48
 800084c:	431bde83 	.word	0x431bde83
 8000850:	fffff8fe 	.word	0xfffff8fe
 8000854:	40012300 	.word	0x40012300
 8000858:	40012000 	.word	0x40012000
 800085c:	40012200 	.word	0x40012200

08000860 <HAL_ADC_PollForConversion>:
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8000860:	6803      	ldr	r3, [r0, #0]
 8000862:	689a      	ldr	r2, [r3, #8]
{
 8000864:	b570      	push	{r4, r5, r6, lr}
 8000866:	4604      	mov	r4, r0
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8000868:	0550      	lsls	r0, r2, #21
 800086a:	d502      	bpl.n	8000872 <HAL_ADC_PollForConversion+0x12>
      HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
 800086c:	689b      	ldr	r3, [r3, #8]
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 800086e:	05da      	lsls	r2, r3, #23
 8000870:	d43e      	bmi.n	80008f0 <HAL_ADC_PollForConversion+0x90>
 8000872:	460d      	mov	r5, r1
  tickstart = HAL_GetTick();
 8000874:	f7ff fe9c 	bl	80005b0 <HAL_GetTick>
 8000878:	4606      	mov	r6, r0
 800087a:	1c6b      	adds	r3, r5, #1
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 800087c:	6822      	ldr	r2, [r4, #0]
 800087e:	d125      	bne.n	80008cc <HAL_ADC_PollForConversion+0x6c>
 8000880:	6813      	ldr	r3, [r2, #0]
 8000882:	0798      	lsls	r0, r3, #30
 8000884:	d5fc      	bpl.n	8000880 <HAL_ADC_PollForConversion+0x20>
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 8000886:	f06f 0312 	mvn.w	r3, #18
 800088a:	6013      	str	r3, [r2, #0]
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 800088c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800088e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000892:	6423      	str	r3, [r4, #64]	; 0x40
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 8000894:	6893      	ldr	r3, [r2, #8]
 8000896:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 800089a:	d115      	bne.n	80008c8 <HAL_ADC_PollForConversion+0x68>
 800089c:	69a3      	ldr	r3, [r4, #24]
 800089e:	b99b      	cbnz	r3, 80008c8 <HAL_ADC_PollForConversion+0x68>
     (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
 80008a0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     (hadc->Init.ContinuousConvMode == DISABLE)            &&
 80008a2:	f413 0f70 	tst.w	r3, #15728640	; 0xf00000
 80008a6:	d002      	beq.n	80008ae <HAL_ADC_PollForConversion+0x4e>
      HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 80008a8:	6893      	ldr	r3, [r2, #8]
     (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
 80008aa:	055b      	lsls	r3, r3, #21
 80008ac:	d40c      	bmi.n	80008c8 <HAL_ADC_PollForConversion+0x68>
    CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 80008ae:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80008b0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80008b4:	6423      	str	r3, [r4, #64]	; 0x40
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80008b6:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80008b8:	f410 5080 	ands.w	r0, r0, #4096	; 0x1000
 80008bc:	d104      	bne.n	80008c8 <HAL_ADC_PollForConversion+0x68>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80008be:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80008c0:	f043 0301 	orr.w	r3, r3, #1
 80008c4:	6423      	str	r3, [r4, #64]	; 0x40
}
 80008c6:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 80008c8:	2000      	movs	r0, #0
}
 80008ca:	bd70      	pop	{r4, r5, r6, pc}
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 80008cc:	6813      	ldr	r3, [r2, #0]
 80008ce:	0799      	lsls	r1, r3, #30
 80008d0:	d4d9      	bmi.n	8000886 <HAL_ADC_PollForConversion+0x26>
      if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 80008d2:	b125      	cbz	r5, 80008de <HAL_ADC_PollForConversion+0x7e>
 80008d4:	f7ff fe6c 	bl	80005b0 <HAL_GetTick>
 80008d8:	1b80      	subs	r0, r0, r6
 80008da:	42a8      	cmp	r0, r5
 80008dc:	d9cd      	bls.n	800087a <HAL_ADC_PollForConversion+0x1a>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008de:	6c23      	ldr	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hadc);
 80008e0:	2200      	movs	r2, #0
        return HAL_TIMEOUT;
 80008e2:	2003      	movs	r0, #3
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008e4:	f043 0304 	orr.w	r3, r3, #4
        __HAL_UNLOCK(hadc);
 80008e8:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008ec:	6423      	str	r3, [r4, #64]	; 0x40
}
 80008ee:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008f0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    __HAL_UNLOCK(hadc);
 80008f2:	2200      	movs	r2, #0
    return HAL_ERROR;
 80008f4:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008f6:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
 80008fa:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008fe:	6423      	str	r3, [r4, #64]	; 0x40
}
 8000900:	bd70      	pop	{r4, r5, r6, pc}
 8000902:	bf00      	nop

08000904 <HAL_ADC_GetValue>:
  return hadc->Instance->DR;
 8000904:	6803      	ldr	r3, [r0, #0]
 8000906:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
}
 8000908:	4770      	bx	lr
 800090a:	bf00      	nop

0800090c <HAL_ADC_ConfigChannel>:
  __HAL_LOCK(hadc);
 800090c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  __IO uint32_t counter = 0;
 8000910:	2200      	movs	r2, #0
{
 8000912:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hadc);
 8000914:	2b01      	cmp	r3, #1
{
 8000916:	b083      	sub	sp, #12
  __IO uint32_t counter = 0;
 8000918:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800091a:	f000 809a 	beq.w	8000a52 <HAL_ADC_ConfigChannel+0x146>
	if (sConfig->Channel > ADC_CHANNEL_9)
 800091e:	680d      	ldr	r5, [r1, #0]
  __HAL_LOCK(hadc);
 8000920:	2201      	movs	r2, #1
 8000922:	6803      	ldr	r3, [r0, #0]
	if (sConfig->Channel > ADC_CHANNEL_9)
 8000924:	2d09      	cmp	r5, #9
  __HAL_LOCK(hadc);
 8000926:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
 800092a:	b2af      	uxth	r7, r5
 800092c:	688a      	ldr	r2, [r1, #8]
	if (sConfig->Channel > ADC_CHANNEL_9)
 800092e:	d828      	bhi.n	8000982 <HAL_ADC_ConfigChannel+0x76>
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8000930:	eb05 0645 	add.w	r6, r5, r5, lsl #1
 8000934:	f04f 0c07 	mov.w	ip, #7
 8000938:	691c      	ldr	r4, [r3, #16]
 800093a:	fa0c fc06 	lsl.w	ip, ip, r6
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 800093e:	fa02 f606 	lsl.w	r6, r2, r6
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8000942:	ea24 040c 	bic.w	r4, r4, ip
 8000946:	611c      	str	r4, [r3, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8000948:	691a      	ldr	r2, [r3, #16]
 800094a:	4316      	orrs	r6, r2
 800094c:	611e      	str	r6, [r3, #16]
  if (sConfig->Rank < 7)
 800094e:	684e      	ldr	r6, [r1, #4]
 8000950:	2e06      	cmp	r6, #6
 8000952:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 8000956:	d82d      	bhi.n	80009b4 <HAL_ADC_ConfigChannel+0xa8>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8000958:	3a05      	subs	r2, #5
 800095a:	241f      	movs	r4, #31
 800095c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800095e:	4094      	lsls	r4, r2
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8000960:	fa07 f202 	lsl.w	r2, r7, r2
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8000964:	ea21 0104 	bic.w	r1, r1, r4
 8000968:	6359      	str	r1, [r3, #52]	; 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 800096a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800096c:	430a      	orrs	r2, r1
 800096e:	635a      	str	r2, [r3, #52]	; 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8000970:	4a3c      	ldr	r2, [pc, #240]	; (8000a64 <HAL_ADC_ConfigChannel+0x158>)
 8000972:	4293      	cmp	r3, r2
 8000974:	d030      	beq.n	80009d8 <HAL_ADC_ConfigChannel+0xcc>
  __HAL_UNLOCK(hadc);
 8000976:	2300      	movs	r3, #0
 8000978:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 800097c:	4618      	mov	r0, r3
}
 800097e:	b003      	add	sp, #12
 8000980:	bdf0      	pop	{r4, r5, r6, r7, pc}
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000982:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 8000986:	f04f 0c07 	mov.w	ip, #7
 800098a:	68dc      	ldr	r4, [r3, #12]
 800098c:	3e1e      	subs	r6, #30
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 800098e:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 8000a68 <HAL_ADC_ConfigChannel+0x15c>
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000992:	fa0c fc06 	lsl.w	ip, ip, r6
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8000996:	4575      	cmp	r5, lr
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000998:	ea24 040c 	bic.w	r4, r4, ip
 800099c:	60dc      	str	r4, [r3, #12]
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 800099e:	d05b      	beq.n	8000a58 <HAL_ADC_ConfigChannel+0x14c>
		  hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 80009a0:	fa02 f606 	lsl.w	r6, r2, r6
 80009a4:	68da      	ldr	r2, [r3, #12]
 80009a6:	4316      	orrs	r6, r2
 80009a8:	60de      	str	r6, [r3, #12]
  if (sConfig->Rank < 7)
 80009aa:	684e      	ldr	r6, [r1, #4]
 80009ac:	2e06      	cmp	r6, #6
 80009ae:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 80009b2:	d9d1      	bls.n	8000958 <HAL_ADC_ConfigChannel+0x4c>
  else if (sConfig->Rank < 13)
 80009b4:	2e0c      	cmp	r6, #12
 80009b6:	d837      	bhi.n	8000a28 <HAL_ADC_ConfigChannel+0x11c>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80009b8:	f1a2 0423 	sub.w	r4, r2, #35	; 0x23
 80009bc:	261f      	movs	r6, #31
 80009be:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80009c0:	40a6      	lsls	r6, r4
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80009c2:	fa07 f204 	lsl.w	r2, r7, r4
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80009c6:	ea21 0106 	bic.w	r1, r1, r6
 80009ca:	6319      	str	r1, [r3, #48]	; 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80009cc:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80009ce:	4314      	orrs	r4, r2
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80009d0:	4a24      	ldr	r2, [pc, #144]	; (8000a64 <HAL_ADC_ConfigChannel+0x158>)
 80009d2:	4293      	cmp	r3, r2
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80009d4:	631c      	str	r4, [r3, #48]	; 0x30
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80009d6:	d1ce      	bne.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
 80009d8:	2d12      	cmp	r5, #18
 80009da:	d033      	beq.n	8000a44 <HAL_ADC_ConfigChannel+0x138>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80009dc:	4b22      	ldr	r3, [pc, #136]	; (8000a68 <HAL_ADC_ConfigChannel+0x15c>)
 80009de:	429d      	cmp	r5, r3
 80009e0:	d001      	beq.n	80009e6 <HAL_ADC_ConfigChannel+0xda>
 80009e2:	2d11      	cmp	r5, #17
 80009e4:	d1c7      	bne.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009e6:	4a21      	ldr	r2, [pc, #132]	; (8000a6c <HAL_ADC_ConfigChannel+0x160>)
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009e8:	491f      	ldr	r1, [pc, #124]	; (8000a68 <HAL_ADC_ConfigChannel+0x15c>)
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009ea:	6853      	ldr	r3, [r2, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009ec:	428d      	cmp	r5, r1
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009ee:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80009f2:	6053      	str	r3, [r2, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009f4:	d1bf      	bne.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80009f6:	f102 7246 	add.w	r2, r2, #51904512	; 0x3180000
 80009fa:	4b1d      	ldr	r3, [pc, #116]	; (8000a70 <HAL_ADC_ConfigChannel+0x164>)
 80009fc:	f502 322e 	add.w	r2, r2, #178176	; 0x2b800
 8000a00:	681b      	ldr	r3, [r3, #0]
 8000a02:	f202 3283 	addw	r2, r2, #899	; 0x383
 8000a06:	fba2 2303 	umull	r2, r3, r2, r3
 8000a0a:	0c9b      	lsrs	r3, r3, #18
 8000a0c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000a10:	005b      	lsls	r3, r3, #1
 8000a12:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	2b00      	cmp	r3, #0
 8000a18:	d0ad      	beq.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
        counter--;
 8000a1a:	9b01      	ldr	r3, [sp, #4]
 8000a1c:	3b01      	subs	r3, #1
 8000a1e:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 8000a20:	9b01      	ldr	r3, [sp, #4]
 8000a22:	2b00      	cmp	r3, #0
 8000a24:	d1f9      	bne.n	8000a1a <HAL_ADC_ConfigChannel+0x10e>
 8000a26:	e7a6      	b.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8000a28:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 8000a2c:	261f      	movs	r6, #31
 8000a2e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 8000a30:	408e      	lsls	r6, r1
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8000a32:	fa07 f201 	lsl.w	r2, r7, r1
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8000a36:	ea24 0406 	bic.w	r4, r4, r6
 8000a3a:	62dc      	str	r4, [r3, #44]	; 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8000a3c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000a3e:	430a      	orrs	r2, r1
 8000a40:	62da      	str	r2, [r3, #44]	; 0x2c
 8000a42:	e795      	b.n	8000970 <HAL_ADC_ConfigChannel+0x64>
    ADC->CCR |= ADC_CCR_VBATE;
 8000a44:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
 8000a48:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000a4c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
 8000a50:	e791      	b.n	8000976 <HAL_ADC_ConfigChannel+0x6a>
  __HAL_LOCK(hadc);
 8000a52:	2002      	movs	r0, #2
}
 8000a54:	b003      	add	sp, #12
 8000a56:	bdf0      	pop	{r4, r5, r6, r7, pc}
			hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, ADC_CHANNEL_18);
 8000a58:	68de      	ldr	r6, [r3, #12]
 8000a5a:	ea46 6602 	orr.w	r6, r6, r2, lsl #24
 8000a5e:	60de      	str	r6, [r3, #12]
 8000a60:	e775      	b.n	800094e <HAL_ADC_ConfigChannel+0x42>
 8000a62:	bf00      	nop
 8000a64:	40012000 	.word	0x40012000
 8000a68:	10000012 	.word	0x10000012
 8000a6c:	40012300 	.word	0x40012300
 8000a70:	20001f48 	.word	0x20001f48

08000a74 <HAL_ADCEx_InjectedConfigChannel>:
  {
    assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8000a74:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8000a78:	2b01      	cmp	r3, #1
 8000a7a:	f000 80ca 	beq.w	8000c12 <HAL_ADCEx_InjectedConfigChannel+0x19e>
 8000a7e:	2201      	movs	r2, #1
 8000a80:	6803      	ldr	r3, [r0, #0]
{
 8000a82:	b4f0      	push	{r4, r5, r6, r7}
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 8000a84:	680d      	ldr	r5, [r1, #0]
 8000a86:	688e      	ldr	r6, [r1, #8]
 8000a88:	2d09      	cmp	r5, #9
  __HAL_LOCK(hadc);
 8000a8a:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
 8000a8e:	b2ac      	uxth	r4, r5
  if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
 8000a90:	d866      	bhi.n	8000b60 <HAL_ADCEx_InjectedConfigChannel+0xec>
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 8000a92:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8000a96:	f04f 0c07 	mov.w	ip, #7
 8000a9a:	691f      	ldr	r7, [r3, #16]
 8000a9c:	fa0c fc02 	lsl.w	ip, ip, r2
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8000aa0:	fa06 f202 	lsl.w	r2, r6, r2
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
 8000aa4:	ea27 070c 	bic.w	r7, r7, ip
 8000aa8:	611f      	str	r7, [r3, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8000aaa:	691e      	ldr	r6, [r3, #16]
 8000aac:	4332      	orrs	r2, r6
 8000aae:	611a      	str	r2, [r3, #16]
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
  
  /* Rank configuration */
  
  /* Clear the old SQx bits for the selected rank */
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ab0:	684f      	ldr	r7, [r1, #4]
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 8000ab2:	f8d3 c038 	ldr.w	ip, [r3, #56]	; 0x38
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8000ab6:	690e      	ldr	r6, [r1, #16]
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ab8:	1cfa      	adds	r2, r7, #3
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 8000aba:	f42c 1c40 	bic.w	ip, ip, #3145728	; 0x300000
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000abe:	1b92      	subs	r2, r2, r6
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8000ac0:	3e01      	subs	r6, #1
  hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
 8000ac2:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ac6:	b2d2      	uxtb	r2, r2
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8000ac8:	f8d3 c038 	ldr.w	ip, [r3, #56]	; 0x38
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000acc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8000ad0:	ea4c 5c06 	orr.w	ip, ip, r6, lsl #20
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ad4:	261f      	movs	r6, #31
   
  /* Set the SQx bits for the selected rank */
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ad6:	4094      	lsls	r4, r2
  hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
 8000ad8:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000adc:	4096      	lsls	r6, r2
 8000ade:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */ 
  if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8000ae0:	f8d1 c018 	ldr.w	ip, [r1, #24]
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000ae4:	ea22 0206 	bic.w	r2, r2, r6
  if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8000ae8:	4e4b      	ldr	r6, [pc, #300]	; (8000c18 <HAL_ADCEx_InjectedConfigChannel+0x1a4>)
  hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000aea:	639a      	str	r2, [r3, #56]	; 0x38
  if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8000aec:	45b4      	cmp	ip, r6
  hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
 8000aee:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000af0:	ea44 0402 	orr.w	r4, r4, r2
 8000af4:	639c      	str	r4, [r3, #56]	; 0x38
  if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8000af6:	d06c      	beq.n	8000bd2 <HAL_ADCEx_InjectedConfigChannel+0x15e>
  {  
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8000af8:	689c      	ldr	r4, [r3, #8]
    hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
    hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8000afa:	69ce      	ldr	r6, [r1, #28]
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8000afc:	f424 2470 	bic.w	r4, r4, #983040	; 0xf0000
 8000b00:	609c      	str	r4, [r3, #8]
    hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
 8000b02:	689a      	ldr	r2, [r3, #8]
 8000b04:	ea4c 0202 	orr.w	r2, ip, r2
 8000b08:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 8000b0a:	689c      	ldr	r4, [r3, #8]
 8000b0c:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8000b10:	609c      	str	r4, [r3, #8]
    hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
 8000b12:	689a      	ldr	r2, [r3, #8]
 8000b14:	4332      	orrs	r2, r6
 8000b16:	609a      	str	r2, [r3, #8]
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);  
  }
  
  if (sConfigInjected->AutoInjectedConv != DISABLE)
 8000b18:	7d4a      	ldrb	r2, [r1, #21]
 8000b1a:	2a00      	cmp	r2, #0
 8000b1c:	d054      	beq.n	8000bc8 <HAL_ADCEx_InjectedConfigChannel+0x154>
  {
    /* Enable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 |= ADC_CR1_JAUTO;
 8000b1e:	685a      	ldr	r2, [r3, #4]
 8000b20:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000b24:	605a      	str	r2, [r3, #4]
  {
    /* Disable the selected ADC automatic injected group conversion */
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
  }
  
  if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
 8000b26:	7d0a      	ldrb	r2, [r1, #20]
 8000b28:	b35a      	cbz	r2, 8000b82 <HAL_ADCEx_InjectedConfigChannel+0x10e>
  {
    /* Enable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 8000b2a:	685a      	ldr	r2, [r3, #4]
  {
    /* Disable the selected ADC injected discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
  }
  
  switch(sConfigInjected->InjectedRank)
 8000b2c:	2f02      	cmp	r7, #2
    hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
 8000b2e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000b32:	605a      	str	r2, [r3, #4]
 8000b34:	68ca      	ldr	r2, [r1, #12]
  switch(sConfigInjected->InjectedRank)
 8000b36:	d02b      	beq.n	8000b90 <HAL_ADCEx_InjectedConfigChannel+0x11c>
 8000b38:	2f03      	cmp	r7, #3
 8000b3a:	d05b      	beq.n	8000bf4 <HAL_ADCEx_InjectedConfigChannel+0x180>
 8000b3c:	2f01      	cmp	r7, #1
 8000b3e:	d051      	beq.n	8000be4 <HAL_ADCEx_InjectedConfigChannel+0x170>
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
      break;
    default:
      /* Set injected channel 4 offset */
      hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
 8000b40:	6a1c      	ldr	r4, [r3, #32]
 8000b42:	4936      	ldr	r1, [pc, #216]	; (8000c1c <HAL_ADCEx_InjectedConfigChannel+0x1a8>)
 8000b44:	4021      	ands	r1, r4
 8000b46:	6219      	str	r1, [r3, #32]
      hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
 8000b48:	6a19      	ldr	r1, [r3, #32]
 8000b4a:	430a      	orrs	r2, r1
 8000b4c:	621a      	str	r2, [r3, #32]
      break;
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 8000b4e:	4a34      	ldr	r2, [pc, #208]	; (8000c20 <HAL_ADCEx_InjectedConfigChannel+0x1ac>)
 8000b50:	4293      	cmp	r3, r2
 8000b52:	d027      	beq.n	8000ba4 <HAL_ADCEx_InjectedConfigChannel+0x130>
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8000b54:	2300      	movs	r3, #0
  
  /* Return function status */
  return HAL_OK;
}
 8000b56:	bcf0      	pop	{r4, r5, r6, r7}
  __HAL_UNLOCK(hadc);
 8000b58:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8000b5c:	4618      	mov	r0, r3
}
 8000b5e:	4770      	bx	lr
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 8000b60:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8000b64:	f04f 0c07 	mov.w	ip, #7
 8000b68:	68df      	ldr	r7, [r3, #12]
 8000b6a:	3a1e      	subs	r2, #30
 8000b6c:	fa0c fc02 	lsl.w	ip, ip, r2
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8000b70:	fa06 f202 	lsl.w	r2, r6, r2
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
 8000b74:	ea27 070c 	bic.w	r7, r7, ip
 8000b78:	60df      	str	r7, [r3, #12]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
 8000b7a:	68de      	ldr	r6, [r3, #12]
 8000b7c:	4332      	orrs	r2, r6
 8000b7e:	60da      	str	r2, [r3, #12]
 8000b80:	e796      	b.n	8000ab0 <HAL_ADCEx_InjectedConfigChannel+0x3c>
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 8000b82:	685a      	ldr	r2, [r3, #4]
  switch(sConfigInjected->InjectedRank)
 8000b84:	2f02      	cmp	r7, #2
    hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
 8000b86:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000b8a:	605a      	str	r2, [r3, #4]
 8000b8c:	68ca      	ldr	r2, [r1, #12]
  switch(sConfigInjected->InjectedRank)
 8000b8e:	d1d3      	bne.n	8000b38 <HAL_ADCEx_InjectedConfigChannel+0xc4>
      hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
 8000b90:	699c      	ldr	r4, [r3, #24]
 8000b92:	4922      	ldr	r1, [pc, #136]	; (8000c1c <HAL_ADCEx_InjectedConfigChannel+0x1a8>)
 8000b94:	4021      	ands	r1, r4
 8000b96:	6199      	str	r1, [r3, #24]
      hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
 8000b98:	6999      	ldr	r1, [r3, #24]
 8000b9a:	430a      	orrs	r2, r1
 8000b9c:	619a      	str	r2, [r3, #24]
  if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
 8000b9e:	4a20      	ldr	r2, [pc, #128]	; (8000c20 <HAL_ADCEx_InjectedConfigChannel+0x1ac>)
 8000ba0:	4293      	cmp	r3, r2
 8000ba2:	d1d7      	bne.n	8000b54 <HAL_ADCEx_InjectedConfigChannel+0xe0>
 8000ba4:	2d12      	cmp	r5, #18
 8000ba6:	d02d      	beq.n	8000c04 <HAL_ADCEx_InjectedConfigChannel+0x190>
  if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
 8000ba8:	4b1e      	ldr	r3, [pc, #120]	; (8000c24 <HAL_ADCEx_InjectedConfigChannel+0x1b0>)
 8000baa:	429d      	cmp	r5, r3
 8000bac:	d001      	beq.n	8000bb2 <HAL_ADCEx_InjectedConfigChannel+0x13e>
 8000bae:	2d11      	cmp	r5, #17
 8000bb0:	d1d0      	bne.n	8000b54 <HAL_ADCEx_InjectedConfigChannel+0xe0>
    ADC->CCR |= ADC_CCR_TSVREFE;
 8000bb2:	4a1d      	ldr	r2, [pc, #116]	; (8000c28 <HAL_ADCEx_InjectedConfigChannel+0x1b4>)
 8000bb4:	6853      	ldr	r3, [r2, #4]
 8000bb6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000bba:	6053      	str	r3, [r2, #4]
  __HAL_UNLOCK(hadc);
 8000bbc:	2300      	movs	r3, #0
}
 8000bbe:	bcf0      	pop	{r4, r5, r6, r7}
  __HAL_UNLOCK(hadc);
 8000bc0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8000bc4:	4618      	mov	r0, r3
}
 8000bc6:	4770      	bx	lr
    hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
 8000bc8:	685a      	ldr	r2, [r3, #4]
 8000bca:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000bce:	605a      	str	r2, [r3, #4]
 8000bd0:	e7a9      	b.n	8000b26 <HAL_ADCEx_InjectedConfigChannel+0xb2>
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
 8000bd2:	689a      	ldr	r2, [r3, #8]
 8000bd4:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8000bd8:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);  
 8000bda:	689a      	ldr	r2, [r3, #8]
 8000bdc:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8000be0:	609a      	str	r2, [r3, #8]
 8000be2:	e799      	b.n	8000b18 <HAL_ADCEx_InjectedConfigChannel+0xa4>
      hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
 8000be4:	695c      	ldr	r4, [r3, #20]
 8000be6:	490d      	ldr	r1, [pc, #52]	; (8000c1c <HAL_ADCEx_InjectedConfigChannel+0x1a8>)
 8000be8:	4021      	ands	r1, r4
 8000bea:	6159      	str	r1, [r3, #20]
      hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
 8000bec:	6959      	ldr	r1, [r3, #20]
 8000bee:	430a      	orrs	r2, r1
 8000bf0:	615a      	str	r2, [r3, #20]
      break;
 8000bf2:	e7ac      	b.n	8000b4e <HAL_ADCEx_InjectedConfigChannel+0xda>
      hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
 8000bf4:	69dc      	ldr	r4, [r3, #28]
 8000bf6:	4909      	ldr	r1, [pc, #36]	; (8000c1c <HAL_ADCEx_InjectedConfigChannel+0x1a8>)
 8000bf8:	4021      	ands	r1, r4
 8000bfa:	61d9      	str	r1, [r3, #28]
      hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
 8000bfc:	69d9      	ldr	r1, [r3, #28]
 8000bfe:	430a      	orrs	r2, r1
 8000c00:	61da      	str	r2, [r3, #28]
      break;
 8000c02:	e7a4      	b.n	8000b4e <HAL_ADCEx_InjectedConfigChannel+0xda>
    ADC->CCR |= ADC_CCR_VBATE;
 8000c04:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
 8000c08:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000c0c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
 8000c10:	e7a0      	b.n	8000b54 <HAL_ADCEx_InjectedConfigChannel+0xe0>
  __HAL_LOCK(hadc);
 8000c12:	2002      	movs	r0, #2
}
 8000c14:	4770      	bx	lr
 8000c16:	bf00      	nop
 8000c18:	000f0001 	.word	0x000f0001
 8000c1c:	fffff000 	.word	0xfffff000
 8000c20:	40012000 	.word	0x40012000
 8000c24:	10000012 	.word	0x10000012
 8000c28:	40012300 	.word	0x40012300

08000c2c <HAL_CAN_Init>:
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
  uint32_t tickstart;

  /* Check CAN handle */
  if (hcan == NULL)
 8000c2c:	2800      	cmp	r0, #0
 8000c2e:	d07c      	beq.n	8000d2a <HAL_CAN_Init+0xfe>
    /* Init the low level hardware: CLOCK, NVIC */
    hcan->MspInitCallback(hcan);
  }

#else
  if (hcan->State == HAL_CAN_STATE_RESET)
 8000c30:	f890 3020 	ldrb.w	r3, [r0, #32]
{
 8000c34:	b570      	push	{r4, r5, r6, lr}
 8000c36:	4604      	mov	r4, r0
  if (hcan->State == HAL_CAN_STATE_RESET)
 8000c38:	2b00      	cmp	r3, #0
 8000c3a:	d073      	beq.n	8000d24 <HAL_CAN_Init+0xf8>
    HAL_CAN_MspInit(hcan);
  }
#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 8000c3c:	6822      	ldr	r2, [r4, #0]
 8000c3e:	6813      	ldr	r3, [r2, #0]
 8000c40:	f023 0302 	bic.w	r3, r3, #2
 8000c44:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000c46:	f7ff fcb3 	bl	80005b0 <HAL_GetTick>
 8000c4a:	4605      	mov	r5, r0

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8000c4c:	e004      	b.n	8000c58 <HAL_CAN_Init+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000c4e:	f7ff fcaf 	bl	80005b0 <HAL_GetTick>
 8000c52:	1b40      	subs	r0, r0, r5
 8000c54:	280a      	cmp	r0, #10
 8000c56:	d85c      	bhi.n	8000d12 <HAL_CAN_Init+0xe6>
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8000c58:	6823      	ldr	r3, [r4, #0]
 8000c5a:	685a      	ldr	r2, [r3, #4]
 8000c5c:	0791      	lsls	r1, r2, #30
 8000c5e:	d4f6      	bmi.n	8000c4e <HAL_CAN_Init+0x22>
      return HAL_ERROR;
    }
  }

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000c60:	681a      	ldr	r2, [r3, #0]
 8000c62:	f042 0201 	orr.w	r2, r2, #1
 8000c66:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000c68:	f7ff fca2 	bl	80005b0 <HAL_GetTick>
 8000c6c:	4605      	mov	r5, r0

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8000c6e:	e004      	b.n	8000c7a <HAL_CAN_Init+0x4e>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000c70:	f7ff fc9e 	bl	80005b0 <HAL_GetTick>
 8000c74:	1b40      	subs	r0, r0, r5
 8000c76:	280a      	cmp	r0, #10
 8000c78:	d84b      	bhi.n	8000d12 <HAL_CAN_Init+0xe6>
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8000c7a:	6823      	ldr	r3, [r4, #0]
 8000c7c:	685a      	ldr	r2, [r3, #4]
 8000c7e:	07d2      	lsls	r2, r2, #31
 8000c80:	d5f6      	bpl.n	8000c70 <HAL_CAN_Init+0x44>
      return HAL_ERROR;
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8000c82:	7e22      	ldrb	r2, [r4, #24]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000c84:	2500      	movs	r5, #0

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 8000c86:	2601      	movs	r6, #1
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8000c88:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000c8a:	681a      	ldr	r2, [r3, #0]
 8000c8c:	bf0c      	ite	eq
 8000c8e:	f042 0280 	orreq.w	r2, r2, #128	; 0x80
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000c92:	f022 0280 	bicne.w	r2, r2, #128	; 0x80
 8000c96:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoBusOff == ENABLE)
 8000c98:	7e62      	ldrb	r2, [r4, #25]
 8000c9a:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8000c9c:	681a      	ldr	r2, [r3, #0]
 8000c9e:	bf0c      	ite	eq
 8000ca0:	f042 0240 	orreq.w	r2, r2, #64	; 0x40
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8000ca4:	f022 0240 	bicne.w	r2, r2, #64	; 0x40
 8000ca8:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoWakeUp == ENABLE)
 8000caa:	7ea2      	ldrb	r2, [r4, #26]
 8000cac:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000cae:	681a      	ldr	r2, [r3, #0]
 8000cb0:	bf0c      	ite	eq
 8000cb2:	f042 0220 	orreq.w	r2, r2, #32
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000cb6:	f022 0220 	bicne.w	r2, r2, #32
 8000cba:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoRetransmission == ENABLE)
 8000cbc:	7ee2      	ldrb	r2, [r4, #27]
 8000cbe:	2a01      	cmp	r2, #1
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 8000cc0:	681a      	ldr	r2, [r3, #0]
 8000cc2:	bf0c      	ite	eq
 8000cc4:	f022 0210 	biceq.w	r2, r2, #16
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 8000cc8:	f042 0210 	orrne.w	r2, r2, #16
 8000ccc:	601a      	str	r2, [r3, #0]
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 8000cce:	7f22      	ldrb	r2, [r4, #28]
 8000cd0:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8000cd2:	681a      	ldr	r2, [r3, #0]
 8000cd4:	bf0c      	ite	eq
 8000cd6:	f042 0208 	orreq.w	r2, r2, #8
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8000cda:	f022 0208 	bicne.w	r2, r2, #8
 8000cde:	601a      	str	r2, [r3, #0]
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 8000ce0:	7f62      	ldrb	r2, [r4, #29]
 8000ce2:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 8000ce4:	681a      	ldr	r2, [r3, #0]
 8000ce6:	bf0c      	ite	eq
 8000ce8:	f042 0204 	orreq.w	r2, r2, #4
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 8000cec:	f022 0204 	bicne.w	r2, r2, #4
 8000cf0:	601a      	str	r2, [r3, #0]
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 8000cf2:	68e1      	ldr	r1, [r4, #12]
 8000cf4:	68a2      	ldr	r2, [r4, #8]
 8000cf6:	6960      	ldr	r0, [r4, #20]
 8000cf8:	430a      	orrs	r2, r1
 8000cfa:	6921      	ldr	r1, [r4, #16]
 8000cfc:	430a      	orrs	r2, r1
 8000cfe:	6861      	ldr	r1, [r4, #4]
 8000d00:	4302      	orrs	r2, r0
 8000d02:	3901      	subs	r1, #1

  /* Return function status */
  return HAL_OK;
 8000d04:	4628      	mov	r0, r5
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 8000d06:	430a      	orrs	r2, r1
 8000d08:	61da      	str	r2, [r3, #28]
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000d0a:	6265      	str	r5, [r4, #36]	; 0x24
  hcan->State = HAL_CAN_STATE_READY;
 8000d0c:	f884 6020 	strb.w	r6, [r4, #32]
}
 8000d10:	bd70      	pop	{r4, r5, r6, pc}
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000d12:	6a63      	ldr	r3, [r4, #36]	; 0x24
      hcan->State = HAL_CAN_STATE_ERROR;
 8000d14:	2205      	movs	r2, #5
      return HAL_ERROR;
 8000d16:	2001      	movs	r0, #1
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000d18:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000d1c:	6263      	str	r3, [r4, #36]	; 0x24
      hcan->State = HAL_CAN_STATE_ERROR;
 8000d1e:	f884 2020 	strb.w	r2, [r4, #32]
}
 8000d22:	bd70      	pop	{r4, r5, r6, pc}
    HAL_CAN_MspInit(hcan);
 8000d24:	f005 fa4c 	bl	80061c0 <HAL_CAN_MspInit>
 8000d28:	e788      	b.n	8000c3c <HAL_CAN_Init+0x10>
    return HAL_ERROR;
 8000d2a:	2001      	movs	r0, #1
}
 8000d2c:	4770      	bx	lr
 8000d2e:	bf00      	nop

08000d30 <HAL_CAN_ConfigFilter>:
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
{
  uint32_t filternbrbitpos;
  CAN_TypeDef *can_ip = hcan->Instance;
  HAL_CAN_StateTypeDef state = hcan->State;
 8000d30:	f890 3020 	ldrb.w	r3, [r0, #32]
{
 8000d34:	4602      	mov	r2, r0

  if ((state == HAL_CAN_STATE_READY) ||
 8000d36:	3b01      	subs	r3, #1
 8000d38:	2b01      	cmp	r3, #1
 8000d3a:	d905      	bls.n	8000d48 <HAL_CAN_ConfigFilter+0x18>
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000d3c:	6a43      	ldr	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 8000d3e:	2001      	movs	r0, #1
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000d40:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000d44:	6253      	str	r3, [r2, #36]	; 0x24
  }
}
 8000d46:	4770      	bx	lr
  CAN_TypeDef *can_ip = hcan->Instance;
 8000d48:	6803      	ldr	r3, [r0, #0]
    if (hcan->Instance == CAN3)
 8000d4a:	4a44      	ldr	r2, [pc, #272]	; (8000e5c <HAL_CAN_ConfigFilter+0x12c>)
 8000d4c:	4293      	cmp	r3, r2
{
 8000d4e:	b4f0      	push	{r4, r5, r6, r7}
    if (hcan->Instance == CAN3)
 8000d50:	d07c      	beq.n	8000e4c <HAL_CAN_ConfigFilter+0x11c>
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000d52:	f502 5240 	add.w	r2, r2, #12288	; 0x3000
 8000d56:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
      SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
 8000d5a:	4613      	mov	r3, r2
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000d5c:	f040 0001 	orr.w	r0, r0, #1
 8000d60:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
      CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
 8000d64:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
 8000d68:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
 8000d6c:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
      SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
 8000d70:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
 8000d74:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 8000d76:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 8000d7a:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d7e:	6948      	ldr	r0, [r1, #20]
 8000d80:	2401      	movs	r4, #1
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8000d82:	f8d3 521c 	ldr.w	r5, [r3, #540]	; 0x21c
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d86:	f000 021f 	and.w	r2, r0, #31
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8000d8a:	69ce      	ldr	r6, [r1, #28]
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d8c:	fa04 f202 	lsl.w	r2, r4, r2
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8000d90:	43d4      	mvns	r4, r2
 8000d92:	4025      	ands	r5, r4
 8000d94:	f8c3 521c 	str.w	r5, [r3, #540]	; 0x21c
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8000d98:	b3a6      	cbz	r6, 8000e04 <HAL_CAN_ConfigFilter+0xd4>
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 8000d9a:	2e01      	cmp	r6, #1
 8000d9c:	d113      	bne.n	8000dc6 <HAL_CAN_ConfigFilter+0x96>
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 8000d9e:	680d      	ldr	r5, [r1, #0]
 8000da0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8000da4:	888e      	ldrh	r6, [r1, #4]
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 8000da6:	f8d3 720c 	ldr.w	r7, [r3, #524]	; 0x20c
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000daa:	f8d1 c008 	ldr.w	ip, [r1, #8]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 8000dae:	ea46 4605 	orr.w	r6, r6, r5, lsl #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 8000db2:	898d      	ldrh	r5, [r1, #12]
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 8000db4:	4317      	orrs	r7, r2
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000db6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 8000dba:	f8c3 720c 	str.w	r7, [r3, #524]	; 0x20c
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 8000dbe:	f8c0 6240 	str.w	r6, [r0, #576]	; 0x240
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 8000dc2:	f8c0 5244 	str.w	r5, [r0, #580]	; 0x244
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 8000dc6:	6988      	ldr	r0, [r1, #24]
 8000dc8:	bb90      	cbnz	r0, 8000e30 <HAL_CAN_ConfigFilter+0x100>
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 8000dca:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
 8000dce:	4020      	ands	r0, r4
 8000dd0:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8000dd4:	6908      	ldr	r0, [r1, #16]
 8000dd6:	bb98      	cbnz	r0, 8000e40 <HAL_CAN_ConfigFilter+0x110>
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 8000dd8:	f8d3 0214 	ldr.w	r0, [r3, #532]	; 0x214
 8000ddc:	4004      	ands	r4, r0
 8000dde:	f8c3 4214 	str.w	r4, [r3, #532]	; 0x214
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 8000de2:	6a09      	ldr	r1, [r1, #32]
 8000de4:	2901      	cmp	r1, #1
 8000de6:	d104      	bne.n	8000df2 <HAL_CAN_ConfigFilter+0xc2>
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 8000de8:	f8d3 121c 	ldr.w	r1, [r3, #540]	; 0x21c
 8000dec:	430a      	orrs	r2, r1
 8000dee:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000df2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    return HAL_OK;
 8000df6:	2000      	movs	r0, #0
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000df8:	f022 0201 	bic.w	r2, r2, #1
}
 8000dfc:	bcf0      	pop	{r4, r5, r6, r7}
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000dfe:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
 8000e02:	4770      	bx	lr
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8000e04:	e9d1 c502 	ldrd	ip, r5, [r1, #8]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8000e08:	888e      	ldrh	r6, [r1, #4]
 8000e0a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000e0e:	f8d3 720c 	ldr.w	r7, [r3, #524]	; 0x20c
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8000e12:	ea46 4605 	orr.w	r6, r6, r5, lsl #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 8000e16:	880d      	ldrh	r5, [r1, #0]
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000e18:	4027      	ands	r7, r4
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000e1a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000e1e:	f8c3 720c 	str.w	r7, [r3, #524]	; 0x20c
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 8000e22:	f8c0 6240 	str.w	r6, [r0, #576]	; 0x240
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 8000e26:	f8c0 5244 	str.w	r5, [r0, #580]	; 0x244
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 8000e2a:	6988      	ldr	r0, [r1, #24]
 8000e2c:	2800      	cmp	r0, #0
 8000e2e:	d0cc      	beq.n	8000dca <HAL_CAN_ConfigFilter+0x9a>
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 8000e30:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
 8000e34:	4310      	orrs	r0, r2
 8000e36:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8000e3a:	6908      	ldr	r0, [r1, #16]
 8000e3c:	2800      	cmp	r0, #0
 8000e3e:	d0cb      	beq.n	8000dd8 <HAL_CAN_ConfigFilter+0xa8>
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 8000e40:	f8d3 0214 	ldr.w	r0, [r3, #532]	; 0x214
 8000e44:	4310      	orrs	r0, r2
 8000e46:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214
 8000e4a:	e7ca      	b.n	8000de2 <HAL_CAN_ConfigFilter+0xb2>
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000e4c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000e50:	f042 0201 	orr.w	r2, r2, #1
 8000e54:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
 8000e58:	e791      	b.n	8000d7e <HAL_CAN_ConfigFilter+0x4e>
 8000e5a:	bf00      	nop
 8000e5c:	40003400 	.word	0x40003400

08000e60 <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 8000e60:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  if (hcan->State == HAL_CAN_STATE_READY)
 8000e62:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000e66:	2b01      	cmp	r3, #1
 8000e68:	d006      	beq.n	8000e78 <HAL_CAN_Start+0x18>
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 8000e6a:	6a42      	ldr	r2, [r0, #36]	; 0x24

    return HAL_ERROR;
 8000e6c:	2301      	movs	r3, #1
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 8000e6e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8000e72:	6242      	str	r2, [r0, #36]	; 0x24
  }
}
 8000e74:	4618      	mov	r0, r3
 8000e76:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000e78:	6802      	ldr	r2, [r0, #0]
    hcan->State = HAL_CAN_STATE_LISTENING;
 8000e7a:	2302      	movs	r3, #2
 8000e7c:	4604      	mov	r4, r0
 8000e7e:	f880 3020 	strb.w	r3, [r0, #32]
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000e82:	6813      	ldr	r3, [r2, #0]
 8000e84:	f023 0301 	bic.w	r3, r3, #1
 8000e88:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8000e8a:	f7ff fb91 	bl	80005b0 <HAL_GetTick>
 8000e8e:	4605      	mov	r5, r0
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 8000e90:	e004      	b.n	8000e9c <HAL_CAN_Start+0x3c>
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000e92:	f7ff fb8d 	bl	80005b0 <HAL_GetTick>
 8000e96:	1b40      	subs	r0, r0, r5
 8000e98:	280a      	cmp	r0, #10
 8000e9a:	d807      	bhi.n	8000eac <HAL_CAN_Start+0x4c>
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 8000e9c:	6823      	ldr	r3, [r4, #0]
 8000e9e:	685b      	ldr	r3, [r3, #4]
 8000ea0:	f013 0301 	ands.w	r3, r3, #1
 8000ea4:	d1f5      	bne.n	8000e92 <HAL_CAN_Start+0x32>
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000ea6:	6263      	str	r3, [r4, #36]	; 0x24
}
 8000ea8:	4618      	mov	r0, r3
 8000eaa:	bd38      	pop	{r3, r4, r5, pc}
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000eac:	6a62      	ldr	r2, [r4, #36]	; 0x24
        hcan->State = HAL_CAN_STATE_ERROR;
 8000eae:	2105      	movs	r1, #5
        return HAL_ERROR;
 8000eb0:	2301      	movs	r3, #1
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000eb2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000eb6:	6262      	str	r2, [r4, #36]	; 0x24
        hcan->State = HAL_CAN_STATE_ERROR;
 8000eb8:	f884 1020 	strb.w	r1, [r4, #32]
        return HAL_ERROR;
 8000ebc:	e7da      	b.n	8000e74 <HAL_CAN_Start+0x14>
 8000ebe:	bf00      	nop

08000ec0 <HAL_CAN_GetRxMessage>:
  *         of the Rx frame will be stored.
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
 8000ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_CAN_StateTypeDef state = hcan->State;
 8000ec4:	f890 5020 	ldrb.w	r5, [r0, #32]
{
 8000ec8:	4604      	mov	r4, r0

  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((state == HAL_CAN_STATE_READY) ||
 8000eca:	3d01      	subs	r5, #1
 8000ecc:	2d01      	cmp	r5, #1
 8000ece:	d906      	bls.n	8000ede <HAL_CAN_GetRxMessage+0x1e>
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000ed0:	6a43      	ldr	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 8000ed2:	2001      	movs	r0, #1
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000ed4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000ed8:	6263      	str	r3, [r4, #36]	; 0x24
  }
}
 8000eda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000ede:	6805      	ldr	r5, [r0, #0]
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 8000ee0:	2900      	cmp	r1, #0
 8000ee2:	d058      	beq.n	8000f96 <HAL_CAN_GetRxMessage+0xd6>
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
 8000ee4:	6928      	ldr	r0, [r5, #16]
 8000ee6:	0780      	lsls	r0, r0, #30
 8000ee8:	d058      	beq.n	8000f9c <HAL_CAN_GetRxMessage+0xdc>
 8000eea:	0108      	lsls	r0, r1, #4
 8000eec:	182e      	adds	r6, r5, r0
    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 8000eee:	f8d6 71b0 	ldr.w	r7, [r6, #432]	; 0x1b0
 8000ef2:	f007 0704 	and.w	r7, r7, #4
 8000ef6:	6097      	str	r7, [r2, #8]
    if (pHeader->IDE == CAN_ID_STD)
 8000ef8:	2f00      	cmp	r7, #0
 8000efa:	d15c      	bne.n	8000fb6 <HAL_CAN_GetRxMessage+0xf6>
      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 8000efc:	f8d6 71b0 	ldr.w	r7, [r6, #432]	; 0x1b0
 8000f00:	0d7f      	lsrs	r7, r7, #21
 8000f02:	6017      	str	r7, [r2, #0]
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_RTR_Pos;
 8000f04:	f8d6 e1b0 	ldr.w	lr, [r6, #432]	; 0x1b0
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f08:	4405      	add	r5, r0
    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 8000f0a:	f8d6 c1b4 	ldr.w	ip, [r6, #436]	; 0x1b4
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000f0e:	f8d6 71b4 	ldr.w	r7, [r6, #436]	; 0x1b4
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_RTR_Pos;
 8000f12:	f3ce 0e40 	ubfx	lr, lr, #1, #1
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f16:	f8d6 61b4 	ldr.w	r6, [r6, #436]	; 0x1b4
    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 8000f1a:	f00c 0c0f 	and.w	ip, ip, #15
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f1e:	f8d5 81b8 	ldr.w	r8, [r5, #440]	; 0x1b8
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000f22:	f3c7 2707 	ubfx	r7, r7, #8, #8
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f26:	0c36      	lsrs	r6, r6, #16
    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 8000f28:	e9c2 ec03 	strd	lr, ip, [r2, #12]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f2c:	e9c2 6705 	strd	r6, r7, [r2, #20]
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f30:	f883 8000 	strb.w	r8, [r3]
    aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
 8000f34:	6822      	ldr	r2, [r4, #0]
 8000f36:	4402      	add	r2, r0
 8000f38:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000f3c:	0a12      	lsrs	r2, r2, #8
 8000f3e:	705a      	strb	r2, [r3, #1]
    aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
 8000f40:	6822      	ldr	r2, [r4, #0]
 8000f42:	4402      	add	r2, r0
 8000f44:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000f48:	0c12      	lsrs	r2, r2, #16
 8000f4a:	709a      	strb	r2, [r3, #2]
    aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
 8000f4c:	6822      	ldr	r2, [r4, #0]
 8000f4e:	4402      	add	r2, r0
 8000f50:	f8d2 21b8 	ldr.w	r2, [r2, #440]	; 0x1b8
 8000f54:	0e12      	lsrs	r2, r2, #24
 8000f56:	70da      	strb	r2, [r3, #3]
    aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
 8000f58:	6822      	ldr	r2, [r4, #0]
 8000f5a:	4402      	add	r2, r0
 8000f5c:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000f60:	711a      	strb	r2, [r3, #4]
    aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
 8000f62:	6822      	ldr	r2, [r4, #0]
 8000f64:	4402      	add	r2, r0
 8000f66:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000f6a:	0a12      	lsrs	r2, r2, #8
 8000f6c:	715a      	strb	r2, [r3, #5]
    aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
 8000f6e:	6822      	ldr	r2, [r4, #0]
 8000f70:	4402      	add	r2, r0
 8000f72:	f8d2 21bc 	ldr.w	r2, [r2, #444]	; 0x1bc
 8000f76:	0c12      	lsrs	r2, r2, #16
 8000f78:	719a      	strb	r2, [r3, #6]
    aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
 8000f7a:	6822      	ldr	r2, [r4, #0]
 8000f7c:	4410      	add	r0, r2
 8000f7e:	f8d0 21bc 	ldr.w	r2, [r0, #444]	; 0x1bc
 8000f82:	0e12      	lsrs	r2, r2, #24
 8000f84:	71da      	strb	r2, [r3, #7]
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 8000f86:	6822      	ldr	r2, [r4, #0]
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 8000f88:	b979      	cbnz	r1, 8000faa <HAL_CAN_GetRxMessage+0xea>
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 8000f8a:	68d3      	ldr	r3, [r2, #12]
    return HAL_OK;
 8000f8c:	4608      	mov	r0, r1
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 8000f8e:	f043 0320 	orr.w	r3, r3, #32
 8000f92:	60d3      	str	r3, [r2, #12]
 8000f94:	e7a1      	b.n	8000eda <HAL_CAN_GetRxMessage+0x1a>
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
 8000f96:	68e8      	ldr	r0, [r5, #12]
 8000f98:	0786      	lsls	r6, r0, #30
 8000f9a:	d1a6      	bne.n	8000eea <HAL_CAN_GetRxMessage+0x2a>
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8000f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
        return HAL_ERROR;
 8000f9e:	2001      	movs	r0, #1
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8000fa0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000fa4:	6263      	str	r3, [r4, #36]	; 0x24
}
 8000fa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 8000faa:	6913      	ldr	r3, [r2, #16]
    return HAL_OK;
 8000fac:	2000      	movs	r0, #0
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 8000fae:	f043 0320 	orr.w	r3, r3, #32
 8000fb2:	6113      	str	r3, [r2, #16]
 8000fb4:	e791      	b.n	8000eda <HAL_CAN_GetRxMessage+0x1a>
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 8000fb6:	f8d6 71b0 	ldr.w	r7, [r6, #432]	; 0x1b0
 8000fba:	08ff      	lsrs	r7, r7, #3
 8000fbc:	6057      	str	r7, [r2, #4]
 8000fbe:	e7a1      	b.n	8000f04 <HAL_CAN_GetRxMessage+0x44>

08000fc0 <HAL_CAN_GetRxFifoFillLevel>:
  * @retval Number of messages available in Rx FIFO.
  */
uint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo)
{
  uint32_t filllevel = 0U;
  HAL_CAN_StateTypeDef state = hcan->State;
 8000fc0:	f890 3020 	ldrb.w	r3, [r0, #32]

  /* Check function parameters */
  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((state == HAL_CAN_STATE_READY) ||
 8000fc4:	3b01      	subs	r3, #1
 8000fc6:	2b01      	cmp	r3, #1
 8000fc8:	d901      	bls.n	8000fce <HAL_CAN_GetRxFifoFillLevel+0xe>
  uint32_t filllevel = 0U;
 8000fca:	2000      	movs	r0, #0
    }
  }

  /* Return Rx FIFO fill level */
  return filllevel;
}
 8000fcc:	4770      	bx	lr
 8000fce:	6803      	ldr	r3, [r0, #0]
    if (RxFifo == CAN_RX_FIFO0)
 8000fd0:	b119      	cbz	r1, 8000fda <HAL_CAN_GetRxFifoFillLevel+0x1a>
      filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;
 8000fd2:	6918      	ldr	r0, [r3, #16]
 8000fd4:	f000 0003 	and.w	r0, r0, #3
 8000fd8:	4770      	bx	lr
      filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;
 8000fda:	68d8      	ldr	r0, [r3, #12]
 8000fdc:	f000 0003 	and.w	r0, r0, #3
 8000fe0:	4770      	bx	lr
 8000fe2:	bf00      	nop

08000fe4 <HAL_CAN_TxMailbox0CompleteCallback>:
 8000fe4:	4770      	bx	lr
 8000fe6:	bf00      	nop

08000fe8 <HAL_CAN_TxMailbox1CompleteCallback>:
 8000fe8:	4770      	bx	lr
 8000fea:	bf00      	nop

08000fec <HAL_CAN_TxMailbox2CompleteCallback>:
 8000fec:	4770      	bx	lr
 8000fee:	bf00      	nop

08000ff0 <HAL_CAN_TxMailbox0AbortCallback>:
 8000ff0:	4770      	bx	lr
 8000ff2:	bf00      	nop

08000ff4 <HAL_CAN_TxMailbox1AbortCallback>:
 8000ff4:	4770      	bx	lr
 8000ff6:	bf00      	nop

08000ff8 <HAL_CAN_TxMailbox2AbortCallback>:
 8000ff8:	4770      	bx	lr
 8000ffa:	bf00      	nop

08000ffc <HAL_CAN_RxFifo0MsgPendingCallback>:
 8000ffc:	4770      	bx	lr
 8000ffe:	bf00      	nop

08001000 <HAL_CAN_RxFifo0FullCallback>:
 8001000:	4770      	bx	lr
 8001002:	bf00      	nop

08001004 <HAL_CAN_RxFifo1MsgPendingCallback>:
 8001004:	4770      	bx	lr
 8001006:	bf00      	nop

08001008 <HAL_CAN_RxFifo1FullCallback>:
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop

0800100c <HAL_CAN_SleepCallback>:
 800100c:	4770      	bx	lr
 800100e:	bf00      	nop

08001010 <HAL_CAN_WakeUpFromRxMsgCallback>:
 8001010:	4770      	bx	lr
 8001012:	bf00      	nop

08001014 <HAL_CAN_ErrorCallback>:
 8001014:	4770      	bx	lr
 8001016:	bf00      	nop

08001018 <HAL_CAN_IRQHandler>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
{
 8001018:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t errorcode = HAL_CAN_ERROR_NONE;
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 800101c:	6803      	ldr	r3, [r0, #0]
{
 800101e:	4605      	mov	r5, r0
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 8001020:	695c      	ldr	r4, [r3, #20]
  uint32_t msrflags = READ_REG(hcan->Instance->MSR);
 8001022:	f8d3 8004 	ldr.w	r8, [r3, #4]
  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
  uint32_t esrflags = READ_REG(hcan->Instance->ESR);

  /* Transmit Mailbox empty interrupt management *****************************/
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 8001026:	f014 0601 	ands.w	r6, r4, #1
  uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
 800102a:	689f      	ldr	r7, [r3, #8]
  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
 800102c:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
 8001030:	f8d3 9010 	ldr.w	r9, [r3, #16]
  uint32_t esrflags = READ_REG(hcan->Instance->ESR);
 8001034:	f8d3 a018 	ldr.w	sl, [r3, #24]
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 8001038:	d025      	beq.n	8001086 <HAL_CAN_IRQHandler+0x6e>
  {
    /* Transmit Mailbox 0 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP0) != 0U)
 800103a:	f017 0601 	ands.w	r6, r7, #1
 800103e:	f040 809c 	bne.w	800117a <HAL_CAN_IRQHandler+0x162>
 8001042:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001046:	f44f 4180 	mov.w	r1, #16384	; 0x4000
        }
      }
    }

    /* Transmit Mailbox 1 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP1) != 0U)
 800104a:	05f8      	lsls	r0, r7, #23
 800104c:	d50d      	bpl.n	800106a <HAL_CAN_IRQHandler+0x52>
    {
      /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
 800104e:	682b      	ldr	r3, [r5, #0]
 8001050:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001054:	6098      	str	r0, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK1) != 0U)
 8001056:	05bb      	lsls	r3, r7, #22
 8001058:	f100 80c7 	bmi.w	80011ea <HAL_CAN_IRQHandler+0x1d2>
        HAL_CAN_TxMailbox1CompleteCallback(hcan);
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST1) != 0U)
 800105c:	0578      	lsls	r0, r7, #21
 800105e:	f100 80d7 	bmi.w	8001210 <HAL_CAN_IRQHandler+0x1f8>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST1;
        }
        else if ((tsrflags & CAN_TSR_TERR1) != 0U)
 8001062:	053a      	lsls	r2, r7, #20
 8001064:	f140 80e8 	bpl.w	8001238 <HAL_CAN_IRQHandler+0x220>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR1;
 8001068:	460e      	mov	r6, r1
        }
      }
    }

    /* Transmit Mailbox 2 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP2) != 0U)
 800106a:	03fb      	lsls	r3, r7, #15
 800106c:	d50b      	bpl.n	8001086 <HAL_CAN_IRQHandler+0x6e>
    {
      /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
 800106e:	682b      	ldr	r3, [r5, #0]
 8001070:	f44f 3280 	mov.w	r2, #65536	; 0x10000

      if ((tsrflags & CAN_TSR_TXOK2) != 0U)
 8001074:	03b8      	lsls	r0, r7, #14
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
 8001076:	609a      	str	r2, [r3, #8]
      if ((tsrflags & CAN_TSR_TXOK2) != 0U)
 8001078:	f100 80b3 	bmi.w	80011e2 <HAL_CAN_IRQHandler+0x1ca>
        HAL_CAN_TxMailbox2CompleteCallback(hcan);
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST2) != 0U)
 800107c:	0379      	lsls	r1, r7, #13
 800107e:	f140 80c9 	bpl.w	8001214 <HAL_CAN_IRQHandler+0x1fc>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST2;
 8001082:	f446 4600 	orr.w	r6, r6, #32768	; 0x8000
      }
    }
  }

  /* Receive FIFO 0 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
 8001086:	0723      	lsls	r3, r4, #28
 8001088:	d502      	bpl.n	8001090 <HAL_CAN_IRQHandler+0x78>
  {
    if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
 800108a:	f01b 0f10 	tst.w	fp, #16
 800108e:	d16e      	bne.n	800116e <HAL_CAN_IRQHandler+0x156>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
    }
  }

  /* Receive FIFO 0 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
 8001090:	0767      	lsls	r7, r4, #29
 8001092:	d502      	bpl.n	800109a <HAL_CAN_IRQHandler+0x82>
  {
    if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
 8001094:	f01b 0f08 	tst.w	fp, #8
 8001098:	d17f      	bne.n	800119a <HAL_CAN_IRQHandler+0x182>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 0 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
 800109a:	07a0      	lsls	r0, r4, #30
 800109c:	d504      	bpl.n	80010a8 <HAL_CAN_IRQHandler+0x90>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
 800109e:	682b      	ldr	r3, [r5, #0]
 80010a0:	68db      	ldr	r3, [r3, #12]
 80010a2:	0799      	lsls	r1, r3, #30
 80010a4:	f040 808e 	bne.w	80011c4 <HAL_CAN_IRQHandler+0x1ac>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
 80010a8:	0662      	lsls	r2, r4, #25
 80010aa:	d502      	bpl.n	80010b2 <HAL_CAN_IRQHandler+0x9a>
  {
    if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
 80010ac:	f019 0f10 	tst.w	r9, #16
 80010b0:	d157      	bne.n	8001162 <HAL_CAN_IRQHandler+0x14a>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
    }
  }

  /* Receive FIFO 1 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
 80010b2:	06a3      	lsls	r3, r4, #26
 80010b4:	d503      	bpl.n	80010be <HAL_CAN_IRQHandler+0xa6>
  {
    if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
 80010b6:	f019 0f08 	tst.w	r9, #8
 80010ba:	f040 8087 	bne.w	80011cc <HAL_CAN_IRQHandler+0x1b4>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
 80010be:	06e7      	lsls	r7, r4, #27
 80010c0:	d504      	bpl.n	80010cc <HAL_CAN_IRQHandler+0xb4>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
 80010c2:	682b      	ldr	r3, [r5, #0]
 80010c4:	691b      	ldr	r3, [r3, #16]
 80010c6:	0798      	lsls	r0, r3, #30
 80010c8:	f040 8087 	bne.w	80011da <HAL_CAN_IRQHandler+0x1c2>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Sleep interrupt management *********************************************/
  if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
 80010cc:	03a1      	lsls	r1, r4, #14
 80010ce:	d502      	bpl.n	80010d6 <HAL_CAN_IRQHandler+0xbe>
  {
    if ((msrflags & CAN_MSR_SLAKI) != 0U)
 80010d0:	f018 0f10 	tst.w	r8, #16
 80010d4:	d168      	bne.n	80011a8 <HAL_CAN_IRQHandler+0x190>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* WakeUp interrupt management *********************************************/
  if ((interrupts & CAN_IT_WAKEUP) != 0U)
 80010d6:	03e2      	lsls	r2, r4, #15
 80010d8:	d502      	bpl.n	80010e0 <HAL_CAN_IRQHandler+0xc8>
  {
    if ((msrflags & CAN_MSR_WKUI) != 0U)
 80010da:	f018 0f08 	tst.w	r8, #8
 80010de:	d16a      	bne.n	80011b6 <HAL_CAN_IRQHandler+0x19e>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Error interrupts management *********************************************/
  if ((interrupts & CAN_IT_ERROR) != 0U)
 80010e0:	0423      	lsls	r3, r4, #16
 80010e2:	d535      	bpl.n	8001150 <HAL_CAN_IRQHandler+0x138>
  {
    if ((msrflags & CAN_MSR_ERRI) != 0U)
 80010e4:	f018 0f04 	tst.w	r8, #4
 80010e8:	682b      	ldr	r3, [r5, #0]
 80010ea:	d02f      	beq.n	800114c <HAL_CAN_IRQHandler+0x134>
    {
      /* Check Error Warning Flag */
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 80010ec:	05e7      	lsls	r7, r4, #23
 80010ee:	d504      	bpl.n	80010fa <HAL_CAN_IRQHandler+0xe2>
 80010f0:	f01a 0f01 	tst.w	sl, #1
          ((esrflags & CAN_ESR_EWGF) != 0U))
      {
        /* Set CAN error code to Error Warning */
        errorcode |= HAL_CAN_ERROR_EWG;
 80010f4:	bf18      	it	ne
 80010f6:	f046 0601 	orrne.w	r6, r6, #1

        /* No need for clear of Error Warning Flag as read-only */
      }

      /* Check Error Passive Flag */
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 80010fa:	05a0      	lsls	r0, r4, #22
 80010fc:	d504      	bpl.n	8001108 <HAL_CAN_IRQHandler+0xf0>
 80010fe:	f01a 0f02 	tst.w	sl, #2
          ((esrflags & CAN_ESR_EPVF) != 0U))
      {
        /* Set CAN error code to Error Passive */
        errorcode |= HAL_CAN_ERROR_EPV;
 8001102:	bf18      	it	ne
 8001104:	f046 0602 	orrne.w	r6, r6, #2

        /* No need for clear of Error Passive Flag as read-only */
      }

      /* Check Bus-off Flag */
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 8001108:	0561      	lsls	r1, r4, #21
 800110a:	d504      	bpl.n	8001116 <HAL_CAN_IRQHandler+0xfe>
 800110c:	f01a 0f04 	tst.w	sl, #4
          ((esrflags & CAN_ESR_BOFF) != 0U))
      {
        /* Set CAN error code to Bus-Off */
        errorcode |= HAL_CAN_ERROR_BOF;
 8001110:	bf18      	it	ne
 8001112:	f046 0604 	orrne.w	r6, r6, #4

        /* No need for clear of Error Bus-Off as read-only */
      }

      /* Check Last Error Code Flag */
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8001116:	0522      	lsls	r2, r4, #20
 8001118:	d518      	bpl.n	800114c <HAL_CAN_IRQHandler+0x134>
 800111a:	f01a 0a70 	ands.w	sl, sl, #112	; 0x70
 800111e:	d015      	beq.n	800114c <HAL_CAN_IRQHandler+0x134>
          ((esrflags & CAN_ESR_LEC) != 0U))
      {
        switch (esrflags & CAN_ESR_LEC)
 8001120:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
 8001124:	f000 8096 	beq.w	8001254 <HAL_CAN_IRQHandler+0x23c>
 8001128:	d979      	bls.n	800121e <HAL_CAN_IRQHandler+0x206>
 800112a:	f1ba 0f50 	cmp.w	sl, #80	; 0x50
 800112e:	f000 808e 	beq.w	800124e <HAL_CAN_IRQHandler+0x236>
 8001132:	f1ba 0f60 	cmp.w	sl, #96	; 0x60
 8001136:	f000 8090 	beq.w	800125a <HAL_CAN_IRQHandler+0x242>
 800113a:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
 800113e:	d101      	bne.n	8001144 <HAL_CAN_IRQHandler+0x12c>
            /* Set CAN error code to Acknowledgement error */
            errorcode |= HAL_CAN_ERROR_ACK;
            break;
          case (CAN_ESR_LEC_2):
            /* Set CAN error code to Bit recessive error */
            errorcode |= HAL_CAN_ERROR_BR;
 8001140:	f046 0640 	orr.w	r6, r6, #64	; 0x40
          default:
            break;
        }

        /* Clear Last error code Flag */
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 8001144:	699a      	ldr	r2, [r3, #24]
 8001146:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800114a:	619a      	str	r2, [r3, #24]
      }
    }

    /* Clear ERRI Flag */
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 800114c:	2204      	movs	r2, #4
 800114e:	605a      	str	r2, [r3, #4]
  }

  /* Call the Error call Back in case of Errors */
  if (errorcode != HAL_CAN_ERROR_NONE)
 8001150:	b12e      	cbz	r6, 800115e <HAL_CAN_IRQHandler+0x146>
  {
    /* Update error code in handle */
    hcan->ErrorCode |= errorcode;
 8001152:	6a6b      	ldr	r3, [r5, #36]	; 0x24
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
    /* Call registered callback*/
    hcan->ErrorCallback(hcan);
#else
    /* Call weak (surcharged) callback */
    HAL_CAN_ErrorCallback(hcan);
 8001154:	4628      	mov	r0, r5
    hcan->ErrorCode |= errorcode;
 8001156:	431e      	orrs	r6, r3
 8001158:	626e      	str	r6, [r5, #36]	; 0x24
    HAL_CAN_ErrorCallback(hcan);
 800115a:	f7ff ff5b 	bl	8001014 <HAL_CAN_ErrorCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
  }
}
 800115e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 8001162:	682b      	ldr	r3, [r5, #0]
 8001164:	2210      	movs	r2, #16
      errorcode |= HAL_CAN_ERROR_RX_FOV1;
 8001166:	f446 6680 	orr.w	r6, r6, #1024	; 0x400
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 800116a:	611a      	str	r2, [r3, #16]
 800116c:	e7a1      	b.n	80010b2 <HAL_CAN_IRQHandler+0x9a>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 800116e:	682b      	ldr	r3, [r5, #0]
 8001170:	2210      	movs	r2, #16
      errorcode |= HAL_CAN_ERROR_RX_FOV0;
 8001172:	f446 7600 	orr.w	r6, r6, #512	; 0x200
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 8001176:	60da      	str	r2, [r3, #12]
 8001178:	e78a      	b.n	8001090 <HAL_CAN_IRQHandler+0x78>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
 800117a:	2201      	movs	r2, #1
 800117c:	609a      	str	r2, [r3, #8]
      if ((tsrflags & CAN_TSR_TXOK0) != 0U)
 800117e:	07bb      	lsls	r3, r7, #30
 8001180:	d437      	bmi.n	80011f2 <HAL_CAN_IRQHandler+0x1da>
        if ((tsrflags & CAN_TSR_ALST0) != 0U)
 8001182:	077e      	lsls	r6, r7, #29
 8001184:	d43d      	bmi.n	8001202 <HAL_CAN_IRQHandler+0x1ea>
        else if ((tsrflags & CAN_TSR_TERR0) != 0U)
 8001186:	f017 0608 	ands.w	r6, r7, #8
 800118a:	d059      	beq.n	8001240 <HAL_CAN_IRQHandler+0x228>
 800118c:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8001190:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
          errorcode |= HAL_CAN_ERROR_TX_TERR0;
 8001194:	f44f 5680 	mov.w	r6, #4096	; 0x1000
 8001198:	e757      	b.n	800104a <HAL_CAN_IRQHandler+0x32>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 800119a:	682b      	ldr	r3, [r5, #0]
 800119c:	2208      	movs	r2, #8
      HAL_CAN_RxFifo0FullCallback(hcan);
 800119e:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 80011a0:	60da      	str	r2, [r3, #12]
      HAL_CAN_RxFifo0FullCallback(hcan);
 80011a2:	f7ff ff2d 	bl	8001000 <HAL_CAN_RxFifo0FullCallback>
 80011a6:	e778      	b.n	800109a <HAL_CAN_IRQHandler+0x82>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 80011a8:	682b      	ldr	r3, [r5, #0]
 80011aa:	2210      	movs	r2, #16
      HAL_CAN_SleepCallback(hcan);
 80011ac:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 80011ae:	605a      	str	r2, [r3, #4]
      HAL_CAN_SleepCallback(hcan);
 80011b0:	f7ff ff2c 	bl	800100c <HAL_CAN_SleepCallback>
 80011b4:	e78f      	b.n	80010d6 <HAL_CAN_IRQHandler+0xbe>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 80011b6:	682b      	ldr	r3, [r5, #0]
 80011b8:	2208      	movs	r2, #8
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 80011ba:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 80011bc:	605a      	str	r2, [r3, #4]
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 80011be:	f7ff ff27 	bl	8001010 <HAL_CAN_WakeUpFromRxMsgCallback>
 80011c2:	e78d      	b.n	80010e0 <HAL_CAN_IRQHandler+0xc8>
      HAL_CAN_RxFifo0MsgPendingCallback(hcan);
 80011c4:	4628      	mov	r0, r5
 80011c6:	f7ff ff19 	bl	8000ffc <HAL_CAN_RxFifo0MsgPendingCallback>
 80011ca:	e76d      	b.n	80010a8 <HAL_CAN_IRQHandler+0x90>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 80011cc:	682b      	ldr	r3, [r5, #0]
 80011ce:	2208      	movs	r2, #8
      HAL_CAN_RxFifo1FullCallback(hcan);
 80011d0:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 80011d2:	611a      	str	r2, [r3, #16]
      HAL_CAN_RxFifo1FullCallback(hcan);
 80011d4:	f7ff ff18 	bl	8001008 <HAL_CAN_RxFifo1FullCallback>
 80011d8:	e771      	b.n	80010be <HAL_CAN_IRQHandler+0xa6>
      HAL_CAN_RxFifo1MsgPendingCallback(hcan);
 80011da:	4628      	mov	r0, r5
 80011dc:	f7ff ff12 	bl	8001004 <HAL_CAN_RxFifo1MsgPendingCallback>
 80011e0:	e774      	b.n	80010cc <HAL_CAN_IRQHandler+0xb4>
        HAL_CAN_TxMailbox2CompleteCallback(hcan);
 80011e2:	4628      	mov	r0, r5
 80011e4:	f7ff ff02 	bl	8000fec <HAL_CAN_TxMailbox2CompleteCallback>
 80011e8:	e74d      	b.n	8001086 <HAL_CAN_IRQHandler+0x6e>
        HAL_CAN_TxMailbox1CompleteCallback(hcan);
 80011ea:	4628      	mov	r0, r5
 80011ec:	f7ff fefc 	bl	8000fe8 <HAL_CAN_TxMailbox1CompleteCallback>
 80011f0:	e73b      	b.n	800106a <HAL_CAN_IRQHandler+0x52>
        HAL_CAN_TxMailbox0CompleteCallback(hcan);
 80011f2:	f7ff fef7 	bl	8000fe4 <HAL_CAN_TxMailbox0CompleteCallback>
  uint32_t errorcode = HAL_CAN_ERROR_NONE;
 80011f6:	2600      	movs	r6, #0
 80011f8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80011fc:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001200:	e723      	b.n	800104a <HAL_CAN_IRQHandler+0x32>
 8001202:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8001206:	f44f 4190 	mov.w	r1, #18432	; 0x4800
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 800120a:	f44f 6600 	mov.w	r6, #2048	; 0x800
 800120e:	e71c      	b.n	800104a <HAL_CAN_IRQHandler+0x32>
          errorcode |= HAL_CAN_ERROR_TX_ALST1;
 8001210:	4616      	mov	r6, r2
 8001212:	e72a      	b.n	800106a <HAL_CAN_IRQHandler+0x52>
        else if ((tsrflags & CAN_TSR_TERR2) != 0U)
 8001214:	033a      	lsls	r2, r7, #12
 8001216:	d50b      	bpl.n	8001230 <HAL_CAN_IRQHandler+0x218>
          errorcode |= HAL_CAN_ERROR_TX_TERR2;
 8001218:	f446 3680 	orr.w	r6, r6, #65536	; 0x10000
 800121c:	e733      	b.n	8001086 <HAL_CAN_IRQHandler+0x6e>
        switch (esrflags & CAN_ESR_LEC)
 800121e:	f1ba 0f10 	cmp.w	sl, #16
 8001222:	d01d      	beq.n	8001260 <HAL_CAN_IRQHandler+0x248>
 8001224:	f1ba 0f20 	cmp.w	sl, #32
 8001228:	d18c      	bne.n	8001144 <HAL_CAN_IRQHandler+0x12c>
            errorcode |= HAL_CAN_ERROR_FOR;
 800122a:	f046 0610 	orr.w	r6, r6, #16
            break;
 800122e:	e789      	b.n	8001144 <HAL_CAN_IRQHandler+0x12c>
          HAL_CAN_TxMailbox2AbortCallback(hcan);
 8001230:	4628      	mov	r0, r5
 8001232:	f7ff fee1 	bl	8000ff8 <HAL_CAN_TxMailbox2AbortCallback>
 8001236:	e726      	b.n	8001086 <HAL_CAN_IRQHandler+0x6e>
          HAL_CAN_TxMailbox1AbortCallback(hcan);
 8001238:	4628      	mov	r0, r5
 800123a:	f7ff fedb 	bl	8000ff4 <HAL_CAN_TxMailbox1AbortCallback>
 800123e:	e714      	b.n	800106a <HAL_CAN_IRQHandler+0x52>
          HAL_CAN_TxMailbox0AbortCallback(hcan);
 8001240:	f7ff fed6 	bl	8000ff0 <HAL_CAN_TxMailbox0AbortCallback>
 8001244:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001248:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800124c:	e6fd      	b.n	800104a <HAL_CAN_IRQHandler+0x32>
            errorcode |= HAL_CAN_ERROR_BD;
 800124e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
            break;
 8001252:	e777      	b.n	8001144 <HAL_CAN_IRQHandler+0x12c>
            errorcode |= HAL_CAN_ERROR_ACK;
 8001254:	f046 0620 	orr.w	r6, r6, #32
            break;
 8001258:	e774      	b.n	8001144 <HAL_CAN_IRQHandler+0x12c>
            errorcode |= HAL_CAN_ERROR_CRC;
 800125a:	f446 7680 	orr.w	r6, r6, #256	; 0x100
            break;
 800125e:	e771      	b.n	8001144 <HAL_CAN_IRQHandler+0x12c>
            errorcode |= HAL_CAN_ERROR_STF;
 8001260:	f046 0608 	orr.w	r6, r6, #8
            break;
 8001264:	e76e      	b.n	8001144 <HAL_CAN_IRQHandler+0x12c>
 8001266:	bf00      	nop

08001268 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001268:	4907      	ldr	r1, [pc, #28]	; (8001288 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800126a:	0200      	lsls	r0, r0, #8
 800126c:	4b07      	ldr	r3, [pc, #28]	; (800128c <HAL_NVIC_SetPriorityGrouping+0x24>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800126e:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001270:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001274:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001276:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 800127a:	4022      	ands	r2, r4
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800127c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001280:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001282:	4318      	orrs	r0, r3
  SCB->AIRCR =  reg_value;
 8001284:	60c8      	str	r0, [r1, #12]
 8001286:	4770      	bx	lr
 8001288:	e000ed00 	.word	0xe000ed00
 800128c:	05fa0000 	.word	0x05fa0000

08001290 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001290:	4b17      	ldr	r3, [pc, #92]	; (80012f0 <HAL_NVIC_SetPriority+0x60>)
 8001292:	68db      	ldr	r3, [r3, #12]
 8001294:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001298:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800129a:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800129e:	1d1c      	adds	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80012a0:	2d04      	cmp	r5, #4
 80012a2:	bf28      	it	cs
 80012a4:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80012a6:	2c06      	cmp	r4, #6
 80012a8:	d918      	bls.n	80012dc <HAL_NVIC_SetPriority+0x4c>
 80012aa:	3b03      	subs	r3, #3
 80012ac:	f04f 34ff 	mov.w	r4, #4294967295
 80012b0:	409c      	lsls	r4, r3
 80012b2:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80012b6:	f04f 32ff 	mov.w	r2, #4294967295
  if ((int32_t)(IRQn) >= 0)
 80012ba:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80012bc:	fa02 f205 	lsl.w	r2, r2, r5
 80012c0:	ea21 0102 	bic.w	r1, r1, r2
 80012c4:	fa01 f203 	lsl.w	r2, r1, r3
 80012c8:	ea42 0204 	orr.w	r2, r2, r4
 80012cc:	ea4f 1202 	mov.w	r2, r2, lsl #4
 80012d0:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
 80012d2:	db06      	blt.n	80012e2 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80012d4:	4b07      	ldr	r3, [pc, #28]	; (80012f4 <HAL_NVIC_SetPriority+0x64>)
 80012d6:	541a      	strb	r2, [r3, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80012d8:	bc30      	pop	{r4, r5}
 80012da:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80012dc:	2400      	movs	r4, #0
 80012de:	4623      	mov	r3, r4
 80012e0:	e7e9      	b.n	80012b6 <HAL_NVIC_SetPriority+0x26>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80012e2:	f000 000f 	and.w	r0, r0, #15
 80012e6:	4b04      	ldr	r3, [pc, #16]	; (80012f8 <HAL_NVIC_SetPriority+0x68>)
 80012e8:	541a      	strb	r2, [r3, r0]
 80012ea:	bc30      	pop	{r4, r5}
 80012ec:	4770      	bx	lr
 80012ee:	bf00      	nop
 80012f0:	e000ed00 	.word	0xe000ed00
 80012f4:	e000e400 	.word	0xe000e400
 80012f8:	e000ed14 	.word	0xe000ed14

080012fc <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80012fc:	2800      	cmp	r0, #0
 80012fe:	db07      	blt.n	8001310 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001300:	f000 011f 	and.w	r1, r0, #31
 8001304:	2301      	movs	r3, #1
 8001306:	0940      	lsrs	r0, r0, #5
 8001308:	4a02      	ldr	r2, [pc, #8]	; (8001314 <HAL_NVIC_EnableIRQ+0x18>)
 800130a:	408b      	lsls	r3, r1
 800130c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8001310:	4770      	bx	lr
 8001312:	bf00      	nop
 8001314:	e000e100 	.word	0xe000e100

08001318 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001318:	3801      	subs	r0, #1
 800131a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800131e:	d20d      	bcs.n	800133c <HAL_SYSTICK_Config+0x24>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001320:	4b07      	ldr	r3, [pc, #28]	; (8001340 <HAL_SYSTICK_Config+0x28>)
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001322:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001324:	2107      	movs	r1, #7
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8001326:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001328:	25f0      	movs	r5, #240	; 0xf0
 800132a:	4c06      	ldr	r4, [pc, #24]	; (8001344 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800132c:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800132e:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001330:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001334:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001336:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 8001338:	bc30      	pop	{r4, r5}
 800133a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800133c:	2001      	movs	r0, #1
 800133e:	4770      	bx	lr
 8001340:	e000e010 	.word	0xe000e010
 8001344:	e000ed00 	.word	0xe000ed00

08001348 <HAL_DFSDM_ChannelInit>:
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DFSDM_ChannelInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel)
{
  /* Check DFSDM Channel handle */
  if(hdfsdm_channel == NULL)
 8001348:	b330      	cbz	r0, 8001398 <HAL_DFSDM_ChannelInit+0x50>
static uint32_t DFSDM_GetChannelFromInstance(DFSDM_Channel_TypeDef* Instance)
{
  uint32_t channel = 0xFF;
  
  /* Get channel from instance */
  if(Instance == DFSDM1_Channel0)
 800134a:	4a63      	ldr	r2, [pc, #396]	; (80014d8 <HAL_DFSDM_ChannelInit+0x190>)
{
 800134c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800134e:	6803      	ldr	r3, [r0, #0]
  if(Instance == DFSDM1_Channel0)
 8001350:	4293      	cmp	r3, r2
 8001352:	f000 808b 	beq.w	800146c <HAL_DFSDM_ChannelInit+0x124>
  {
    channel = 0;
  }
  else if(Instance == DFSDM1_Channel1)
 8001356:	3220      	adds	r2, #32
 8001358:	4293      	cmp	r3, r2
 800135a:	d01f      	beq.n	800139c <HAL_DFSDM_ChannelInit+0x54>
  {
    channel = 1;
  }
  else if(Instance == DFSDM1_Channel2)
 800135c:	3220      	adds	r2, #32
 800135e:	4293      	cmp	r3, r2
 8001360:	f000 8086 	beq.w	8001470 <HAL_DFSDM_ChannelInit+0x128>
  {
    channel = 2;
  }
  else if(Instance == DFSDM1_Channel3)
 8001364:	3220      	adds	r2, #32
 8001366:	4293      	cmp	r3, r2
 8001368:	f000 8084 	beq.w	8001474 <HAL_DFSDM_ChannelInit+0x12c>
  {
    channel = 3;
  }
  else if(Instance == DFSDM1_Channel4)
 800136c:	3220      	adds	r2, #32
 800136e:	4293      	cmp	r3, r2
 8001370:	f000 80a3 	beq.w	80014ba <HAL_DFSDM_ChannelInit+0x172>
  {
    channel = 4;
  }
  else if(Instance == DFSDM1_Channel5)
 8001374:	3220      	adds	r2, #32
 8001376:	4293      	cmp	r3, r2
 8001378:	d07e      	beq.n	8001478 <HAL_DFSDM_ChannelInit+0x130>
  {
    channel = 5;
  }
  else if(Instance == DFSDM1_Channel6)
 800137a:	3220      	adds	r2, #32
 800137c:	4293      	cmp	r3, r2
 800137e:	f000 80a0 	beq.w	80014c2 <HAL_DFSDM_ChannelInit+0x17a>
  {
    channel = 6;
  }
  else if(Instance == DFSDM1_Channel7)
 8001382:	3220      	adds	r2, #32
  {
    channel = 7;
 8001384:	4293      	cmp	r3, r2
 8001386:	bf14      	ite	ne
 8001388:	23ff      	movne	r3, #255	; 0xff
 800138a:	2307      	moveq	r3, #7
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800138c:	4d53      	ldr	r5, [pc, #332]	; (80014dc <HAL_DFSDM_ChannelInit+0x194>)
 800138e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8001392:	b14b      	cbz	r3, 80013a8 <HAL_DFSDM_ChannelInit+0x60>
    return HAL_ERROR;
 8001394:	2001      	movs	r0, #1
}
 8001396:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8001398:	2001      	movs	r0, #1
}
 800139a:	4770      	bx	lr
    channel = 1;
 800139c:	2301      	movs	r3, #1
  if(a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800139e:	4d4f      	ldr	r5, [pc, #316]	; (80014dc <HAL_DFSDM_ChannelInit+0x194>)
 80013a0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80013a4:	2b00      	cmp	r3, #0
 80013a6:	d1f5      	bne.n	8001394 <HAL_DFSDM_ChannelInit+0x4c>
 80013a8:	4604      	mov	r4, r0
  HAL_DFSDM_ChannelMspInit(hdfsdm_channel);
 80013aa:	f004 ffab 	bl	8006304 <HAL_DFSDM_ChannelMspInit>
  v_dfsdm1ChannelCounter++;
 80013ae:	4b4c      	ldr	r3, [pc, #304]	; (80014e0 <HAL_DFSDM_ChannelInit+0x198>)
 80013b0:	681a      	ldr	r2, [r3, #0]
 80013b2:	3201      	adds	r2, #1
 80013b4:	601a      	str	r2, [r3, #0]
  if(v_dfsdm1ChannelCounter == 1)
 80013b6:	681b      	ldr	r3, [r3, #0]
 80013b8:	2b01      	cmp	r3, #1
 80013ba:	d061      	beq.n	8001480 <HAL_DFSDM_ChannelInit+0x138>
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 80013bc:	6823      	ldr	r3, [r4, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 80013be:	2001      	movs	r0, #1
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013c0:	6966      	ldr	r6, [r4, #20]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 80013c2:	6819      	ldr	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013c4:	6922      	ldr	r2, [r4, #16]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 80013c6:	f421 4171 	bic.w	r1, r1, #61696	; 0xf100
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 80013ca:	f8d4 e024 	ldr.w	lr, [r4, #36]	; 0x24
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013ce:	4332      	orrs	r2, r6
                                        hdfsdm_channel->Init.Input.DataPacking | 
 80013d0:	69a6      	ldr	r6, [r4, #24]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX | 
 80013d2:	6019      	str	r1, [r3, #0]
                                        hdfsdm_channel->Init.Input.DataPacking | 
 80013d4:	4332      	orrs	r2, r6
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013d6:	6819      	ldr	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 80013d8:	69e6      	ldr	r6, [r4, #28]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013da:	430a      	orrs	r2, r1
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 80013dc:	6a21      	ldr	r1, [r4, #32]
                                       ((hdfsdm_channel->Init.Awd.Oversampling - 1) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 80013de:	6aa7      	ldr	r7, [r4, #40]	; 0x28
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer | 
 80013e0:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 80013e2:	430e      	orrs	r6, r1
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 80013e4:	681a      	ldr	r2, [r3, #0]
                                       ((hdfsdm_channel->Init.Awd.Oversampling - 1) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 80013e6:	3f01      	subs	r7, #1
                                        (hdfsdm_channel->Init.RightBitShift << DFSDM_CHCFGR2_DTRBS_Pos));
 80013e8:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 80013ec:	f022 020f 	bic.w	r2, r2, #15
 80013f0:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type | 
 80013f2:	681a      	ldr	r2, [r3, #0]
 80013f4:	4316      	orrs	r6, r2
 80013f6:	601e      	str	r6, [r3, #0]
  hdfsdm_channel->Instance->CHAWSCDR &= ~(DFSDM_CHAWSCDR_AWFORD | DFSDM_CHAWSCDR_AWFOSR);
 80013f8:	689e      	ldr	r6, [r3, #8]
 80013fa:	f426 065f 	bic.w	r6, r6, #14614528	; 0xdf0000
 80013fe:	609e      	str	r6, [r3, #8]
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 8001400:	6899      	ldr	r1, [r3, #8]
  if(Instance == DFSDM1_Channel0)
 8001402:	4e35      	ldr	r6, [pc, #212]	; (80014d8 <HAL_DFSDM_ChannelInit+0x190>)
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 8001404:	ea41 010e 	orr.w	r1, r1, lr
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) | 
 8001408:	f8d4 e02c 	ldr.w	lr, [r4, #44]	; 0x2c
  if(Instance == DFSDM1_Channel0)
 800140c:	42b3      	cmp	r3, r6
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder | 
 800140e:	ea41 4107 	orr.w	r1, r1, r7, lsl #16
 8001412:	6099      	str	r1, [r3, #8]
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 8001414:	6859      	ldr	r1, [r3, #4]
 8001416:	f001 0107 	and.w	r1, r1, #7
 800141a:	6059      	str	r1, [r3, #4]
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) | 
 800141c:	685a      	ldr	r2, [r3, #4]
 800141e:	ea42 02cc 	orr.w	r2, r2, ip, lsl #3
 8001422:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 8001426:	605a      	str	r2, [r3, #4]
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 8001428:	681a      	ldr	r2, [r3, #0]
 800142a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800142e:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 8001430:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(Instance == DFSDM1_Channel0)
 8001434:	d043      	beq.n	80014be <HAL_DFSDM_ChannelInit+0x176>
  else if(Instance == DFSDM1_Channel1)
 8001436:	4a2b      	ldr	r2, [pc, #172]	; (80014e4 <HAL_DFSDM_ChannelInit+0x19c>)
 8001438:	4293      	cmp	r3, r2
 800143a:	d013      	beq.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
  else if(Instance == DFSDM1_Channel2)
 800143c:	3220      	adds	r2, #32
 800143e:	4293      	cmp	r3, r2
 8001440:	d041      	beq.n	80014c6 <HAL_DFSDM_ChannelInit+0x17e>
  else if(Instance == DFSDM1_Channel3)
 8001442:	3220      	adds	r2, #32
 8001444:	4293      	cmp	r3, r2
 8001446:	d040      	beq.n	80014ca <HAL_DFSDM_ChannelInit+0x182>
  else if(Instance == DFSDM1_Channel4)
 8001448:	3220      	adds	r2, #32
 800144a:	4293      	cmp	r3, r2
 800144c:	d016      	beq.n	800147c <HAL_DFSDM_ChannelInit+0x134>
  else if(Instance == DFSDM1_Channel5)
 800144e:	3220      	adds	r2, #32
 8001450:	4293      	cmp	r3, r2
 8001452:	d03c      	beq.n	80014ce <HAL_DFSDM_ChannelInit+0x186>
  else if(Instance == DFSDM1_Channel6)
 8001454:	3220      	adds	r2, #32
 8001456:	4293      	cmp	r3, r2
 8001458:	d03b      	beq.n	80014d2 <HAL_DFSDM_ChannelInit+0x18a>
  else if(Instance == DFSDM1_Channel7)
 800145a:	4823      	ldr	r0, [pc, #140]	; (80014e8 <HAL_DFSDM_ChannelInit+0x1a0>)
    channel = 7;
 800145c:	4283      	cmp	r3, r0
 800145e:	bf14      	ite	ne
 8001460:	20ff      	movne	r0, #255	; 0xff
 8001462:	2007      	moveq	r0, #7
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = hdfsdm_channel;
 8001464:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
  return HAL_OK;
 8001468:	2000      	movs	r0, #0
}
 800146a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    channel = 0;
 800146c:	2300      	movs	r3, #0
 800146e:	e78d      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 2;
 8001470:	2302      	movs	r3, #2
 8001472:	e78b      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 3;
 8001474:	2303      	movs	r3, #3
 8001476:	e789      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 5;
 8001478:	2305      	movs	r3, #5
 800147a:	e787      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 4;
 800147c:	2004      	movs	r0, #4
 800147e:	e7f1      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 8001480:	4b15      	ldr	r3, [pc, #84]	; (80014d8 <HAL_DFSDM_ChannelInit+0x190>)
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 8001482:	7921      	ldrb	r1, [r4, #4]
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 8001484:	681a      	ldr	r2, [r3, #0]
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 8001486:	2901      	cmp	r1, #1
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 8001488:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 800148c:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= hdfsdm_channel->Init.OutputClock.Selection;
 800148e:	681a      	ldr	r2, [r3, #0]
 8001490:	68a0      	ldr	r0, [r4, #8]
 8001492:	ea42 0200 	orr.w	r2, r2, r0
 8001496:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
 8001498:	681a      	ldr	r2, [r3, #0]
 800149a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800149e:	601a      	str	r2, [r3, #0]
    if(hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 80014a0:	d105      	bne.n	80014ae <HAL_DFSDM_ChannelInit+0x166>
      DFSDM1_Channel0->CHCFGR1 |= (uint32_t) ((hdfsdm_channel->Init.OutputClock.Divider - 1) << 
 80014a2:	68e1      	ldr	r1, [r4, #12]
 80014a4:	681a      	ldr	r2, [r3, #0]
 80014a6:	3901      	subs	r1, #1
 80014a8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80014ac:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= DFSDM_CHCFGR1_DFSDMEN;
 80014ae:	4a0a      	ldr	r2, [pc, #40]	; (80014d8 <HAL_DFSDM_ChannelInit+0x190>)
 80014b0:	6813      	ldr	r3, [r2, #0]
 80014b2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80014b6:	6013      	str	r3, [r2, #0]
 80014b8:	e780      	b.n	80013bc <HAL_DFSDM_ChannelInit+0x74>
    channel = 4;
 80014ba:	2304      	movs	r3, #4
 80014bc:	e766      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 0;
 80014be:	2000      	movs	r0, #0
 80014c0:	e7d0      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
    channel = 6;
 80014c2:	2306      	movs	r3, #6
 80014c4:	e762      	b.n	800138c <HAL_DFSDM_ChannelInit+0x44>
    channel = 2;
 80014c6:	2002      	movs	r0, #2
 80014c8:	e7cc      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
    channel = 3;
 80014ca:	2003      	movs	r0, #3
 80014cc:	e7ca      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
    channel = 5;
 80014ce:	2005      	movs	r0, #5
 80014d0:	e7c8      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
    channel = 6;
 80014d2:	2006      	movs	r0, #6
 80014d4:	e7c6      	b.n	8001464 <HAL_DFSDM_ChannelInit+0x11c>
 80014d6:	bf00      	nop
 80014d8:	40017400 	.word	0x40017400
 80014dc:	20002084 	.word	0x20002084
 80014e0:	200020a4 	.word	0x200020a4
 80014e4:	40017420 	.word	0x40017420
 80014e8:	400174e0 	.word	0x400174e0

080014ec <HAL_DFSDM_FilterInit>:
  if(hdfsdm_filter == NULL)
 80014ec:	2800      	cmp	r0, #0
 80014ee:	d066      	beq.n	80015be <HAL_DFSDM_FilterInit+0xd2>
  if((hdfsdm_filter->Instance == DFSDM1_Filter0) && 
 80014f0:	6802      	ldr	r2, [r0, #0]
{
 80014f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((hdfsdm_filter->Instance == DFSDM1_Filter0) && 
 80014f4:	4b35      	ldr	r3, [pc, #212]	; (80015cc <HAL_DFSDM_FilterInit+0xe0>)
 80014f6:	429a      	cmp	r2, r3
 80014f8:	d059      	beq.n	80015ae <HAL_DFSDM_FilterInit+0xc2>
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 80014fa:	2200      	movs	r2, #0
  hdfsdm_filter->InjectedChannelsNbr = 1;
 80014fc:	2301      	movs	r3, #1
 80014fe:	4604      	mov	r4, r0
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 8001500:	6302      	str	r2, [r0, #48]	; 0x30
  hdfsdm_filter->ErrorCode           = DFSDM_FILTER_ERROR_NONE;
 8001502:	6502      	str	r2, [r0, #80]	; 0x50
  hdfsdm_filter->InjConvRemaining    = 1;
 8001504:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
  HAL_DFSDM_FilterMspInit(hdfsdm_filter);
 8001508:	f004 fea2 	bl	8006250 <HAL_DFSDM_FilterMspInit>
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 800150c:	6823      	ldr	r3, [r4, #0]
  if(hdfsdm_filter->Init.RegularParam.FastMode == ENABLE)
 800150e:	7a21      	ldrb	r1, [r4, #8]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 8001510:	681a      	ldr	r2, [r3, #0]
  if(hdfsdm_filter->Init.RegularParam.FastMode == ENABLE)
 8001512:	2901      	cmp	r1, #1
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 8001514:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 8001518:	601a      	str	r2, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_FAST;
 800151a:	681a      	ldr	r2, [r3, #0]
 800151c:	bf0c      	ite	eq
 800151e:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_FAST);
 8001522:	f022 5200 	bicne.w	r2, r2, #536870912	; 0x20000000
 8001526:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.RegularParam.DmaMode == ENABLE)
 8001528:	7a62      	ldrb	r2, [r4, #9]
 800152a:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RDMAEN;
 800152c:	681a      	ldr	r2, [r3, #0]
 800152e:	bf0c      	ite	eq
 8001530:	f442 1200 	orreq.w	r2, r2, #2097152	; 0x200000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RDMAEN);
 8001534:	f422 1200 	bicne.w	r2, r2, #2097152	; 0x200000
 8001538:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 800153a:	4a25      	ldr	r2, [pc, #148]	; (80015d0 <HAL_DFSDM_FilterInit+0xe4>)
 800153c:	6819      	ldr	r1, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 800153e:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 8001542:	400a      	ands	r2, r1
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 8001544:	f1bc 0f02 	cmp.w	ip, #2
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 8001548:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 800154a:	d03a      	beq.n	80015c2 <HAL_DFSDM_FilterInit+0xd6>
  if(hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 800154c:	7c25      	ldrb	r5, [r4, #16]
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 800154e:	2601      	movs	r6, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 8001550:	681a      	ldr	r2, [r3, #0]
  return HAL_OK;
 8001552:	2000      	movs	r0, #0
  if(hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 8001554:	2d01      	cmp	r5, #1
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 8001556:	491f      	ldr	r1, [pc, #124]	; (80015d4 <HAL_DFSDM_FilterInit+0xe8>)
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 8001558:	bf0c      	ite	eq
 800155a:	f042 0210 	orreq.w	r2, r2, #16
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSCAN);
 800155e:	f022 0210 	bicne.w	r2, r2, #16
 8001562:	601a      	str	r2, [r3, #0]
  if(hdfsdm_filter->Init.InjectedParam.DmaMode == ENABLE)
 8001564:	7c62      	ldrb	r2, [r4, #17]
 8001566:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JDMAEN;
 8001568:	681a      	ldr	r2, [r3, #0]
 800156a:	bf0c      	ite	eq
 800156c:	f042 0220 	orreq.w	r2, r2, #32
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JDMAEN);
 8001570:	f022 0220 	bicne.w	r2, r2, #32
 8001574:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 8001576:	695a      	ldr	r2, [r3, #20]
 8001578:	4011      	ands	r1, r2
                                  (hdfsdm_filter->Init.FilterParam.IntOversampling - 1));
 800157a:	6a62      	ldr	r2, [r4, #36]	; 0x24
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 800157c:	6159      	str	r1, [r3, #20]
                                  (hdfsdm_filter->Init.FilterParam.IntOversampling - 1));
 800157e:	3a01      	subs	r2, #1
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 8001580:	6959      	ldr	r1, [r3, #20]
 8001582:	430a      	orrs	r2, r1
                                    ((hdfsdm_filter->Init.FilterParam.Oversampling - 1) << DFSDM_FLTFCR_FOSR_Pos) |
 8001584:	e9d4 7107 	ldrd	r7, r1, [r4, #28]
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 8001588:	433a      	orrs	r2, r7
                                    ((hdfsdm_filter->Init.FilterParam.Oversampling - 1) << DFSDM_FLTFCR_FOSR_Pos) |
 800158a:	3901      	subs	r1, #1
  hdfsdm_filter->RegularTrigger   = hdfsdm_filter->Init.RegularParam.Trigger;
 800158c:	6867      	ldr	r7, [r4, #4]
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 800158e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  hdfsdm_filter->ExtTriggerEdge   = hdfsdm_filter->Init.InjectedParam.ExtTriggerEdge;
 8001592:	69a1      	ldr	r1, [r4, #24]
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 8001594:	615a      	str	r2, [r3, #20]
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 8001596:	681a      	ldr	r2, [r3, #0]
  hdfsdm_filter->InjectedTrigger  = hdfsdm_filter->Init.InjectedParam.Trigger;
 8001598:	f8c4 c038 	str.w	ip, [r4, #56]	; 0x38
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800159c:	4332      	orrs	r2, r6
  hdfsdm_filter->InjectedScanMode = hdfsdm_filter->Init.InjectedParam.ScanMode;
 800159e:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  hdfsdm_filter->RegularTrigger   = hdfsdm_filter->Init.RegularParam.Trigger;
 80015a2:	6367      	str	r7, [r4, #52]	; 0x34
  hdfsdm_filter->ExtTriggerEdge   = hdfsdm_filter->Init.InjectedParam.ExtTriggerEdge;
 80015a4:	63e1      	str	r1, [r4, #60]	; 0x3c
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 80015a6:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 80015a8:	f884 604c 	strb.w	r6, [r4, #76]	; 0x4c
}
 80015ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if((hdfsdm_filter->Instance == DFSDM1_Filter0) && 
 80015ae:	6843      	ldr	r3, [r0, #4]
 80015b0:	2b01      	cmp	r3, #1
 80015b2:	d002      	beq.n	80015ba <HAL_DFSDM_FilterInit+0xce>
    ((hdfsdm_filter->Init.RegularParam.Trigger  == DFSDM_FILTER_SYNC_TRIGGER) || 
 80015b4:	68c3      	ldr	r3, [r0, #12]
 80015b6:	2b01      	cmp	r3, #1
 80015b8:	d19f      	bne.n	80014fa <HAL_DFSDM_FilterInit+0xe>
    return HAL_ERROR;
 80015ba:	4618      	mov	r0, r3
}
 80015bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80015be:	2001      	movs	r0, #1
}
 80015c0:	4770      	bx	lr
    hdfsdm_filter->Instance->FLTCR1 |= (hdfsdm_filter->Init.InjectedParam.ExtTrigger);
 80015c2:	681a      	ldr	r2, [r3, #0]
 80015c4:	6961      	ldr	r1, [r4, #20]
 80015c6:	430a      	orrs	r2, r1
 80015c8:	601a      	str	r2, [r3, #0]
 80015ca:	e7bf      	b.n	800154c <HAL_DFSDM_FilterInit+0x60>
 80015cc:	40017500 	.word	0x40017500
 80015d0:	ffff80f7 	.word	0xffff80f7
 80015d4:	1c00ff00 	.word	0x1c00ff00

080015d8 <HAL_DFSDM_FilterConfigRegChannel>:
  if((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_RESET) && 
 80015d8:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 80015dc:	3b01      	subs	r3, #1
 80015de:	b2db      	uxtb	r3, r3
 80015e0:	2bfd      	cmp	r3, #253	; 0xfd
 80015e2:	d813      	bhi.n	800160c <HAL_DFSDM_FilterConfigRegChannel+0x34>
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 80015e4:	6803      	ldr	r3, [r0, #0]
 80015e6:	0209      	lsls	r1, r1, #8
    if(ContinuousMode == DFSDM_CONTINUOUS_CONV_ON)
 80015e8:	2a01      	cmp	r2, #1
 80015ea:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
{
 80015ee:	b430      	push	{r4, r5}
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 80015f0:	681d      	ldr	r5, [r3, #0]
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) (((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET) |
 80015f2:	bf08      	it	eq
 80015f4:	f441 2180 	orreq.w	r1, r1, #262144	; 0x40000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 80015f8:	4c05      	ldr	r4, [pc, #20]	; (8001610 <HAL_DFSDM_FilterConfigRegChannel+0x38>)
 80015fa:	402c      	ands	r4, r5
 80015fc:	601c      	str	r4, [r3, #0]
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) ((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET);
 80015fe:	681c      	ldr	r4, [r3, #0]
 8001600:	4321      	orrs	r1, r4
}
 8001602:	bc30      	pop	{r4, r5}
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t) ((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET);
 8001604:	6019      	str	r1, [r3, #0]
    hdfsdm_filter->RegularContMode = ContinuousMode;
 8001606:	6302      	str	r2, [r0, #48]	; 0x30
  HAL_StatusTypeDef status = HAL_OK;
 8001608:	2000      	movs	r0, #0
}
 800160a:	4770      	bx	lr
    status = HAL_ERROR;
 800160c:	2001      	movs	r0, #1
}
 800160e:	4770      	bx	lr
 8001610:	f8fbffff 	.word	0xf8fbffff

08001614 <HAL_DFSDM_FilterRegularStart>:
  if((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) || \
 8001614:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 8001618:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
 800161c:	2a01      	cmp	r2, #1
 800161e:	d001      	beq.n	8001624 <HAL_DFSDM_FilterRegularStart+0x10>
    status = HAL_ERROR;
 8001620:	2001      	movs	r0, #1
}
 8001622:	4770      	bx	lr
  * @retval None
  */
static void DFSDM_RegConvStart(DFSDM_Filter_HandleTypeDef* hdfsdm_filter)
{
  /* Check regular trigger */
  if(hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SW_TRIGGER)
 8001624:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8001626:	6802      	ldr	r2, [r0, #0]
 8001628:	b191      	cbz	r1, 8001650 <HAL_DFSDM_FilterRegularStart+0x3c>
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSWSTART;
  }
  else /* synchronous trigger */
  {
    /* Disable DFSDM filter */
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 800162a:	6811      	ldr	r1, [r2, #0]

    /* Enable DFSDM  filter */
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
    
    /* If injected conversion was in progress, restart it */
    if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 800162c:	2b03      	cmp	r3, #3
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 800162e:	f021 0101 	bic.w	r1, r1, #1
 8001632:	6011      	str	r1, [r2, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSYNC;
 8001634:	6811      	ldr	r1, [r2, #0]
 8001636:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 800163a:	6011      	str	r1, [r2, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800163c:	6811      	ldr	r1, [r2, #0]
 800163e:	f041 0101 	orr.w	r1, r1, #1
 8001642:	6011      	str	r1, [r2, #0]
    if(hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 8001644:	d00f      	beq.n	8001666 <HAL_DFSDM_FilterRegularStart+0x52>
                                         hdfsdm_filter->InjectedChannelsNbr : 1;
    }
  }
  /* Update DFSDM filter state */
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 8001646:	2302      	movs	r3, #2
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 8001648:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  HAL_StatusTypeDef status = HAL_OK;
 800164c:	2000      	movs	r0, #0
 800164e:	4770      	bx	lr
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSWSTART;
 8001650:	6811      	ldr	r1, [r2, #0]
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 8001652:	2b01      	cmp	r3, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSWSTART;
 8001654:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 8001658:	6011      	str	r1, [r2, #0]
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 800165a:	d0f4      	beq.n	8001646 <HAL_DFSDM_FilterRegularStart+0x32>
 800165c:	2304      	movs	r3, #4
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 800165e:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  HAL_StatusTypeDef status = HAL_OK;
 8001662:	2000      	movs	r0, #0
 8001664:	4770      	bx	lr
      if(hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SW_TRIGGER)
 8001666:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001668:	b91b      	cbnz	r3, 8001672 <HAL_DFSDM_FilterRegularStart+0x5e>
        hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSWSTART;
 800166a:	6813      	ldr	r3, [r2, #0]
 800166c:	f043 0302 	orr.w	r3, r3, #2
 8001670:	6013      	str	r3, [r2, #0]
                                         hdfsdm_filter->InjectedChannelsNbr : 1;
 8001672:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001676:	2b01      	cmp	r3, #1
                          HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 8001678:	f04f 0304 	mov.w	r3, #4
                                         hdfsdm_filter->InjectedChannelsNbr : 1;
 800167c:	bf0c      	ite	eq
 800167e:	6c42      	ldreq	r2, [r0, #68]	; 0x44
 8001680:	2201      	movne	r2, #1
      hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
 8001682:	6482      	str	r2, [r0, #72]	; 0x48
 8001684:	e7e0      	b.n	8001648 <HAL_DFSDM_FilterRegularStart+0x34>
 8001686:	bf00      	nop

08001688 <HAL_DFSDM_FilterGetRegularValue>:
  reg = hdfsdm_filter->Instance->FLTRDATAR;
 8001688:	6803      	ldr	r3, [r0, #0]
 800168a:	69d8      	ldr	r0, [r3, #28]
  *Channel = (reg & DFSDM_FLTRDATAR_RDATACH);
 800168c:	f000 0307 	and.w	r3, r0, #7
}
 8001690:	1200      	asrs	r0, r0, #8
  *Channel = (reg & DFSDM_FLTRDATAR_RDATACH);
 8001692:	600b      	str	r3, [r1, #0]
}
 8001694:	4770      	bx	lr
 8001696:	bf00      	nop

08001698 <HAL_DFSDM_FilterErrorCallback>:
 8001698:	4770      	bx	lr
 800169a:	bf00      	nop

0800169c <HAL_DFSDM_FilterPollForRegConversion>:
  if((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_REG) && \
 800169c:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 80016a0:	2b02      	cmp	r3, #2
 80016a2:	d003      	beq.n	80016ac <HAL_DFSDM_FilterPollForRegConversion+0x10>
 80016a4:	2b04      	cmp	r3, #4
 80016a6:	d001      	beq.n	80016ac <HAL_DFSDM_FilterPollForRegConversion+0x10>
    return HAL_ERROR;
 80016a8:	2001      	movs	r0, #1
}
 80016aa:	4770      	bx	lr
{
 80016ac:	b570      	push	{r4, r5, r6, lr}
 80016ae:	460c      	mov	r4, r1
 80016b0:	4605      	mov	r5, r0
    tickstart = HAL_GetTick();  
 80016b2:	f7fe ff7d 	bl	80005b0 <HAL_GetTick>
 80016b6:	4606      	mov	r6, r0
 80016b8:	1c63      	adds	r3, r4, #1
    while((hdfsdm_filter->Instance->FLTISR & DFSDM_FLTISR_REOCF) != DFSDM_FLTISR_REOCF)
 80016ba:	682a      	ldr	r2, [r5, #0]
 80016bc:	d112      	bne.n	80016e4 <HAL_DFSDM_FilterPollForRegConversion+0x48>
 80016be:	6893      	ldr	r3, [r2, #8]
 80016c0:	0798      	lsls	r0, r3, #30
 80016c2:	d5fc      	bpl.n	80016be <HAL_DFSDM_FilterPollForRegConversion+0x22>
    if((hdfsdm_filter->Instance->FLTISR & DFSDM_FLTISR_ROVRF) == DFSDM_FLTISR_ROVRF)
 80016c4:	6893      	ldr	r3, [r2, #8]
 80016c6:	071b      	lsls	r3, r3, #28
 80016c8:	d419      	bmi.n	80016fe <HAL_DFSDM_FilterPollForRegConversion+0x62>
    if((hdfsdm_filter->RegularContMode == DFSDM_CONTINUOUS_CONV_OFF) && \
 80016ca:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80016cc:	b9ab      	cbnz	r3, 80016fa <HAL_DFSDM_FilterPollForRegConversion+0x5e>
 80016ce:	6b68      	ldr	r0, [r5, #52]	; 0x34
 80016d0:	b9f0      	cbnz	r0, 8001710 <HAL_DFSDM_FilterPollForRegConversion+0x74>
                             HAL_DFSDM_FILTER_STATE_READY : HAL_DFSDM_FILTER_STATE_INJ;
 80016d2:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
 80016d6:	2b02      	cmp	r3, #2
 80016d8:	bf0c      	ite	eq
 80016da:	2301      	moveq	r3, #1
 80016dc:	2303      	movne	r3, #3
      hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
 80016de:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
}
 80016e2:	bd70      	pop	{r4, r5, r6, pc}
    while((hdfsdm_filter->Instance->FLTISR & DFSDM_FLTISR_REOCF) != DFSDM_FLTISR_REOCF)
 80016e4:	6893      	ldr	r3, [r2, #8]
 80016e6:	0799      	lsls	r1, r3, #30
 80016e8:	d4ec      	bmi.n	80016c4 <HAL_DFSDM_FilterPollForRegConversion+0x28>
        if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 80016ea:	b124      	cbz	r4, 80016f6 <HAL_DFSDM_FilterPollForRegConversion+0x5a>
 80016ec:	f7fe ff60 	bl	80005b0 <HAL_GetTick>
 80016f0:	1b80      	subs	r0, r0, r6
 80016f2:	42a0      	cmp	r0, r4
 80016f4:	d9e0      	bls.n	80016b8 <HAL_DFSDM_FilterPollForRegConversion+0x1c>
          return HAL_TIMEOUT;
 80016f6:	2003      	movs	r0, #3
}
 80016f8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_OK;
 80016fa:	2000      	movs	r0, #0
}
 80016fc:	bd70      	pop	{r4, r5, r6, pc}
      hdfsdm_filter->ErrorCode = DFSDM_FILTER_ERROR_REGULAR_OVERRUN;
 80016fe:	2301      	movs	r3, #1
      HAL_DFSDM_FilterErrorCallback(hdfsdm_filter);
 8001700:	4628      	mov	r0, r5
      hdfsdm_filter->ErrorCode = DFSDM_FILTER_ERROR_REGULAR_OVERRUN;
 8001702:	652b      	str	r3, [r5, #80]	; 0x50
      HAL_DFSDM_FilterErrorCallback(hdfsdm_filter);
 8001704:	f7ff ffc8 	bl	8001698 <HAL_DFSDM_FilterErrorCallback>
      hdfsdm_filter->Instance->FLTICR = DFSDM_FLTICR_CLRROVRF;
 8001708:	682b      	ldr	r3, [r5, #0]
 800170a:	2208      	movs	r2, #8
 800170c:	60da      	str	r2, [r3, #12]
 800170e:	e7dc      	b.n	80016ca <HAL_DFSDM_FilterPollForRegConversion+0x2e>
    return HAL_OK;
 8001710:	4618      	mov	r0, r3
}
 8001712:	bd70      	pop	{r4, r5, r6, pc}

08001714 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8001714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001716:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8001718:	f7fe ff4a 	bl	80005b0 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800171c:	2c00      	cmp	r4, #0
 800171e:	d053      	beq.n	80017c8 <HAL_DMA_Init+0xb4>
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8001720:	2202      	movs	r2, #2
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8001722:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 8001724:	2100      	movs	r1, #0
 8001726:	4605      	mov	r5, r0
  hdma->State = HAL_DMA_STATE_BUSY;
 8001728:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 800172c:	681a      	ldr	r2, [r3, #0]
  __HAL_UNLOCK(hdma);
 800172e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 8001732:	f022 0201 	bic.w	r2, r2, #1
 8001736:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8001738:	e005      	b.n	8001746 <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800173a:	f7fe ff39 	bl	80005b0 <HAL_GetTick>
 800173e:	1b40      	subs	r0, r0, r5
 8001740:	2805      	cmp	r0, #5
 8001742:	d83a      	bhi.n	80017ba <HAL_DMA_Init+0xa6>
 8001744:	6823      	ldr	r3, [r4, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8001746:	681a      	ldr	r2, [r3, #0]
 8001748:	07d1      	lsls	r1, r2, #31
 800174a:	d4f6      	bmi.n	800173a <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800174c:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 8001750:	68e1      	ldr	r1, [r4, #12]
 8001752:	4302      	orrs	r2, r0
  tmp = hdma->Instance->CR;
 8001754:	681f      	ldr	r7, [r3, #0]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001756:	e9d4 0504 	ldrd	r0, r5, [r4, #16]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800175a:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800175c:	4302      	orrs	r2, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
 800175e:	6a20      	ldr	r0, [r4, #32]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001760:	e9d4 6106 	ldrd	r6, r1, [r4, #24]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001764:	432a      	orrs	r2, r5
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001766:	4d35      	ldr	r5, [pc, #212]	; (800183c <HAL_DMA_Init+0x128>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001768:	4332      	orrs	r2, r6
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800176a:	403d      	ands	r5, r7
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800176c:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800176e:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hdma->Init.Mode                | hdma->Init.Priority;
 8001770:	4302      	orrs	r2, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001772:	2904      	cmp	r1, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001774:	ea42 0205 	orr.w	r2, r2, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001778:	d028      	beq.n	80017cc <HAL_DMA_Init+0xb8>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800177a:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800177c:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800177e:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8001782:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001784:	b2da      	uxtb	r2, r3
 8001786:	4d2e      	ldr	r5, [pc, #184]	; (8001840 <HAL_DMA_Init+0x12c>)
  hdma->Instance->FCR = tmp;
 8001788:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800178a:	3a10      	subs	r2, #16
 800178c:	492d      	ldr	r1, [pc, #180]	; (8001844 <HAL_DMA_Init+0x130>)
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800178e:	482e      	ldr	r0, [pc, #184]	; (8001848 <HAL_DMA_Init+0x134>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001790:	fba5 5202 	umull	r5, r2, r5, r2
 8001794:	4019      	ands	r1, r3
  hdma->State = HAL_DMA_STATE_READY;
 8001796:	2501      	movs	r5, #1
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001798:	0913      	lsrs	r3, r2, #4
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800179a:	2200      	movs	r2, #0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800179c:	5cc0      	ldrb	r0, [r0, r3]
  
  if (stream_number > 3U)
 800179e:	2b03      	cmp	r3, #3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017a0:	f04f 033f 	mov.w	r3, #63	; 0x3f
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80017a4:	bf88      	it	hi
 80017a6:	3104      	addhi	r1, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80017a8:	65e0      	str	r0, [r4, #92]	; 0x5c
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017aa:	4083      	lsls	r3, r0
  return HAL_OK;
 80017ac:	4610      	mov	r0, r2
 80017ae:	65a1      	str	r1, [r4, #88]	; 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80017b0:	608b      	str	r3, [r1, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80017b2:	6562      	str	r2, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 80017b4:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
}
 80017b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80017ba:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80017bc:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 80017be:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80017c0:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80017c2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80017c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80017c8:	2001      	movs	r0, #1
}
 80017ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80017cc:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 80017d0:	6aa7      	ldr	r7, [r4, #40]	; 0x28
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80017d2:	ea45 0001 	orr.w	r0, r5, r1
    tmp |= hdma->Init.FIFOThreshold;
 80017d6:	f047 0104 	orr.w	r1, r7, #4
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80017da:	4302      	orrs	r2, r0
  hdma->Instance->CR = tmp;  
 80017dc:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 80017de:	695a      	ldr	r2, [r3, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80017e0:	f022 0207 	bic.w	r2, r2, #7
    tmp |= hdma->Init.FIFOThreshold;
 80017e4:	4311      	orrs	r1, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80017e6:	2d00      	cmp	r5, #0
 80017e8:	d0cc      	beq.n	8001784 <HAL_DMA_Init+0x70>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80017ea:	b17e      	cbz	r6, 800180c <HAL_DMA_Init+0xf8>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80017ec:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 80017f0:	d016      	beq.n	8001820 <HAL_DMA_Init+0x10c>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 80017f2:	2f02      	cmp	r7, #2
 80017f4:	d903      	bls.n	80017fe <HAL_DMA_Init+0xea>
 80017f6:	2f03      	cmp	r7, #3
 80017f8:	d1c4      	bne.n	8001784 <HAL_DMA_Init+0x70>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80017fa:	01ea      	lsls	r2, r5, #7
 80017fc:	d5c2      	bpl.n	8001784 <HAL_DMA_Init+0x70>
        hdma->State = HAL_DMA_STATE_READY;
 80017fe:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001800:	2240      	movs	r2, #64	; 0x40
        return HAL_ERROR; 
 8001802:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001804:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8001806:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800180a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (tmp)
 800180c:	2f01      	cmp	r7, #1
 800180e:	d003      	beq.n	8001818 <HAL_DMA_Init+0x104>
 8001810:	d3f3      	bcc.n	80017fa <HAL_DMA_Init+0xe6>
 8001812:	2f02      	cmp	r7, #2
 8001814:	d1b6      	bne.n	8001784 <HAL_DMA_Init+0x70>
 8001816:	e7f0      	b.n	80017fa <HAL_DMA_Init+0xe6>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8001818:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 800181c:	d1b2      	bne.n	8001784 <HAL_DMA_Init+0x70>
 800181e:	e7ee      	b.n	80017fe <HAL_DMA_Init+0xea>
    switch (tmp)
 8001820:	2f03      	cmp	r7, #3
 8001822:	d8af      	bhi.n	8001784 <HAL_DMA_Init+0x70>
 8001824:	a201      	add	r2, pc, #4	; (adr r2, 800182c <HAL_DMA_Init+0x118>)
 8001826:	f852 f027 	ldr.w	pc, [r2, r7, lsl #2]
 800182a:	bf00      	nop
 800182c:	080017ff 	.word	0x080017ff
 8001830:	080017fb 	.word	0x080017fb
 8001834:	080017ff 	.word	0x080017ff
 8001838:	08001819 	.word	0x08001819
 800183c:	e010803f 	.word	0xe010803f
 8001840:	aaaaaaab 	.word	0xaaaaaaab
 8001844:	fffffc00 	.word	0xfffffc00
 8001848:	08009940 	.word	0x08009940

0800184c <HAL_DMA_Start_IT>:
{
 800184c:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(hdma);
 800184e:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8001852:	2c01      	cmp	r4, #1
 8001854:	d038      	beq.n	80018c8 <HAL_DMA_Start_IT+0x7c>
 8001856:	2501      	movs	r5, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8001858:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800185c:	6d86      	ldr	r6, [r0, #88]	; 0x58
  if(HAL_DMA_STATE_READY == hdma->State)
 800185e:	42ac      	cmp	r4, r5
  __HAL_LOCK(hdma);
 8001860:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8001864:	d129      	bne.n	80018ba <HAL_DMA_Start_IT+0x6e>
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001866:	6804      	ldr	r4, [r0, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8001868:	2702      	movs	r7, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800186a:	2500      	movs	r5, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 800186c:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001870:	6545      	str	r5, [r0, #84]	; 0x54
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001872:	6887      	ldr	r7, [r0, #8]
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001874:	6825      	ldr	r5, [r4, #0]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001876:	2f40      	cmp	r7, #64	; 0x40
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001878:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 800187c:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 800187e:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001880:	d026      	beq.n	80018d0 <HAL_DMA_Start_IT+0x84>
    hdma->Instance->PAR = SrcAddress;
 8001882:	60a1      	str	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8001884:	60e2      	str	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001886:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8001888:	233f      	movs	r3, #63	; 0x3f
    if(hdma->XferHalfCpltCallback != NULL)
 800188a:	6c02      	ldr	r2, [r0, #64]	; 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800188c:	408b      	lsls	r3, r1
 800188e:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8001890:	6823      	ldr	r3, [r4, #0]
 8001892:	f043 0316 	orr.w	r3, r3, #22
 8001896:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8001898:	6963      	ldr	r3, [r4, #20]
 800189a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800189e:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 80018a0:	b11a      	cbz	r2, 80018aa <HAL_DMA_Start_IT+0x5e>
      hdma->Instance->CR  |= DMA_IT_HT;
 80018a2:	6823      	ldr	r3, [r4, #0]
 80018a4:	f043 0308 	orr.w	r3, r3, #8
 80018a8:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 80018aa:	6822      	ldr	r2, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80018ac:	2300      	movs	r3, #0
    __HAL_DMA_ENABLE(hdma);
 80018ae:	f042 0201 	orr.w	r2, r2, #1
}
 80018b2:	4618      	mov	r0, r3
    __HAL_DMA_ENABLE(hdma);
 80018b4:	6022      	str	r2, [r4, #0]
}
 80018b6:	bcf0      	pop	{r4, r5, r6, r7}
 80018b8:	4770      	bx	lr
    __HAL_UNLOCK(hdma);	  
 80018ba:	2200      	movs	r2, #0
    status = HAL_BUSY;
 80018bc:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);	  
 80018be:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
}
 80018c2:	4618      	mov	r0, r3
 80018c4:	bcf0      	pop	{r4, r5, r6, r7}
 80018c6:	4770      	bx	lr
  __HAL_LOCK(hdma);
 80018c8:	2302      	movs	r3, #2
}
 80018ca:	bcf0      	pop	{r4, r5, r6, r7}
 80018cc:	4618      	mov	r0, r3
 80018ce:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 80018d0:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 80018d2:	60e1      	str	r1, [r4, #12]
 80018d4:	e7d7      	b.n	8001886 <HAL_DMA_Start_IT+0x3a>
 80018d6:	bf00      	nop

080018d8 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80018d8:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
{
 80018dc:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80018de:	2a02      	cmp	r2, #2
 80018e0:	d003      	beq.n	80018ea <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80018e2:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 80018e4:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80018e6:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 80018e8:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 80018ea:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 80018ec:	2105      	movs	r1, #5
  return HAL_OK;
 80018ee:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 80018f0:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 80018f4:	6813      	ldr	r3, [r2, #0]
 80018f6:	f023 0301 	bic.w	r3, r3, #1
 80018fa:	6013      	str	r3, [r2, #0]
}
 80018fc:	4770      	bx	lr
 80018fe:	bf00      	nop

08001900 <HAL_DMA_IRQHandler>:
{
 8001900:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001902:	4604      	mov	r4, r0
 8001904:	b083      	sub	sp, #12
  __IO uint32_t count = 0;
 8001906:	2000      	movs	r0, #0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001908:	2208      	movs	r2, #8
  uint32_t timeout = SystemCoreClock / 9600;
 800190a:	4966      	ldr	r1, [pc, #408]	; (8001aa4 <HAL_DMA_IRQHandler+0x1a4>)
  __IO uint32_t count = 0;
 800190c:	9001      	str	r0, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600;
 800190e:	680e      	ldr	r6, [r1, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001910:	e9d4 7316 	ldrd	r7, r3, [r4, #88]	; 0x58
 8001914:	409a      	lsls	r2, r3
  tmpisr = regs->ISR;
 8001916:	683d      	ldr	r5, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001918:	422a      	tst	r2, r5
 800191a:	d003      	beq.n	8001924 <HAL_DMA_IRQHandler+0x24>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800191c:	6821      	ldr	r1, [r4, #0]
 800191e:	6808      	ldr	r0, [r1, #0]
 8001920:	0740      	lsls	r0, r0, #29
 8001922:	d459      	bmi.n	80019d8 <HAL_DMA_IRQHandler+0xd8>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8001924:	2201      	movs	r2, #1
 8001926:	409a      	lsls	r2, r3
 8001928:	422a      	tst	r2, r5
 800192a:	d003      	beq.n	8001934 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 800192c:	6821      	ldr	r1, [r4, #0]
 800192e:	6949      	ldr	r1, [r1, #20]
 8001930:	0608      	lsls	r0, r1, #24
 8001932:	d474      	bmi.n	8001a1e <HAL_DMA_IRQHandler+0x11e>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8001934:	2204      	movs	r2, #4
 8001936:	409a      	lsls	r2, r3
 8001938:	422a      	tst	r2, r5
 800193a:	d003      	beq.n	8001944 <HAL_DMA_IRQHandler+0x44>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800193c:	6821      	ldr	r1, [r4, #0]
 800193e:	6809      	ldr	r1, [r1, #0]
 8001940:	0789      	lsls	r1, r1, #30
 8001942:	d466      	bmi.n	8001a12 <HAL_DMA_IRQHandler+0x112>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8001944:	2210      	movs	r2, #16
 8001946:	409a      	lsls	r2, r3
 8001948:	422a      	tst	r2, r5
 800194a:	d003      	beq.n	8001954 <HAL_DMA_IRQHandler+0x54>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 800194c:	6821      	ldr	r1, [r4, #0]
 800194e:	6808      	ldr	r0, [r1, #0]
 8001950:	0700      	lsls	r0, r0, #28
 8001952:	d44b      	bmi.n	80019ec <HAL_DMA_IRQHandler+0xec>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8001954:	2220      	movs	r2, #32
 8001956:	409a      	lsls	r2, r3
 8001958:	422a      	tst	r2, r5
 800195a:	d014      	beq.n	8001986 <HAL_DMA_IRQHandler+0x86>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800195c:	6821      	ldr	r1, [r4, #0]
 800195e:	6808      	ldr	r0, [r1, #0]
 8001960:	06c0      	lsls	r0, r0, #27
 8001962:	d510      	bpl.n	8001986 <HAL_DMA_IRQHandler+0x86>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8001964:	60ba      	str	r2, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8001966:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 800196a:	2a05      	cmp	r2, #5
 800196c:	d063      	beq.n	8001a36 <HAL_DMA_IRQHandler+0x136>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800196e:	680b      	ldr	r3, [r1, #0]
 8001970:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001974:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001976:	d07e      	beq.n	8001a76 <HAL_DMA_IRQHandler+0x176>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001978:	0319      	lsls	r1, r3, #12
 800197a:	f140 8089 	bpl.w	8001a90 <HAL_DMA_IRQHandler+0x190>
        if(hdma->XferCpltCallback != NULL)
 800197e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001980:	b10b      	cbz	r3, 8001986 <HAL_DMA_IRQHandler+0x86>
          hdma->XferCpltCallback(hdma);
 8001982:	4620      	mov	r0, r4
 8001984:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8001986:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001988:	b323      	cbz	r3, 80019d4 <HAL_DMA_IRQHandler+0xd4>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800198a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800198c:	07da      	lsls	r2, r3, #31
 800198e:	d51a      	bpl.n	80019c6 <HAL_DMA_IRQHandler+0xc6>
      __HAL_DMA_DISABLE(hdma);
 8001990:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_ABORT;
 8001992:	2105      	movs	r1, #5
  uint32_t timeout = SystemCoreClock / 9600;
 8001994:	4b44      	ldr	r3, [pc, #272]	; (8001aa8 <HAL_DMA_IRQHandler+0x1a8>)
      hdma->State = HAL_DMA_STATE_ABORT;
 8001996:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  uint32_t timeout = SystemCoreClock / 9600;
 800199a:	fba3 3606 	umull	r3, r6, r3, r6
      __HAL_DMA_DISABLE(hdma);
 800199e:	6813      	ldr	r3, [r2, #0]
 80019a0:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 80019a4:	0ab6      	lsrs	r6, r6, #10
      __HAL_DMA_DISABLE(hdma);
 80019a6:	6013      	str	r3, [r2, #0]
 80019a8:	e002      	b.n	80019b0 <HAL_DMA_IRQHandler+0xb0>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80019aa:	6813      	ldr	r3, [r2, #0]
 80019ac:	07db      	lsls	r3, r3, #31
 80019ae:	d504      	bpl.n	80019ba <HAL_DMA_IRQHandler+0xba>
        if (++count > timeout)
 80019b0:	9b01      	ldr	r3, [sp, #4]
 80019b2:	3301      	adds	r3, #1
 80019b4:	42b3      	cmp	r3, r6
 80019b6:	9301      	str	r3, [sp, #4]
 80019b8:	d9f7      	bls.n	80019aa <HAL_DMA_IRQHandler+0xaa>
      __HAL_UNLOCK(hdma);
 80019ba:	2200      	movs	r2, #0
      hdma->State = HAL_DMA_STATE_READY;
 80019bc:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
 80019be:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 80019c2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 80019c6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80019c8:	b123      	cbz	r3, 80019d4 <HAL_DMA_IRQHandler+0xd4>
      hdma->XferErrorCallback(hdma);
 80019ca:	4620      	mov	r0, r4
}
 80019cc:	b003      	add	sp, #12
 80019ce:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 80019d2:	4718      	bx	r3
}
 80019d4:	b003      	add	sp, #12
 80019d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 80019d8:	6808      	ldr	r0, [r1, #0]
 80019da:	f020 0004 	bic.w	r0, r0, #4
 80019de:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 80019e0:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 80019e2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80019e4:	f042 0201 	orr.w	r2, r2, #1
 80019e8:	6562      	str	r2, [r4, #84]	; 0x54
 80019ea:	e79b      	b.n	8001924 <HAL_DMA_IRQHandler+0x24>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80019ec:	60ba      	str	r2, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80019ee:	680a      	ldr	r2, [r1, #0]
 80019f0:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80019f4:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80019f6:	d118      	bne.n	8001a2a <HAL_DMA_IRQHandler+0x12a>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80019f8:	05d2      	lsls	r2, r2, #23
 80019fa:	d403      	bmi.n	8001a04 <HAL_DMA_IRQHandler+0x104>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80019fc:	680a      	ldr	r2, [r1, #0]
 80019fe:	f022 0208 	bic.w	r2, r2, #8
 8001a02:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8001a04:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001a06:	2a00      	cmp	r2, #0
 8001a08:	d0a4      	beq.n	8001954 <HAL_DMA_IRQHandler+0x54>
          hdma->XferHalfCpltCallback(hdma);
 8001a0a:	4620      	mov	r0, r4
 8001a0c:	4790      	blx	r2
 8001a0e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001a10:	e7a0      	b.n	8001954 <HAL_DMA_IRQHandler+0x54>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8001a12:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8001a14:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001a16:	f042 0204 	orr.w	r2, r2, #4
 8001a1a:	6562      	str	r2, [r4, #84]	; 0x54
 8001a1c:	e792      	b.n	8001944 <HAL_DMA_IRQHandler+0x44>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8001a1e:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8001a20:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001a22:	f042 0202 	orr.w	r2, r2, #2
 8001a26:	6562      	str	r2, [r4, #84]	; 0x54
 8001a28:	e784      	b.n	8001934 <HAL_DMA_IRQHandler+0x34>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001a2a:	0311      	lsls	r1, r2, #12
 8001a2c:	d5ea      	bpl.n	8001a04 <HAL_DMA_IRQHandler+0x104>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8001a2e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001a30:	2a00      	cmp	r2, #0
 8001a32:	d1ea      	bne.n	8001a0a <HAL_DMA_IRQHandler+0x10a>
 8001a34:	e78e      	b.n	8001954 <HAL_DMA_IRQHandler+0x54>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001a36:	680a      	ldr	r2, [r1, #0]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001a38:	6c20      	ldr	r0, [r4, #64]	; 0x40
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001a3a:	f022 0216 	bic.w	r2, r2, #22
 8001a3e:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8001a40:	694a      	ldr	r2, [r1, #20]
 8001a42:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001a46:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001a48:	b338      	cbz	r0, 8001a9a <HAL_DMA_IRQHandler+0x19a>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001a4a:	680a      	ldr	r2, [r1, #0]
 8001a4c:	f022 0208 	bic.w	r2, r2, #8
 8001a50:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001a52:	223f      	movs	r2, #63	; 0x3f
        __HAL_UNLOCK(hdma);
 8001a54:	2000      	movs	r0, #0
        hdma->State = HAL_DMA_STATE_READY;
 8001a56:	2101      	movs	r1, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001a58:	fa02 f303 	lsl.w	r3, r2, r3
        if(hdma->XferAbortCallback != NULL)
 8001a5c:	6d22      	ldr	r2, [r4, #80]	; 0x50
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001a5e:	60bb      	str	r3, [r7, #8]
        __HAL_UNLOCK(hdma);
 8001a60:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8001a64:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8001a68:	2a00      	cmp	r2, #0
 8001a6a:	d0b3      	beq.n	80019d4 <HAL_DMA_IRQHandler+0xd4>
          hdma->XferAbortCallback(hdma);
 8001a6c:	4620      	mov	r0, r4
}
 8001a6e:	b003      	add	sp, #12
 8001a70:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
          hdma->XferAbortCallback(hdma);
 8001a74:	4710      	bx	r2
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001a76:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8001a7a:	d180      	bne.n	800197e <HAL_DMA_IRQHandler+0x7e>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8001a7c:	680a      	ldr	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8001a7e:	2001      	movs	r0, #1
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8001a80:	f022 0210 	bic.w	r2, r2, #16
 8001a84:	600a      	str	r2, [r1, #0]
          __HAL_UNLOCK(hdma);
 8001a86:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8001a8a:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 8001a8e:	e776      	b.n	800197e <HAL_DMA_IRQHandler+0x7e>
          if(hdma->XferM1CpltCallback != NULL)
 8001a90:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001a92:	2b00      	cmp	r3, #0
 8001a94:	f47f af75 	bne.w	8001982 <HAL_DMA_IRQHandler+0x82>
 8001a98:	e775      	b.n	8001986 <HAL_DMA_IRQHandler+0x86>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001a9a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001a9c:	2a00      	cmp	r2, #0
 8001a9e:	d1d4      	bne.n	8001a4a <HAL_DMA_IRQHandler+0x14a>
 8001aa0:	e7d7      	b.n	8001a52 <HAL_DMA_IRQHandler+0x152>
 8001aa2:	bf00      	nop
 8001aa4:	20001f48 	.word	0x20001f48
 8001aa8:	1b4e81b5 	.word	0x1b4e81b5

08001aac <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8001aac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001ab0:	4f7d      	ldr	r7, [pc, #500]	; (8001ca8 <HAL_FLASH_Program+0x1fc>)
 8001ab2:	7d3c      	ldrb	r4, [r7, #20]
 8001ab4:	2c01      	cmp	r4, #1
 8001ab6:	d05b      	beq.n	8001b70 <HAL_FLASH_Program+0xc4>
 8001ab8:	469b      	mov	fp, r3
 8001aba:	4691      	mov	r9, r2
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
  uint32_t tickstart = 0;
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001abc:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
 8001abe:	2201      	movs	r2, #1
 8001ac0:	468a      	mov	sl, r1
 8001ac2:	4680      	mov	r8, r0
 8001ac4:	753a      	strb	r2, [r7, #20]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
  { 
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001ac6:	f24c 3650 	movw	r6, #50000	; 0xc350
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001aca:	61bb      	str	r3, [r7, #24]
  tickstart = HAL_GetTick();
 8001acc:	f7fe fd70 	bl	80005b0 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001ad0:	4c76      	ldr	r4, [pc, #472]	; (8001cac <HAL_FLASH_Program+0x200>)
  tickstart = HAL_GetTick();
 8001ad2:	4605      	mov	r5, r0
 8001ad4:	e004      	b.n	8001ae0 <HAL_FLASH_Program+0x34>
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001ad6:	f7fe fd6b 	bl	80005b0 <HAL_GetTick>
 8001ada:	1b40      	subs	r0, r0, r5
 8001adc:	42b0      	cmp	r0, r6
 8001ade:	d84a      	bhi.n	8001b76 <HAL_FLASH_Program+0xca>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001ae0:	68e3      	ldr	r3, [r4, #12]
 8001ae2:	03db      	lsls	r3, r3, #15
 8001ae4:	d4f7      	bmi.n	8001ad6 <HAL_FLASH_Program+0x2a>
        return HAL_TIMEOUT;
      }
    } 
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8001ae6:	68e3      	ldr	r3, [r4, #12]
 8001ae8:	f013 0ff2 	tst.w	r3, #242	; 0xf2
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8001aec:	68e3      	ldr	r3, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8001aee:	f040 80ae 	bne.w	8001c4e <HAL_FLASH_Program+0x1a2>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8001af2:	07da      	lsls	r2, r3, #31
 8001af4:	d501      	bpl.n	8001afa <HAL_FLASH_Program+0x4e>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001af6:	2301      	movs	r3, #1
 8001af8:	60e3      	str	r3, [r4, #12]
    switch(TypeProgram)
 8001afa:	f1b8 0f03 	cmp.w	r8, #3
 8001afe:	d814      	bhi.n	8001b2a <HAL_FLASH_Program+0x7e>
 8001b00:	e8df f008 	tbb	[pc, r8]
 8001b04:	3e665202 	.word	0x3e665202
  FLASH->CR &= CR_PSIZE_MASK;
 8001b08:	4b68      	ldr	r3, [pc, #416]	; (8001cac <HAL_FLASH_Program+0x200>)
        FLASH_Program_Byte(Address, (uint8_t) Data);
 8001b0a:	fa5f f989 	uxtb.w	r9, r9
  FLASH->CR &= CR_PSIZE_MASK;
 8001b0e:	691a      	ldr	r2, [r3, #16]
 8001b10:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001b14:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8001b16:	691a      	ldr	r2, [r3, #16]
 8001b18:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8001b1a:	691a      	ldr	r2, [r3, #16]
 8001b1c:	f042 0201 	orr.w	r2, r2, #1
 8001b20:	611a      	str	r2, [r3, #16]
  *(__IO uint8_t*)Address = Data;
 8001b22:	f88a 9000 	strb.w	r9, [sl]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001b26:	f3bf 8f4f 	dsb	sy
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b2a:	2300      	movs	r3, #0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001b2c:	4c5f      	ldr	r4, [pc, #380]	; (8001cac <HAL_FLASH_Program+0x200>)
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001b2e:	f24c 3650 	movw	r6, #50000	; 0xc350
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001b32:	61bb      	str	r3, [r7, #24]
  tickstart = HAL_GetTick();
 8001b34:	f7fe fd3c 	bl	80005b0 <HAL_GetTick>
 8001b38:	4605      	mov	r5, r0
 8001b3a:	e005      	b.n	8001b48 <HAL_FLASH_Program+0x9c>
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001b3c:	f7fe fd38 	bl	80005b0 <HAL_GetTick>
 8001b40:	1b40      	subs	r0, r0, r5
 8001b42:	42b0      	cmp	r0, r6
 8001b44:	f200 8081 	bhi.w	8001c4a <HAL_FLASH_Program+0x19e>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001b48:	68e3      	ldr	r3, [r4, #12]
 8001b4a:	03db      	lsls	r3, r3, #15
 8001b4c:	d4f6      	bmi.n	8001b3c <HAL_FLASH_Program+0x90>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8001b4e:	68e0      	ldr	r0, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8001b50:	68e3      	ldr	r3, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8001b52:	f010 00f2 	ands.w	r0, r0, #242	; 0xf2
 8001b56:	d14d      	bne.n	8001bf4 <HAL_FLASH_Program+0x148>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8001b58:	f013 0301 	ands.w	r3, r3, #1
 8001b5c:	f000 80a2 	beq.w	8001ca4 <HAL_FLASH_Program+0x1f8>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001b60:	2301      	movs	r3, #1
 8001b62:	60e3      	str	r3, [r4, #12]
    FLASH->CR &= (~FLASH_CR_PG);
 8001b64:	4a51      	ldr	r2, [pc, #324]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001b66:	6913      	ldr	r3, [r2, #16]
 8001b68:	f023 0301 	bic.w	r3, r3, #1
 8001b6c:	6113      	str	r3, [r2, #16]
 8001b6e:	e003      	b.n	8001b78 <HAL_FLASH_Program+0xcc>
  __HAL_LOCK(&pFlash);
 8001b70:	2002      	movs	r0, #2
}
 8001b72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001b76:	2003      	movs	r0, #3
  __HAL_UNLOCK(&pFlash);
 8001b78:	2300      	movs	r3, #0
 8001b7a:	753b      	strb	r3, [r7, #20]
}
 8001b7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  FLASH->CR &= CR_PSIZE_MASK;
 8001b80:	4b4a      	ldr	r3, [pc, #296]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001b82:	691a      	ldr	r2, [r3, #16]
 8001b84:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001b88:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8001b8a:	691a      	ldr	r2, [r3, #16]
 8001b8c:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 8001b90:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8001b92:	691a      	ldr	r2, [r3, #16]
 8001b94:	f042 0201 	orr.w	r2, r2, #1
 8001b98:	611a      	str	r2, [r3, #16]
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8001b9a:	f8ca 9000 	str.w	r9, [sl]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8001b9e:	f8ca b004 	str.w	fp, [sl, #4]
 8001ba2:	f3bf 8f4f 	dsb	sy
 8001ba6:	e7c0      	b.n	8001b2a <HAL_FLASH_Program+0x7e>
  FLASH->CR &= CR_PSIZE_MASK;
 8001ba8:	4b40      	ldr	r3, [pc, #256]	; (8001cac <HAL_FLASH_Program+0x200>)
        FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8001baa:	fa1f f989 	uxth.w	r9, r9
  FLASH->CR &= CR_PSIZE_MASK;
 8001bae:	691a      	ldr	r2, [r3, #16]
 8001bb0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001bb4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8001bb6:	691a      	ldr	r2, [r3, #16]
 8001bb8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001bbc:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8001bbe:	691a      	ldr	r2, [r3, #16]
 8001bc0:	f042 0201 	orr.w	r2, r2, #1
 8001bc4:	611a      	str	r2, [r3, #16]
  *(__IO uint16_t*)Address = Data;
 8001bc6:	f8aa 9000 	strh.w	r9, [sl]
 8001bca:	f3bf 8f4f 	dsb	sy
 8001bce:	e7ac      	b.n	8001b2a <HAL_FLASH_Program+0x7e>
  FLASH->CR &= CR_PSIZE_MASK;
 8001bd0:	4b36      	ldr	r3, [pc, #216]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001bd2:	691a      	ldr	r2, [r3, #16]
 8001bd4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001bd8:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8001bda:	691a      	ldr	r2, [r3, #16]
 8001bdc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001be0:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8001be2:	691a      	ldr	r2, [r3, #16]
 8001be4:	f042 0201 	orr.w	r2, r2, #1
 8001be8:	611a      	str	r2, [r3, #16]
  *(__IO uint32_t*)Address = Data;
 8001bea:	f8ca 9000 	str.w	r9, [sl]
 8001bee:	f3bf 8f4f 	dsb	sy
 8001bf2:	e79a      	b.n	8001b2a <HAL_FLASH_Program+0x7e>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8001bf4:	079c      	lsls	r4, r3, #30
 8001bf6:	d503      	bpl.n	8001c00 <HAL_FLASH_Program+0x154>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8001bf8:	69bb      	ldr	r3, [r7, #24]
 8001bfa:	f043 0320 	orr.w	r3, r3, #32
 8001bfe:	61bb      	str	r3, [r7, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8001c00:	4b2a      	ldr	r3, [pc, #168]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c02:	68db      	ldr	r3, [r3, #12]
 8001c04:	06d8      	lsls	r0, r3, #27
 8001c06:	d503      	bpl.n	8001c10 <HAL_FLASH_Program+0x164>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001c08:	69bb      	ldr	r3, [r7, #24]
 8001c0a:	f043 0310 	orr.w	r3, r3, #16
 8001c0e:	61bb      	str	r3, [r7, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8001c10:	4b26      	ldr	r3, [pc, #152]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c12:	68db      	ldr	r3, [r3, #12]
 8001c14:	0699      	lsls	r1, r3, #26
 8001c16:	d503      	bpl.n	8001c20 <HAL_FLASH_Program+0x174>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8001c18:	69bb      	ldr	r3, [r7, #24]
 8001c1a:	f043 0308 	orr.w	r3, r3, #8
 8001c1e:	61bb      	str	r3, [r7, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8001c20:	4b22      	ldr	r3, [pc, #136]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c22:	68db      	ldr	r3, [r3, #12]
 8001c24:	065a      	lsls	r2, r3, #25
 8001c26:	d503      	bpl.n	8001c30 <HAL_FLASH_Program+0x184>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8001c28:	69bb      	ldr	r3, [r7, #24]
 8001c2a:	f043 0304 	orr.w	r3, r3, #4
 8001c2e:	61bb      	str	r3, [r7, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
 8001c30:	4b1e      	ldr	r3, [pc, #120]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c32:	68db      	ldr	r3, [r3, #12]
 8001c34:	061b      	lsls	r3, r3, #24
 8001c36:	d503      	bpl.n	8001c40 <HAL_FLASH_Program+0x194>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
 8001c38:	69bb      	ldr	r3, [r7, #24]
 8001c3a:	f043 0302 	orr.w	r3, r3, #2
 8001c3e:	61bb      	str	r3, [r7, #24]
   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
  }  
#endif /* FLASH_OPTCR2_PCROP */
  
  /* Clear error programming flags */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001c40:	4b1a      	ldr	r3, [pc, #104]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c42:	22f2      	movs	r2, #242	; 0xf2
    return HAL_ERROR;
 8001c44:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001c46:	60da      	str	r2, [r3, #12]
 8001c48:	e78c      	b.n	8001b64 <HAL_FLASH_Program+0xb8>
        return HAL_TIMEOUT;
 8001c4a:	2003      	movs	r0, #3
 8001c4c:	e78a      	b.n	8001b64 <HAL_FLASH_Program+0xb8>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8001c4e:	079e      	lsls	r6, r3, #30
 8001c50:	d503      	bpl.n	8001c5a <HAL_FLASH_Program+0x1ae>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8001c52:	69bb      	ldr	r3, [r7, #24]
 8001c54:	f043 0320 	orr.w	r3, r3, #32
 8001c58:	61bb      	str	r3, [r7, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8001c5a:	4b14      	ldr	r3, [pc, #80]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c5c:	68db      	ldr	r3, [r3, #12]
 8001c5e:	06dd      	lsls	r5, r3, #27
 8001c60:	d503      	bpl.n	8001c6a <HAL_FLASH_Program+0x1be>
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001c62:	69bb      	ldr	r3, [r7, #24]
 8001c64:	f043 0310 	orr.w	r3, r3, #16
 8001c68:	61bb      	str	r3, [r7, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8001c6a:	4b10      	ldr	r3, [pc, #64]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c6c:	68db      	ldr	r3, [r3, #12]
 8001c6e:	069c      	lsls	r4, r3, #26
 8001c70:	d503      	bpl.n	8001c7a <HAL_FLASH_Program+0x1ce>
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8001c72:	69bb      	ldr	r3, [r7, #24]
 8001c74:	f043 0308 	orr.w	r3, r3, #8
 8001c78:	61bb      	str	r3, [r7, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8001c7a:	4b0c      	ldr	r3, [pc, #48]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c7c:	68db      	ldr	r3, [r3, #12]
 8001c7e:	0658      	lsls	r0, r3, #25
 8001c80:	d503      	bpl.n	8001c8a <HAL_FLASH_Program+0x1de>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8001c82:	69bb      	ldr	r3, [r7, #24]
 8001c84:	f043 0304 	orr.w	r3, r3, #4
 8001c88:	61bb      	str	r3, [r7, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
 8001c8a:	4b08      	ldr	r3, [pc, #32]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c8c:	68db      	ldr	r3, [r3, #12]
 8001c8e:	0619      	lsls	r1, r3, #24
 8001c90:	d503      	bpl.n	8001c9a <HAL_FLASH_Program+0x1ee>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
 8001c92:	69bb      	ldr	r3, [r7, #24]
 8001c94:	f043 0302 	orr.w	r3, r3, #2
 8001c98:	61bb      	str	r3, [r7, #24]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001c9a:	4b04      	ldr	r3, [pc, #16]	; (8001cac <HAL_FLASH_Program+0x200>)
 8001c9c:	22f2      	movs	r2, #242	; 0xf2
    return HAL_ERROR;
 8001c9e:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001ca0:	60da      	str	r2, [r3, #12]
 8001ca2:	e769      	b.n	8001b78 <HAL_FLASH_Program+0xcc>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8001ca4:	4618      	mov	r0, r3
 8001ca6:	e75d      	b.n	8001b64 <HAL_FLASH_Program+0xb8>
 8001ca8:	20002100 	.word	0x20002100
 8001cac:	40023c00 	.word	0x40023c00

08001cb0 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8001cb0:	4b06      	ldr	r3, [pc, #24]	; (8001ccc <HAL_FLASH_Unlock+0x1c>)
 8001cb2:	691a      	ldr	r2, [r3, #16]
 8001cb4:	2a00      	cmp	r2, #0
 8001cb6:	db01      	blt.n	8001cbc <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8001cb8:	2000      	movs	r0, #0
}
 8001cba:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001cbc:	4904      	ldr	r1, [pc, #16]	; (8001cd0 <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001cbe:	4a05      	ldr	r2, [pc, #20]	; (8001cd4 <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001cc0:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001cc2:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8001cc4:	6918      	ldr	r0, [r3, #16]
  HAL_StatusTypeDef status = HAL_OK;
 8001cc6:	0fc0      	lsrs	r0, r0, #31
 8001cc8:	4770      	bx	lr
 8001cca:	bf00      	nop
 8001ccc:	40023c00 	.word	0x40023c00
 8001cd0:	45670123 	.word	0x45670123
 8001cd4:	cdef89ab 	.word	0xcdef89ab

08001cd8 <HAL_FLASH_Lock>:
  FLASH->CR |= FLASH_CR_LOCK;
 8001cd8:	4a03      	ldr	r2, [pc, #12]	; (8001ce8 <HAL_FLASH_Lock+0x10>)
}
 8001cda:	2000      	movs	r0, #0
  FLASH->CR |= FLASH_CR_LOCK;
 8001cdc:	6913      	ldr	r3, [r2, #16]
 8001cde:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001ce2:	6113      	str	r3, [r2, #16]
}
 8001ce4:	4770      	bx	lr
 8001ce6:	bf00      	nop
 8001ce8:	40023c00 	.word	0x40023c00

08001cec <FLASH_WaitForLastOperation>:
{ 
 8001cec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001cee:	2300      	movs	r3, #0
 8001cf0:	4d28      	ldr	r5, [pc, #160]	; (8001d94 <FLASH_WaitForLastOperation+0xa8>)
{ 
 8001cf2:	4604      	mov	r4, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001cf4:	4e28      	ldr	r6, [pc, #160]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001cf6:	61ab      	str	r3, [r5, #24]
  tickstart = HAL_GetTick();
 8001cf8:	f7fe fc5a 	bl	80005b0 <HAL_GetTick>
 8001cfc:	4607      	mov	r7, r0
 8001cfe:	1c60      	adds	r0, r4, #1
 8001d00:	d10f      	bne.n	8001d22 <FLASH_WaitForLastOperation+0x36>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001d02:	4a25      	ldr	r2, [pc, #148]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d04:	68d3      	ldr	r3, [r2, #12]
 8001d06:	03d9      	lsls	r1, r3, #15
 8001d08:	d4fc      	bmi.n	8001d04 <FLASH_WaitForLastOperation+0x18>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8001d0a:	4b23      	ldr	r3, [pc, #140]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d0c:	68d8      	ldr	r0, [r3, #12]
 8001d0e:	f010 00f2 	ands.w	r0, r0, #242	; 0xf2
 8001d12:	d113      	bne.n	8001d3c <FLASH_WaitForLastOperation+0x50>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8001d14:	68da      	ldr	r2, [r3, #12]
 8001d16:	f012 0201 	ands.w	r2, r2, #1
 8001d1a:	d00d      	beq.n	8001d38 <FLASH_WaitForLastOperation+0x4c>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001d1c:	2201      	movs	r2, #1
 8001d1e:	60da      	str	r2, [r3, #12]
}  
 8001d20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8001d22:	68f3      	ldr	r3, [r6, #12]
 8001d24:	03db      	lsls	r3, r3, #15
 8001d26:	d5f0      	bpl.n	8001d0a <FLASH_WaitForLastOperation+0x1e>
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001d28:	b124      	cbz	r4, 8001d34 <FLASH_WaitForLastOperation+0x48>
 8001d2a:	f7fe fc41 	bl	80005b0 <HAL_GetTick>
 8001d2e:	1bc0      	subs	r0, r0, r7
 8001d30:	42a0      	cmp	r0, r4
 8001d32:	d9e4      	bls.n	8001cfe <FLASH_WaitForLastOperation+0x12>
        return HAL_TIMEOUT;
 8001d34:	2003      	movs	r0, #3
}  
 8001d36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8001d38:	4610      	mov	r0, r2
}  
 8001d3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8001d3c:	68db      	ldr	r3, [r3, #12]
 8001d3e:	079c      	lsls	r4, r3, #30
 8001d40:	d503      	bpl.n	8001d4a <FLASH_WaitForLastOperation+0x5e>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8001d42:	69ab      	ldr	r3, [r5, #24]
 8001d44:	f043 0320 	orr.w	r3, r3, #32
 8001d48:	61ab      	str	r3, [r5, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8001d4a:	4b13      	ldr	r3, [pc, #76]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d4c:	68db      	ldr	r3, [r3, #12]
 8001d4e:	06d8      	lsls	r0, r3, #27
 8001d50:	d503      	bpl.n	8001d5a <FLASH_WaitForLastOperation+0x6e>
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001d52:	69ab      	ldr	r3, [r5, #24]
 8001d54:	f043 0310 	orr.w	r3, r3, #16
 8001d58:	61ab      	str	r3, [r5, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8001d5a:	4b0f      	ldr	r3, [pc, #60]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d5c:	68db      	ldr	r3, [r3, #12]
 8001d5e:	0699      	lsls	r1, r3, #26
 8001d60:	d503      	bpl.n	8001d6a <FLASH_WaitForLastOperation+0x7e>
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8001d62:	69ab      	ldr	r3, [r5, #24]
 8001d64:	f043 0308 	orr.w	r3, r3, #8
 8001d68:	61ab      	str	r3, [r5, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8001d6a:	4b0b      	ldr	r3, [pc, #44]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d6c:	68db      	ldr	r3, [r3, #12]
 8001d6e:	065a      	lsls	r2, r3, #25
 8001d70:	d503      	bpl.n	8001d7a <FLASH_WaitForLastOperation+0x8e>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8001d72:	69ab      	ldr	r3, [r5, #24]
 8001d74:	f043 0304 	orr.w	r3, r3, #4
 8001d78:	61ab      	str	r3, [r5, #24]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
 8001d7a:	4b07      	ldr	r3, [pc, #28]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d7c:	68db      	ldr	r3, [r3, #12]
 8001d7e:	061b      	lsls	r3, r3, #24
 8001d80:	d503      	bpl.n	8001d8a <FLASH_WaitForLastOperation+0x9e>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
 8001d82:	69ab      	ldr	r3, [r5, #24]
 8001d84:	f043 0302 	orr.w	r3, r3, #2
 8001d88:	61ab      	str	r3, [r5, #24]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001d8a:	4b03      	ldr	r3, [pc, #12]	; (8001d98 <FLASH_WaitForLastOperation+0xac>)
 8001d8c:	22f2      	movs	r2, #242	; 0xf2
    return HAL_ERROR;
 8001d8e:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8001d90:	60da      	str	r2, [r3, #12]
}  
 8001d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001d94:	20002100 	.word	0x20002100
 8001d98:	40023c00 	.word	0x40023c00

08001d9c <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 8001d9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t index = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001da0:	4e49      	ldr	r6, [pc, #292]	; (8001ec8 <HAL_FLASHEx_Erase+0x12c>)
 8001da2:	7d33      	ldrb	r3, [r6, #20]
 8001da4:	2b01      	cmp	r3, #1
 8001da6:	f000 8081 	beq.w	8001eac <HAL_FLASHEx_Erase+0x110>
 8001daa:	2301      	movs	r3, #1
 8001dac:	4681      	mov	r9, r0

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001dae:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001db2:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 8001db4:	7533      	strb	r3, [r6, #20]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001db6:	f7ff ff99 	bl	8001cec <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 8001dba:	4607      	mov	r7, r0
 8001dbc:	2800      	cmp	r0, #0
 8001dbe:	d170      	bne.n	8001ea2 <HAL_FLASHEx_Erase+0x106>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 8001dc0:	f04f 33ff 	mov.w	r3, #4294967295
 8001dc4:	f8c8 3000 	str.w	r3, [r8]
    
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001dc8:	f8d9 3000 	ldr.w	r3, [r9]
 8001dcc:	2b01      	cmp	r3, #1
 8001dce:	d042      	beq.n	8001e56 <HAL_FLASHEx_Erase+0xba>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8001dd0:	e9d9 5302 	ldrd	r5, r3, [r9, #8]
 8001dd4:	442b      	add	r3, r5
 8001dd6:	429d      	cmp	r5, r3
 8001dd8:	d263      	bcs.n	8001ea2 <HAL_FLASHEx_Erase+0x106>
  {
    Sector += 4;
  }  

  /* If the previous operation is completed, proceed to erase the sector */
  FLASH->CR &= CR_PSIZE_MASK;
 8001dda:	4c3c      	ldr	r4, [pc, #240]	; (8001ecc <HAL_FLASHEx_Erase+0x130>)
 8001ddc:	e032      	b.n	8001e44 <HAL_FLASHEx_Erase+0xa8>
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8001dde:	2b02      	cmp	r3, #2
 8001de0:	bf0c      	ite	eq
 8001de2:	f44f 7300 	moveq.w	r3, #512	; 0x200
 8001de6:	f44f 7340 	movne.w	r3, #768	; 0x300
  FLASH->CR &= CR_PSIZE_MASK;
 8001dea:	6922      	ldr	r2, [r4, #16]
  if(Sector > FLASH_SECTOR_11) 
 8001dec:	2d0b      	cmp	r5, #11
 8001dee:	4629      	mov	r1, r5
  FLASH->CR &= CR_PSIZE_MASK;
 8001df0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    Sector += 4;
 8001df4:	bf88      	it	hi
 8001df6:	1d29      	addhi	r1, r5, #4
  FLASH->CR &= CR_PSIZE_MASK;
 8001df8:	6122      	str	r2, [r4, #16]
  FLASH->CR |= tmp_psize;
 8001dfa:	6922      	ldr	r2, [r4, #16]
 8001dfc:	4313      	orrs	r3, r2
 8001dfe:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8001e00:	6922      	ldr	r2, [r4, #16]
 8001e02:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8001e06:	6122      	str	r2, [r4, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8001e08:	6923      	ldr	r3, [r4, #16]
 8001e0a:	f043 0302 	orr.w	r3, r3, #2
 8001e0e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001e12:	6123      	str	r3, [r4, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8001e14:	6923      	ldr	r3, [r4, #16]
 8001e16:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001e1a:	6123      	str	r3, [r4, #16]
 8001e1c:	f3bf 8f4f 	dsb	sy
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e20:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001e24:	f7ff ff62 	bl	8001cec <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB)); 
 8001e28:	6923      	ldr	r3, [r4, #16]
 8001e2a:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8001e2e:	6123      	str	r3, [r4, #16]
        if(status != HAL_OK) 
 8001e30:	2800      	cmp	r0, #0
 8001e32:	d13f      	bne.n	8001eb4 <HAL_FLASHEx_Erase+0x118>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8001e34:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8001e38:	3501      	adds	r5, #1
 8001e3a:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8001e3e:	4413      	add	r3, r2
 8001e40:	42ab      	cmp	r3, r5
 8001e42:	d92e      	bls.n	8001ea2 <HAL_FLASHEx_Erase+0x106>
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8001e44:	f899 3010 	ldrb.w	r3, [r9, #16]
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8001e48:	2b00      	cmp	r3, #0
 8001e4a:	d0ce      	beq.n	8001dea <HAL_FLASHEx_Erase+0x4e>
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 8001e4c:	2b01      	cmp	r3, #1
 8001e4e:	d1c6      	bne.n	8001dde <HAL_FLASHEx_Erase+0x42>
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8001e50:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001e54:	e7c9      	b.n	8001dea <HAL_FLASHEx_Erase+0x4e>
  FLASH->CR &= CR_PSIZE_MASK;
 8001e56:	4a1d      	ldr	r2, [pc, #116]	; (8001ecc <HAL_FLASHEx_Erase+0x130>)
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8001e58:	f8d9 0004 	ldr.w	r0, [r9, #4]
  FLASH->CR &= CR_PSIZE_MASK;
 8001e5c:	6911      	ldr	r1, [r2, #16]
  if(Banks == FLASH_BANK_BOTH)
 8001e5e:	2803      	cmp	r0, #3
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8001e60:	f8d9 3010 	ldr.w	r3, [r9, #16]
  FLASH->CR &= CR_PSIZE_MASK;
 8001e64:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8001e68:	6111      	str	r1, [r2, #16]
  if(Banks == FLASH_BANK_BOTH)
 8001e6a:	d027      	beq.n	8001ebc <HAL_FLASHEx_Erase+0x120>
    FLASH->CR |= FLASH_CR_MER2;
 8001e6c:	6911      	ldr	r1, [r2, #16]
  else if(Banks == FLASH_BANK_2)
 8001e6e:	2802      	cmp	r0, #2
    FLASH->CR |= FLASH_CR_MER2;
 8001e70:	bf0c      	ite	eq
 8001e72:	f441 4100 	orreq.w	r1, r1, #32768	; 0x8000
    FLASH->CR |= FLASH_CR_MER1;    
 8001e76:	f041 0104 	orrne.w	r1, r1, #4
 8001e7a:	6111      	str	r1, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8);
 8001e7c:	4c13      	ldr	r4, [pc, #76]	; (8001ecc <HAL_FLASHEx_Erase+0x130>)
 8001e7e:	021b      	lsls	r3, r3, #8
 8001e80:	6922      	ldr	r2, [r4, #16]
 8001e82:	b29b      	uxth	r3, r3
 8001e84:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001e88:	4313      	orrs	r3, r2
 8001e8a:	6123      	str	r3, [r4, #16]
 8001e8c:	f3bf 8f4f 	dsb	sy
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e90:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001e94:	f7ff ff2a 	bl	8001cec <FLASH_WaitForLastOperation>
      FLASH->CR &= (~FLASH_MER_BIT);
 8001e98:	6922      	ldr	r2, [r4, #16]
 8001e9a:	4b0d      	ldr	r3, [pc, #52]	; (8001ed0 <HAL_FLASHEx_Erase+0x134>)
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e9c:	4607      	mov	r7, r0
      FLASH->CR &= (~FLASH_MER_BIT);
 8001e9e:	4013      	ands	r3, r2
 8001ea0:	6123      	str	r3, [r4, #16]
  __HAL_UNLOCK(&pFlash);
 8001ea2:	2300      	movs	r3, #0
}
 8001ea4:	4638      	mov	r0, r7
  __HAL_UNLOCK(&pFlash);
 8001ea6:	7533      	strb	r3, [r6, #20]
}
 8001ea8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  __HAL_LOCK(&pFlash);
 8001eac:	2702      	movs	r7, #2
}
 8001eae:	4638      	mov	r0, r7
 8001eb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          *SectorError = index;
 8001eb4:	f8c8 5000 	str.w	r5, [r8]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001eb8:	4607      	mov	r7, r0
          break;
 8001eba:	e7f2      	b.n	8001ea2 <HAL_FLASHEx_Erase+0x106>
    FLASH->CR |= FLASH_MER_BIT;
 8001ebc:	6910      	ldr	r0, [r2, #16]
 8001ebe:	f248 0104 	movw	r1, #32772	; 0x8004
 8001ec2:	4301      	orrs	r1, r0
 8001ec4:	6111      	str	r1, [r2, #16]
 8001ec6:	e7d9      	b.n	8001e7c <HAL_FLASHEx_Erase+0xe0>
 8001ec8:	20002100 	.word	0x20002100
 8001ecc:	40023c00 	.word	0x40023c00
 8001ed0:	ffff7ffb 	.word	0xffff7ffb

08001ed4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001ed4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001ed8:	f8df c22c 	ldr.w	ip, [pc, #556]	; 8002108 <HAL_GPIO_Init+0x234>
{
 8001edc:	b083      	sub	sp, #12
 8001ede:	468e      	mov	lr, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 8001ee0:	2500      	movs	r5, #0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001ee2:	f8df 9228 	ldr.w	r9, [pc, #552]	; 800210c <HAL_GPIO_Init+0x238>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001ee6:	f8d1 8000 	ldr.w	r8, [r1]
 8001eea:	e003      	b.n	8001ef4 <HAL_GPIO_Init+0x20>
  for(position = 0; position < GPIO_NUMBER; position++)
 8001eec:	3501      	adds	r5, #1
 8001eee:	2d10      	cmp	r5, #16
 8001ef0:	f000 80b6 	beq.w	8002060 <HAL_GPIO_Init+0x18c>
    ioposition = ((uint32_t)0x01) << position;
 8001ef4:	2301      	movs	r3, #1
 8001ef6:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001ef8:	ea08 0103 	and.w	r1, r8, r3
    if(iocurrent == ioposition)
 8001efc:	428b      	cmp	r3, r1
 8001efe:	d1f5      	bne.n	8001eec <HAL_GPIO_Init+0x18>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f00:	f8de 4004 	ldr.w	r4, [lr, #4]
 8001f04:	f024 0710 	bic.w	r7, r4, #16
 8001f08:	2f02      	cmp	r7, #2
 8001f0a:	f040 80ac 	bne.w	8002066 <HAL_GPIO_Init+0x192>
        temp = GPIOx->AFR[position >> 3];
 8001f0e:	08ef      	lsrs	r7, r5, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f10:	f005 0a07 	and.w	sl, r5, #7
 8001f14:	f04f 0b0f 	mov.w	fp, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f18:	f8de 2010 	ldr.w	r2, [lr, #16]
 8001f1c:	eb00 0787 	add.w	r7, r0, r7, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f20:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3];
 8001f24:	6a3e      	ldr	r6, [r7, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f26:	fa0b fb0a 	lsl.w	fp, fp, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f2a:	fa02 f20a 	lsl.w	r2, r2, sl
 8001f2e:	ea4f 0a45 	mov.w	sl, r5, lsl #1
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f32:	ea26 060b 	bic.w	r6, r6, fp
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f36:	f04f 0b03 	mov.w	fp, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f3a:	4332      	orrs	r2, r6
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f3c:	fa0b fb0a 	lsl.w	fp, fp, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f40:	f004 0603 	and.w	r6, r4, #3
        GPIOx->AFR[position >> 3] = temp;
 8001f44:	623a      	str	r2, [r7, #32]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f46:	ea6f 020b 	mvn.w	r2, fp
      temp = GPIOx->MODER;
 8001f4a:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f4c:	fa06 f60a 	lsl.w	r6, r6, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001f50:	4017      	ands	r7, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f52:	433e      	orrs	r6, r7
      GPIOx->MODER = temp;
 8001f54:	6006      	str	r6, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 8001f56:	6886      	ldr	r6, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f58:	f3c4 1700 	ubfx	r7, r4, #4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001f5c:	ea06 0b02 	and.w	fp, r6, r2
        temp |= (GPIO_Init->Speed << (position * 2));
 8001f60:	f8de 600c 	ldr.w	r6, [lr, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f64:	40af      	lsls	r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 8001f66:	fa06 f60a 	lsl.w	r6, r6, sl
 8001f6a:	ea46 060b 	orr.w	r6, r6, fp
        GPIOx->OSPEEDR = temp;
 8001f6e:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 8001f70:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001f72:	ea26 0303 	bic.w	r3, r6, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f76:	431f      	orrs	r7, r3
        GPIOx->OTYPER = temp;
 8001f78:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8001f7a:	68c6      	ldr	r6, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001f7c:	00e7      	lsls	r7, r4, #3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001f7e:	f8de 3008 	ldr.w	r3, [lr, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001f82:	ea02 0206 	and.w	r2, r2, r6
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001f86:	fa03 f30a 	lsl.w	r3, r3, sl
 8001f8a:	ea43 0302 	orr.w	r3, r3, r2
      GPIOx->PUPDR = temp;
 8001f8e:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001f90:	d5ac      	bpl.n	8001eec <HAL_GPIO_Init+0x18>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f92:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
 8001f96:	f025 0703 	bic.w	r7, r5, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001f9a:	f005 0303 	and.w	r3, r5, #3
 8001f9e:	220f      	movs	r2, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fa0:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8001fa4:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fa8:	009b      	lsls	r3, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001faa:	f8c9 6044 	str.w	r6, [r9, #68]	; 0x44
 8001fae:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 8001fb2:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fb6:	fa02 fa03 	lsl.w	sl, r2, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fba:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8001fbe:	9601      	str	r6, [sp, #4]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001fc0:	4e48      	ldr	r6, [pc, #288]	; (80020e4 <HAL_GPIO_Init+0x210>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fc2:	9a01      	ldr	r2, [sp, #4]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001fc4:	42b0      	cmp	r0, r6
        temp = SYSCFG->EXTICR[position >> 2];
 8001fc6:	68ba      	ldr	r2, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fc8:	ea22 020a 	bic.w	r2, r2, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001fcc:	d020      	beq.n	8002010 <HAL_GPIO_Init+0x13c>
 8001fce:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001fd2:	42b0      	cmp	r0, r6
 8001fd4:	d05e      	beq.n	8002094 <HAL_GPIO_Init+0x1c0>
 8001fd6:	4e44      	ldr	r6, [pc, #272]	; (80020e8 <HAL_GPIO_Init+0x214>)
 8001fd8:	42b0      	cmp	r0, r6
 8001fda:	d060      	beq.n	800209e <HAL_GPIO_Init+0x1ca>
 8001fdc:	4e43      	ldr	r6, [pc, #268]	; (80020ec <HAL_GPIO_Init+0x218>)
 8001fde:	42b0      	cmp	r0, r6
 8001fe0:	d062      	beq.n	80020a8 <HAL_GPIO_Init+0x1d4>
 8001fe2:	4e43      	ldr	r6, [pc, #268]	; (80020f0 <HAL_GPIO_Init+0x21c>)
 8001fe4:	42b0      	cmp	r0, r6
 8001fe6:	d064      	beq.n	80020b2 <HAL_GPIO_Init+0x1de>
 8001fe8:	4e42      	ldr	r6, [pc, #264]	; (80020f4 <HAL_GPIO_Init+0x220>)
 8001fea:	42b0      	cmp	r0, r6
 8001fec:	d06b      	beq.n	80020c6 <HAL_GPIO_Init+0x1f2>
 8001fee:	4e42      	ldr	r6, [pc, #264]	; (80020f8 <HAL_GPIO_Init+0x224>)
 8001ff0:	42b0      	cmp	r0, r6
 8001ff2:	d06d      	beq.n	80020d0 <HAL_GPIO_Init+0x1fc>
 8001ff4:	4e41      	ldr	r6, [pc, #260]	; (80020fc <HAL_GPIO_Init+0x228>)
 8001ff6:	42b0      	cmp	r0, r6
 8001ff8:	d060      	beq.n	80020bc <HAL_GPIO_Init+0x1e8>
 8001ffa:	4e41      	ldr	r6, [pc, #260]	; (8002100 <HAL_GPIO_Init+0x22c>)
 8001ffc:	42b0      	cmp	r0, r6
 8001ffe:	d06c      	beq.n	80020da <HAL_GPIO_Init+0x206>
 8002000:	4e40      	ldr	r6, [pc, #256]	; (8002104 <HAL_GPIO_Init+0x230>)
 8002002:	42b0      	cmp	r0, r6
 8002004:	bf0c      	ite	eq
 8002006:	2609      	moveq	r6, #9
 8002008:	260a      	movne	r6, #10
 800200a:	fa06 f303 	lsl.w	r3, r6, r3
 800200e:	431a      	orrs	r2, r3
        SYSCFG->EXTICR[position >> 2] = temp;
 8002010:	60ba      	str	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002012:	03e6      	lsls	r6, r4, #15
        temp = EXTI->IMR;
 8002014:	f8dc 3000 	ldr.w	r3, [ip]
        temp &= ~((uint32_t)iocurrent);
 8002018:	ea6f 0201 	mvn.w	r2, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 800201c:	f105 0501 	add.w	r5, r5, #1
        temp &= ~((uint32_t)iocurrent);
 8002020:	bf54      	ite	pl
 8002022:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8002024:	430b      	orrmi	r3, r1
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002026:	03a7      	lsls	r7, r4, #14
        EXTI->IMR = temp;
 8002028:	f8cc 3000 	str.w	r3, [ip]
        temp = EXTI->EMR;
 800202c:	f8dc 3004 	ldr.w	r3, [ip, #4]
        temp &= ~((uint32_t)iocurrent);
 8002030:	bf54      	ite	pl
 8002032:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8002034:	430b      	orrmi	r3, r1
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002036:	02e6      	lsls	r6, r4, #11
        EXTI->EMR = temp;
 8002038:	f8cc 3004 	str.w	r3, [ip, #4]
        temp = EXTI->RTSR;
 800203c:	f8dc 3008 	ldr.w	r3, [ip, #8]
        temp &= ~((uint32_t)iocurrent);
 8002040:	bf54      	ite	pl
 8002042:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8002044:	430b      	orrmi	r3, r1
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002046:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
 8002048:	f8cc 3008 	str.w	r3, [ip, #8]
        temp = EXTI->FTSR;
 800204c:	f8dc 300c 	ldr.w	r3, [ip, #12]
        temp &= ~((uint32_t)iocurrent);
 8002050:	bf54      	ite	pl
 8002052:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8002054:	430b      	orrmi	r3, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 8002056:	2d10      	cmp	r5, #16
        }
        EXTI->FTSR = temp;
 8002058:	f8cc 300c 	str.w	r3, [ip, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 800205c:	f47f af4a 	bne.w	8001ef4 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 8002060:	b003      	add	sp, #12
 8002062:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002066:	ea4f 0a45 	mov.w	sl, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800206a:	2203      	movs	r2, #3
      temp = GPIOx->MODER;
 800206c:	f8d0 b000 	ldr.w	fp, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002070:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8002072:	ea04 0602 	and.w	r6, r4, r2
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8002076:	fa02 f20a 	lsl.w	r2, r2, sl
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800207a:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800207c:	ea6f 0202 	mvn.w	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8002080:	fa06 f60a 	lsl.w	r6, r6, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8002084:	ea02 0b0b 	and.w	fp, r2, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8002088:	ea46 060b 	orr.w	r6, r6, fp
      GPIOx->MODER = temp;
 800208c:	6006      	str	r6, [r0, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800208e:	f63f af74 	bhi.w	8001f7a <HAL_GPIO_Init+0xa6>
 8002092:	e760      	b.n	8001f56 <HAL_GPIO_Init+0x82>
 8002094:	2601      	movs	r6, #1
 8002096:	fa06 f303 	lsl.w	r3, r6, r3
 800209a:	431a      	orrs	r2, r3
 800209c:	e7b8      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 800209e:	2602      	movs	r6, #2
 80020a0:	fa06 f303 	lsl.w	r3, r6, r3
 80020a4:	431a      	orrs	r2, r3
 80020a6:	e7b3      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020a8:	2603      	movs	r6, #3
 80020aa:	fa06 f303 	lsl.w	r3, r6, r3
 80020ae:	431a      	orrs	r2, r3
 80020b0:	e7ae      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020b2:	2604      	movs	r6, #4
 80020b4:	fa06 f303 	lsl.w	r3, r6, r3
 80020b8:	431a      	orrs	r2, r3
 80020ba:	e7a9      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020bc:	2607      	movs	r6, #7
 80020be:	fa06 f303 	lsl.w	r3, r6, r3
 80020c2:	431a      	orrs	r2, r3
 80020c4:	e7a4      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020c6:	2605      	movs	r6, #5
 80020c8:	fa06 f303 	lsl.w	r3, r6, r3
 80020cc:	431a      	orrs	r2, r3
 80020ce:	e79f      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020d0:	2606      	movs	r6, #6
 80020d2:	fa06 f303 	lsl.w	r3, r6, r3
 80020d6:	431a      	orrs	r2, r3
 80020d8:	e79a      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020da:	2608      	movs	r6, #8
 80020dc:	fa06 f303 	lsl.w	r3, r6, r3
 80020e0:	431a      	orrs	r2, r3
 80020e2:	e795      	b.n	8002010 <HAL_GPIO_Init+0x13c>
 80020e4:	40020000 	.word	0x40020000
 80020e8:	40020800 	.word	0x40020800
 80020ec:	40020c00 	.word	0x40020c00
 80020f0:	40021000 	.word	0x40021000
 80020f4:	40021400 	.word	0x40021400
 80020f8:	40021800 	.word	0x40021800
 80020fc:	40021c00 	.word	0x40021c00
 8002100:	40022000 	.word	0x40022000
 8002104:	40022400 	.word	0x40022400
 8002108:	40013c00 	.word	0x40013c00
 800210c:	40023800 	.word	0x40023800

08002110 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8002110:	6903      	ldr	r3, [r0, #16]
 8002112:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8002114:	bf14      	ite	ne
 8002116:	2001      	movne	r0, #1
 8002118:	2000      	moveq	r0, #0
 800211a:	4770      	bx	lr

0800211c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800211c:	b902      	cbnz	r2, 8002120 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800211e:	0409      	lsls	r1, r1, #16
 8002120:	6181      	str	r1, [r0, #24]
  }
}
 8002122:	4770      	bx	lr

08002124 <HAL_IWDG_Init>:
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if (hiwdg == NULL)
 8002124:	b1f8      	cbz	r0, 8002166 <HAL_IWDG_Init+0x42>
{
 8002126:	b538      	push	{r3, r4, r5, lr}
 8002128:	4604      	mov	r4, r0
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));
  assert_param(IS_IWDG_WINDOW(hiwdg->Init.Window));

  /* Enable IWDG. LSI is turned on automatically */
  __HAL_IWDG_START(hiwdg);
 800212a:	6803      	ldr	r3, [r0, #0]
 800212c:	f64c 45cc 	movw	r5, #52428	; 0xcccc

  /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 8002130:	f245 5055 	movw	r0, #21845	; 0x5555

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 8002134:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
  __HAL_IWDG_START(hiwdg);
 8002138:	601d      	str	r5, [r3, #0]
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 800213a:	6018      	str	r0, [r3, #0]
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
 800213c:	6059      	str	r1, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 800213e:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
 8002140:	f7fe fa36 	bl	80005b0 <HAL_GetTick>
 8002144:	4605      	mov	r5, r0

  /* Wait for register to be updated */
  while (hiwdg->Instance->SR != 0x00u)
 8002146:	e004      	b.n	8002152 <HAL_IWDG_Init+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > HAL_IWDG_DEFAULT_TIMEOUT)
 8002148:	f7fe fa32 	bl	80005b0 <HAL_GetTick>
 800214c:	1b40      	subs	r0, r0, r5
 800214e:	2830      	cmp	r0, #48	; 0x30
 8002150:	d80b      	bhi.n	800216a <HAL_IWDG_Init+0x46>
  while (hiwdg->Instance->SR != 0x00u)
 8002152:	6823      	ldr	r3, [r4, #0]
 8002154:	68d8      	ldr	r0, [r3, #12]
 8002156:	2800      	cmp	r0, #0
 8002158:	d1f6      	bne.n	8002148 <HAL_IWDG_Init+0x24>
    }
  }

  /* If window parameter is different than current value, modify window
  register */
  if (hiwdg->Instance->WINR != hiwdg->Init.Window)
 800215a:	68e2      	ldr	r2, [r4, #12]
 800215c:	6919      	ldr	r1, [r3, #16]
 800215e:	4291      	cmp	r1, r2
 8002160:	d005      	beq.n	800216e <HAL_IWDG_Init+0x4a>
  {
    /* Write to IWDG WINR the IWDG_Window value to compare with. In any case,
    even if window feature is disabled, Watchdog will be reloaded by writing
    windows register */
    hiwdg->Instance->WINR = hiwdg->Init.Window;
 8002162:	611a      	str	r2, [r3, #16]
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
  }

  /* Return function status */
  return HAL_OK;
}
 8002164:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002166:	2001      	movs	r0, #1
}
 8002168:	4770      	bx	lr
      return HAL_TIMEOUT;
 800216a:	2003      	movs	r0, #3
}
 800216c:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 800216e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8002172:	601a      	str	r2, [r3, #0]
}
 8002174:	bd38      	pop	{r3, r4, r5, pc}
 8002176:	bf00      	nop

08002178 <HAL_IWDG_Refresh>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8002178:	6803      	ldr	r3, [r0, #0]
 800217a:	f64a 22aa 	movw	r2, #43690	; 0xaaaa

  /* Return function status */
  return HAL_OK;
}
 800217e:	2000      	movs	r0, #0
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8002180:	601a      	str	r2, [r3, #0]
}
 8002182:	4770      	bx	lr

08002184 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8002184:	4a1b      	ldr	r2, [pc, #108]	; (80021f4 <HAL_PWREx_EnableOverDrive+0x70>)
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8002186:	4b1c      	ldr	r3, [pc, #112]	; (80021f8 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8002188:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800218a:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
{
 800218e:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8002190:	6411      	str	r1, [r2, #64]	; 0x40
{
 8002192:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 8002194:	6c12      	ldr	r2, [r2, #64]	; 0x40

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8002196:	461c      	mov	r4, r3
  __HAL_RCC_PWR_CLK_ENABLE();
 8002198:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 800219c:	9201      	str	r2, [sp, #4]
 800219e:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 80021a0:	681a      	ldr	r2, [r3, #0]
 80021a2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80021a6:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 80021a8:	f7fe fa02 	bl	80005b0 <HAL_GetTick>
 80021ac:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80021ae:	e005      	b.n	80021bc <HAL_PWREx_EnableOverDrive+0x38>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80021b0:	f7fe f9fe 	bl	80005b0 <HAL_GetTick>
 80021b4:	1b40      	subs	r0, r0, r5
 80021b6:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80021ba:	d817      	bhi.n	80021ec <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80021bc:	6863      	ldr	r3, [r4, #4]
 80021be:	03da      	lsls	r2, r3, #15
 80021c0:	d5f6      	bpl.n	80021b0 <HAL_PWREx_EnableOverDrive+0x2c>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80021c2:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80021c4:	4d0c      	ldr	r5, [pc, #48]	; (80021f8 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80021c6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80021ca:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 80021cc:	f7fe f9f0 	bl	80005b0 <HAL_GetTick>
 80021d0:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80021d2:	e005      	b.n	80021e0 <HAL_PWREx_EnableOverDrive+0x5c>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80021d4:	f7fe f9ec 	bl	80005b0 <HAL_GetTick>
 80021d8:	1b00      	subs	r0, r0, r4
 80021da:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80021de:	d805      	bhi.n	80021ec <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80021e0:	686b      	ldr	r3, [r5, #4]
 80021e2:	039b      	lsls	r3, r3, #14
 80021e4:	d5f6      	bpl.n	80021d4 <HAL_PWREx_EnableOverDrive+0x50>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 80021e6:	2000      	movs	r0, #0
}
 80021e8:	b003      	add	sp, #12
 80021ea:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 80021ec:	2003      	movs	r0, #3
}
 80021ee:	b003      	add	sp, #12
 80021f0:	bd30      	pop	{r4, r5, pc}
 80021f2:	bf00      	nop
 80021f4:	40023800 	.word	0x40023800
 80021f8:	40007000 	.word	0x40007000

080021fc <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80021fc:	2800      	cmp	r0, #0
 80021fe:	f000 8134 	beq.w	800246a <HAL_RCC_OscConfig+0x26e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002202:	6803      	ldr	r3, [r0, #0]
{
 8002204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002208:	07dd      	lsls	r5, r3, #31
{
 800220a:	b082      	sub	sp, #8
 800220c:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800220e:	d535      	bpl.n	800227c <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002210:	49ab      	ldr	r1, [pc, #684]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002212:	688a      	ldr	r2, [r1, #8]
 8002214:	f002 020c 	and.w	r2, r2, #12
 8002218:	2a04      	cmp	r2, #4
 800221a:	f000 80fe 	beq.w	800241a <HAL_RCC_OscConfig+0x21e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800221e:	688a      	ldr	r2, [r1, #8]
 8002220:	f002 020c 	and.w	r2, r2, #12
 8002224:	2a08      	cmp	r2, #8
 8002226:	f000 80f4 	beq.w	8002412 <HAL_RCC_OscConfig+0x216>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800222a:	6863      	ldr	r3, [r4, #4]
 800222c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002230:	d010      	beq.n	8002254 <HAL_RCC_OscConfig+0x58>
 8002232:	2b00      	cmp	r3, #0
 8002234:	f000 811b 	beq.w	800246e <HAL_RCC_OscConfig+0x272>
 8002238:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800223c:	4ba0      	ldr	r3, [pc, #640]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 800223e:	681a      	ldr	r2, [r3, #0]
 8002240:	f000 8162 	beq.w	8002508 <HAL_RCC_OscConfig+0x30c>
 8002244:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002248:	601a      	str	r2, [r3, #0]
 800224a:	681a      	ldr	r2, [r3, #0]
 800224c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002250:	601a      	str	r2, [r3, #0]
 8002252:	e004      	b.n	800225e <HAL_RCC_OscConfig+0x62>
 8002254:	4a9a      	ldr	r2, [pc, #616]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002256:	6813      	ldr	r3, [r2, #0]
 8002258:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800225c:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800225e:	f7fe f9a7 	bl	80005b0 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002262:	4d97      	ldr	r5, [pc, #604]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
        tickstart = HAL_GetTick();
 8002264:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002266:	e005      	b.n	8002274 <HAL_RCC_OscConfig+0x78>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002268:	f7fe f9a2 	bl	80005b0 <HAL_GetTick>
 800226c:	1b80      	subs	r0, r0, r6
 800226e:	2864      	cmp	r0, #100	; 0x64
 8002270:	f200 80ee 	bhi.w	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002274:	682b      	ldr	r3, [r5, #0]
 8002276:	039a      	lsls	r2, r3, #14
 8002278:	d5f6      	bpl.n	8002268 <HAL_RCC_OscConfig+0x6c>
 800227a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800227c:	079f      	lsls	r7, r3, #30
 800227e:	d442      	bmi.n	8002306 <HAL_RCC_OscConfig+0x10a>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002280:	071a      	lsls	r2, r3, #28
 8002282:	d517      	bpl.n	80022b4 <HAL_RCC_OscConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8002284:	6963      	ldr	r3, [r4, #20]
 8002286:	2b00      	cmp	r3, #0
 8002288:	f000 80b0 	beq.w	80023ec <HAL_RCC_OscConfig+0x1f0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800228c:	4b8c      	ldr	r3, [pc, #560]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 800228e:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002290:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 8002292:	f042 0201 	orr.w	r2, r2, #1
 8002296:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8002298:	f7fe f98a 	bl	80005b0 <HAL_GetTick>
 800229c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800229e:	e005      	b.n	80022ac <HAL_RCC_OscConfig+0xb0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80022a0:	f7fe f986 	bl	80005b0 <HAL_GetTick>
 80022a4:	1b80      	subs	r0, r0, r6
 80022a6:	2802      	cmp	r0, #2
 80022a8:	f200 80d2 	bhi.w	8002450 <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022ac:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80022ae:	079b      	lsls	r3, r3, #30
 80022b0:	d5f6      	bpl.n	80022a0 <HAL_RCC_OscConfig+0xa4>
 80022b2:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80022b4:	075d      	lsls	r5, r3, #29
 80022b6:	d56b      	bpl.n	8002390 <HAL_RCC_OscConfig+0x194>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80022b8:	4b81      	ldr	r3, [pc, #516]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 80022ba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80022bc:	00d0      	lsls	r0, r2, #3
 80022be:	f100 80ed 	bmi.w	800249c <HAL_RCC_OscConfig+0x2a0>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80022c2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 80022c4:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80022c6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80022ca:	641a      	str	r2, [r3, #64]	; 0x40
 80022cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80022ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80022d2:	9301      	str	r3, [sp, #4]
 80022d4:	9b01      	ldr	r3, [sp, #4]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80022d6:	4b7b      	ldr	r3, [pc, #492]	; (80024c4 <HAL_RCC_OscConfig+0x2c8>)
 80022d8:	681a      	ldr	r2, [r3, #0]
 80022da:	05d1      	lsls	r1, r2, #23
 80022dc:	f140 80a7 	bpl.w	800242e <HAL_RCC_OscConfig+0x232>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80022e0:	68a3      	ldr	r3, [r4, #8]
 80022e2:	2b01      	cmp	r3, #1
 80022e4:	d039      	beq.n	800235a <HAL_RCC_OscConfig+0x15e>
 80022e6:	2b00      	cmp	r3, #0
 80022e8:	f000 80da 	beq.w	80024a0 <HAL_RCC_OscConfig+0x2a4>
 80022ec:	2b05      	cmp	r3, #5
 80022ee:	4b74      	ldr	r3, [pc, #464]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 80022f0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80022f2:	f000 8111 	beq.w	8002518 <HAL_RCC_OscConfig+0x31c>
 80022f6:	f022 0201 	bic.w	r2, r2, #1
 80022fa:	671a      	str	r2, [r3, #112]	; 0x70
 80022fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80022fe:	f022 0204 	bic.w	r2, r2, #4
 8002302:	671a      	str	r2, [r3, #112]	; 0x70
 8002304:	e02e      	b.n	8002364 <HAL_RCC_OscConfig+0x168>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8002306:	4a6e      	ldr	r2, [pc, #440]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002308:	6891      	ldr	r1, [r2, #8]
 800230a:	f011 0f0c 	tst.w	r1, #12
 800230e:	d062      	beq.n	80023d6 <HAL_RCC_OscConfig+0x1da>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002310:	6891      	ldr	r1, [r2, #8]
 8002312:	f001 010c 	and.w	r1, r1, #12
 8002316:	2908      	cmp	r1, #8
 8002318:	d05a      	beq.n	80023d0 <HAL_RCC_OscConfig+0x1d4>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800231a:	68e3      	ldr	r3, [r4, #12]
 800231c:	2b00      	cmp	r3, #0
 800231e:	f000 80df 	beq.w	80024e0 <HAL_RCC_OscConfig+0x2e4>
        __HAL_RCC_HSI_ENABLE();
 8002322:	4b67      	ldr	r3, [pc, #412]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002324:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002326:	461d      	mov	r5, r3
        __HAL_RCC_HSI_ENABLE();
 8002328:	f042 0201 	orr.w	r2, r2, #1
 800232c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800232e:	f7fe f93f 	bl	80005b0 <HAL_GetTick>
 8002332:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002334:	e005      	b.n	8002342 <HAL_RCC_OscConfig+0x146>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002336:	f7fe f93b 	bl	80005b0 <HAL_GetTick>
 800233a:	1b80      	subs	r0, r0, r6
 800233c:	2802      	cmp	r0, #2
 800233e:	f200 8087 	bhi.w	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002342:	682b      	ldr	r3, [r5, #0]
 8002344:	0798      	lsls	r0, r3, #30
 8002346:	d5f6      	bpl.n	8002336 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002348:	682b      	ldr	r3, [r5, #0]
 800234a:	6922      	ldr	r2, [r4, #16]
 800234c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002350:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002354:	602b      	str	r3, [r5, #0]
 8002356:	6823      	ldr	r3, [r4, #0]
 8002358:	e792      	b.n	8002280 <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800235a:	4a59      	ldr	r2, [pc, #356]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 800235c:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800235e:	f043 0301 	orr.w	r3, r3, #1
 8002362:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002364:	f7fe f924 	bl	80005b0 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002368:	4e55      	ldr	r6, [pc, #340]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
      tickstart = HAL_GetTick();
 800236a:	4680      	mov	r8, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800236c:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002370:	e005      	b.n	800237e <HAL_RCC_OscConfig+0x182>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002372:	f7fe f91d 	bl	80005b0 <HAL_GetTick>
 8002376:	eba0 0008 	sub.w	r0, r0, r8
 800237a:	42b8      	cmp	r0, r7
 800237c:	d868      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800237e:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8002380:	079b      	lsls	r3, r3, #30
 8002382:	d5f6      	bpl.n	8002372 <HAL_RCC_OscConfig+0x176>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8002384:	b125      	cbz	r5, 8002390 <HAL_RCC_OscConfig+0x194>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8002386:	4a4e      	ldr	r2, [pc, #312]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002388:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800238a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800238e:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002390:	69a3      	ldr	r3, [r4, #24]
 8002392:	b1cb      	cbz	r3, 80023c8 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002394:	4a4a      	ldr	r2, [pc, #296]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002396:	6891      	ldr	r1, [r2, #8]
 8002398:	f001 010c 	and.w	r1, r1, #12
 800239c:	2908      	cmp	r1, #8
 800239e:	d021      	beq.n	80023e4 <HAL_RCC_OscConfig+0x1e8>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80023a0:	2b02      	cmp	r3, #2
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80023a2:	6813      	ldr	r3, [r2, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80023a4:	f000 80c0 	beq.w	8002528 <HAL_RCC_OscConfig+0x32c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80023a8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80023ac:	4614      	mov	r4, r2
        __HAL_RCC_PLL_DISABLE();
 80023ae:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80023b0:	f7fe f8fe 	bl	80005b0 <HAL_GetTick>
 80023b4:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80023b6:	e004      	b.n	80023c2 <HAL_RCC_OscConfig+0x1c6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80023b8:	f7fe f8fa 	bl	80005b0 <HAL_GetTick>
 80023bc:	1b40      	subs	r0, r0, r5
 80023be:	2802      	cmp	r0, #2
 80023c0:	d846      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80023c2:	6823      	ldr	r3, [r4, #0]
 80023c4:	019b      	lsls	r3, r3, #6
 80023c6:	d4f7      	bmi.n	80023b8 <HAL_RCC_OscConfig+0x1bc>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80023c8:	2000      	movs	r0, #0
}
 80023ca:	b002      	add	sp, #8
 80023cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80023d0:	6852      	ldr	r2, [r2, #4]
 80023d2:	0256      	lsls	r6, r2, #9
 80023d4:	d4a1      	bmi.n	800231a <HAL_RCC_OscConfig+0x11e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80023d6:	4a3a      	ldr	r2, [pc, #232]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 80023d8:	6812      	ldr	r2, [r2, #0]
 80023da:	0795      	lsls	r5, r2, #30
 80023dc:	d53c      	bpl.n	8002458 <HAL_RCC_OscConfig+0x25c>
 80023de:	68e2      	ldr	r2, [r4, #12]
 80023e0:	2a01      	cmp	r2, #1
 80023e2:	d039      	beq.n	8002458 <HAL_RCC_OscConfig+0x25c>
    return HAL_ERROR;
 80023e4:	2001      	movs	r0, #1
}
 80023e6:	b002      	add	sp, #8
 80023e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 80023ec:	4b34      	ldr	r3, [pc, #208]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 80023ee:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80023f0:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 80023f2:	f022 0201 	bic.w	r2, r2, #1
 80023f6:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 80023f8:	f7fe f8da 	bl	80005b0 <HAL_GetTick>
 80023fc:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80023fe:	e004      	b.n	800240a <HAL_RCC_OscConfig+0x20e>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002400:	f7fe f8d6 	bl	80005b0 <HAL_GetTick>
 8002404:	1b80      	subs	r0, r0, r6
 8002406:	2802      	cmp	r0, #2
 8002408:	d822      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800240a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800240c:	079f      	lsls	r7, r3, #30
 800240e:	d4f7      	bmi.n	8002400 <HAL_RCC_OscConfig+0x204>
 8002410:	e74f      	b.n	80022b2 <HAL_RCC_OscConfig+0xb6>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002412:	684a      	ldr	r2, [r1, #4]
 8002414:	0250      	lsls	r0, r2, #9
 8002416:	f57f af08 	bpl.w	800222a <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800241a:	4a29      	ldr	r2, [pc, #164]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 800241c:	6812      	ldr	r2, [r2, #0]
 800241e:	0391      	lsls	r1, r2, #14
 8002420:	f57f af2c 	bpl.w	800227c <HAL_RCC_OscConfig+0x80>
 8002424:	6862      	ldr	r2, [r4, #4]
 8002426:	2a00      	cmp	r2, #0
 8002428:	f47f af28 	bne.w	800227c <HAL_RCC_OscConfig+0x80>
 800242c:	e7da      	b.n	80023e4 <HAL_RCC_OscConfig+0x1e8>
      PWR->CR1 |= PWR_CR1_DBP;
 800242e:	681a      	ldr	r2, [r3, #0]
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8002430:	461e      	mov	r6, r3
      PWR->CR1 |= PWR_CR1_DBP;
 8002432:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002436:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002438:	f7fe f8ba 	bl	80005b0 <HAL_GetTick>
 800243c:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800243e:	6833      	ldr	r3, [r6, #0]
 8002440:	05da      	lsls	r2, r3, #23
 8002442:	f53f af4d 	bmi.w	80022e0 <HAL_RCC_OscConfig+0xe4>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002446:	f7fe f8b3 	bl	80005b0 <HAL_GetTick>
 800244a:	1bc0      	subs	r0, r0, r7
 800244c:	2864      	cmp	r0, #100	; 0x64
 800244e:	d9f6      	bls.n	800243e <HAL_RCC_OscConfig+0x242>
            return HAL_TIMEOUT;
 8002450:	2003      	movs	r0, #3
}
 8002452:	b002      	add	sp, #8
 8002454:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002458:	4919      	ldr	r1, [pc, #100]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 800245a:	6920      	ldr	r0, [r4, #16]
 800245c:	680a      	ldr	r2, [r1, #0]
 800245e:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8002462:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8002466:	600a      	str	r2, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002468:	e70a      	b.n	8002280 <HAL_RCC_OscConfig+0x84>
    return HAL_ERROR;
 800246a:	2001      	movs	r0, #1
}
 800246c:	4770      	bx	lr
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800246e:	4b14      	ldr	r3, [pc, #80]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
 8002470:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002472:	461d      	mov	r5, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002474:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002478:	601a      	str	r2, [r3, #0]
 800247a:	681a      	ldr	r2, [r3, #0]
 800247c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002480:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002482:	f7fe f895 	bl	80005b0 <HAL_GetTick>
 8002486:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002488:	e004      	b.n	8002494 <HAL_RCC_OscConfig+0x298>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800248a:	f7fe f891 	bl	80005b0 <HAL_GetTick>
 800248e:	1b80      	subs	r0, r0, r6
 8002490:	2864      	cmp	r0, #100	; 0x64
 8002492:	d8dd      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002494:	682b      	ldr	r3, [r5, #0]
 8002496:	039b      	lsls	r3, r3, #14
 8002498:	d4f7      	bmi.n	800248a <HAL_RCC_OscConfig+0x28e>
 800249a:	e6ee      	b.n	800227a <HAL_RCC_OscConfig+0x7e>
  FlagStatus pwrclkchanged = RESET;
 800249c:	2500      	movs	r5, #0
 800249e:	e71a      	b.n	80022d6 <HAL_RCC_OscConfig+0xda>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024a0:	4b07      	ldr	r3, [pc, #28]	; (80024c0 <HAL_RCC_OscConfig+0x2c4>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80024a2:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024a8:	461e      	mov	r6, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024aa:	f022 0201 	bic.w	r2, r2, #1
 80024ae:	671a      	str	r2, [r3, #112]	; 0x70
 80024b0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80024b2:	f022 0204 	bic.w	r2, r2, #4
 80024b6:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 80024b8:	f7fe f87a 	bl	80005b0 <HAL_GetTick>
 80024bc:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024be:	e008      	b.n	80024d2 <HAL_RCC_OscConfig+0x2d6>
 80024c0:	40023800 	.word	0x40023800
 80024c4:	40007000 	.word	0x40007000
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80024c8:	f7fe f872 	bl	80005b0 <HAL_GetTick>
 80024cc:	1bc0      	subs	r0, r0, r7
 80024ce:	4540      	cmp	r0, r8
 80024d0:	d8be      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024d2:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80024d4:	0798      	lsls	r0, r3, #30
 80024d6:	d4f7      	bmi.n	80024c8 <HAL_RCC_OscConfig+0x2cc>
    if(pwrclkchanged == SET)
 80024d8:	2d00      	cmp	r5, #0
 80024da:	f43f af59 	beq.w	8002390 <HAL_RCC_OscConfig+0x194>
 80024de:	e752      	b.n	8002386 <HAL_RCC_OscConfig+0x18a>
        __HAL_RCC_HSI_DISABLE();
 80024e0:	4b2c      	ldr	r3, [pc, #176]	; (8002594 <HAL_RCC_OscConfig+0x398>)
 80024e2:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80024e4:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 80024e6:	f022 0201 	bic.w	r2, r2, #1
 80024ea:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80024ec:	f7fe f860 	bl	80005b0 <HAL_GetTick>
 80024f0:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80024f2:	e004      	b.n	80024fe <HAL_RCC_OscConfig+0x302>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80024f4:	f7fe f85c 	bl	80005b0 <HAL_GetTick>
 80024f8:	1b80      	subs	r0, r0, r6
 80024fa:	2802      	cmp	r0, #2
 80024fc:	d8a8      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80024fe:	682b      	ldr	r3, [r5, #0]
 8002500:	0799      	lsls	r1, r3, #30
 8002502:	d4f7      	bmi.n	80024f4 <HAL_RCC_OscConfig+0x2f8>
 8002504:	6823      	ldr	r3, [r4, #0]
 8002506:	e6bb      	b.n	8002280 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002508:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800250c:	601a      	str	r2, [r3, #0]
 800250e:	681a      	ldr	r2, [r3, #0]
 8002510:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002514:	601a      	str	r2, [r3, #0]
 8002516:	e6a2      	b.n	800225e <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002518:	f042 0204 	orr.w	r2, r2, #4
 800251c:	671a      	str	r2, [r3, #112]	; 0x70
 800251e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002520:	f042 0201 	orr.w	r2, r2, #1
 8002524:	671a      	str	r2, [r3, #112]	; 0x70
 8002526:	e71d      	b.n	8002364 <HAL_RCC_OscConfig+0x168>
        __HAL_RCC_PLL_DISABLE();
 8002528:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800252c:	4615      	mov	r5, r2
        __HAL_RCC_PLL_DISABLE();
 800252e:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002530:	f7fe f83e 	bl	80005b0 <HAL_GetTick>
 8002534:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002536:	e004      	b.n	8002542 <HAL_RCC_OscConfig+0x346>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002538:	f7fe f83a 	bl	80005b0 <HAL_GetTick>
 800253c:	1b80      	subs	r0, r0, r6
 800253e:	2802      	cmp	r0, #2
 8002540:	d886      	bhi.n	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002542:	682b      	ldr	r3, [r5, #0]
 8002544:	0199      	lsls	r1, r3, #6
 8002546:	d4f7      	bmi.n	8002538 <HAL_RCC_OscConfig+0x33c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002548:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 800254c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800254e:	4313      	orrs	r3, r2
 8002550:	e9d4 200a 	ldrd	r2, r0, [r4, #40]	; 0x28
 8002554:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8002558:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800255a:	0852      	lsrs	r2, r2, #1
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800255c:	4c0d      	ldr	r4, [pc, #52]	; (8002594 <HAL_RCC_OscConfig+0x398>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800255e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8002562:	3a01      	subs	r2, #1
 8002564:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8002568:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800256c:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 800256e:	682b      	ldr	r3, [r5, #0]
 8002570:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002574:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8002576:	f7fe f81b 	bl	80005b0 <HAL_GetTick>
 800257a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800257c:	e005      	b.n	800258a <HAL_RCC_OscConfig+0x38e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800257e:	f7fe f817 	bl	80005b0 <HAL_GetTick>
 8002582:	1b40      	subs	r0, r0, r5
 8002584:	2802      	cmp	r0, #2
 8002586:	f63f af63 	bhi.w	8002450 <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800258a:	6823      	ldr	r3, [r4, #0]
 800258c:	019a      	lsls	r2, r3, #6
 800258e:	d5f6      	bpl.n	800257e <HAL_RCC_OscConfig+0x382>
 8002590:	e71a      	b.n	80023c8 <HAL_RCC_OscConfig+0x1cc>
 8002592:	bf00      	nop
 8002594:	40023800 	.word	0x40023800

08002598 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8002598:	b178      	cbz	r0, 80025ba <HAL_RCC_ClockConfig+0x22>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800259a:	4a5e      	ldr	r2, [pc, #376]	; (8002714 <HAL_RCC_ClockConfig+0x17c>)
 800259c:	6813      	ldr	r3, [r2, #0]
 800259e:	f003 030f 	and.w	r3, r3, #15
 80025a2:	428b      	cmp	r3, r1
 80025a4:	d20b      	bcs.n	80025be <HAL_RCC_ClockConfig+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80025a6:	6813      	ldr	r3, [r2, #0]
 80025a8:	f023 030f 	bic.w	r3, r3, #15
 80025ac:	430b      	orrs	r3, r1
 80025ae:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80025b0:	6813      	ldr	r3, [r2, #0]
 80025b2:	f003 030f 	and.w	r3, r3, #15
 80025b6:	428b      	cmp	r3, r1
 80025b8:	d001      	beq.n	80025be <HAL_RCC_ClockConfig+0x26>
    return HAL_ERROR;
 80025ba:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 80025bc:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80025be:	6803      	ldr	r3, [r0, #0]
{
 80025c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80025c4:	079d      	lsls	r5, r3, #30
 80025c6:	d514      	bpl.n	80025f2 <HAL_RCC_ClockConfig+0x5a>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80025c8:	075c      	lsls	r4, r3, #29
 80025ca:	d504      	bpl.n	80025d6 <HAL_RCC_ClockConfig+0x3e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80025cc:	4c52      	ldr	r4, [pc, #328]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 80025ce:	68a2      	ldr	r2, [r4, #8]
 80025d0:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 80025d4:	60a2      	str	r2, [r4, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80025d6:	071a      	lsls	r2, r3, #28
 80025d8:	d504      	bpl.n	80025e4 <HAL_RCC_ClockConfig+0x4c>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80025da:	4c4f      	ldr	r4, [pc, #316]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 80025dc:	68a2      	ldr	r2, [r4, #8]
 80025de:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 80025e2:	60a2      	str	r2, [r4, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80025e4:	4c4c      	ldr	r4, [pc, #304]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 80025e6:	6885      	ldr	r5, [r0, #8]
 80025e8:	68a2      	ldr	r2, [r4, #8]
 80025ea:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80025ee:	432a      	orrs	r2, r5
 80025f0:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80025f2:	07df      	lsls	r7, r3, #31
 80025f4:	4604      	mov	r4, r0
 80025f6:	460d      	mov	r5, r1
 80025f8:	d521      	bpl.n	800263e <HAL_RCC_ClockConfig+0xa6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80025fa:	6842      	ldr	r2, [r0, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025fc:	4b46      	ldr	r3, [pc, #280]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80025fe:	2a01      	cmp	r2, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002600:	681b      	ldr	r3, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002602:	d063      	beq.n	80026cc <HAL_RCC_ClockConfig+0x134>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002604:	2a02      	cmp	r2, #2
 8002606:	d078      	beq.n	80026fa <HAL_RCC_ClockConfig+0x162>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002608:	0799      	lsls	r1, r3, #30
 800260a:	d528      	bpl.n	800265e <HAL_RCC_ClockConfig+0xc6>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800260c:	4942      	ldr	r1, [pc, #264]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800260e:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002612:	688b      	ldr	r3, [r1, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002614:	460e      	mov	r6, r1
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002616:	f023 0303 	bic.w	r3, r3, #3
 800261a:	4313      	orrs	r3, r2
 800261c:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 800261e:	f7fd ffc7 	bl	80005b0 <HAL_GetTick>
 8002622:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002624:	e004      	b.n	8002630 <HAL_RCC_ClockConfig+0x98>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002626:	f7fd ffc3 	bl	80005b0 <HAL_GetTick>
 800262a:	1bc0      	subs	r0, r0, r7
 800262c:	4540      	cmp	r0, r8
 800262e:	d862      	bhi.n	80026f6 <HAL_RCC_ClockConfig+0x15e>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002630:	68b3      	ldr	r3, [r6, #8]
 8002632:	6862      	ldr	r2, [r4, #4]
 8002634:	f003 030c 	and.w	r3, r3, #12
 8002638:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800263c:	d1f3      	bne.n	8002626 <HAL_RCC_ClockConfig+0x8e>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800263e:	4a35      	ldr	r2, [pc, #212]	; (8002714 <HAL_RCC_ClockConfig+0x17c>)
 8002640:	6813      	ldr	r3, [r2, #0]
 8002642:	f003 030f 	and.w	r3, r3, #15
 8002646:	42ab      	cmp	r3, r5
 8002648:	d90c      	bls.n	8002664 <HAL_RCC_ClockConfig+0xcc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800264a:	6813      	ldr	r3, [r2, #0]
 800264c:	f023 030f 	bic.w	r3, r3, #15
 8002650:	432b      	orrs	r3, r5
 8002652:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8002654:	6813      	ldr	r3, [r2, #0]
 8002656:	f003 030f 	and.w	r3, r3, #15
 800265a:	42ab      	cmp	r3, r5
 800265c:	d002      	beq.n	8002664 <HAL_RCC_ClockConfig+0xcc>
    return HAL_ERROR;
 800265e:	2001      	movs	r0, #1
}
 8002660:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002664:	6823      	ldr	r3, [r4, #0]
 8002666:	075a      	lsls	r2, r3, #29
 8002668:	d506      	bpl.n	8002678 <HAL_RCC_ClockConfig+0xe0>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800266a:	492b      	ldr	r1, [pc, #172]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 800266c:	68e0      	ldr	r0, [r4, #12]
 800266e:	688a      	ldr	r2, [r1, #8]
 8002670:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8002674:	4302      	orrs	r2, r0
 8002676:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002678:	071b      	lsls	r3, r3, #28
 800267a:	d507      	bpl.n	800268c <HAL_RCC_ClockConfig+0xf4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800267c:	4a26      	ldr	r2, [pc, #152]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 800267e:	6921      	ldr	r1, [r4, #16]
 8002680:	6893      	ldr	r3, [r2, #8]
 8002682:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8002686:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800268a:	6093      	str	r3, [r2, #8]
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800268c:	4922      	ldr	r1, [pc, #136]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 800268e:	688b      	ldr	r3, [r1, #8]
 8002690:	f003 030c 	and.w	r3, r3, #12
 8002694:	2b04      	cmp	r3, #4
 8002696:	d01c      	beq.n	80026d2 <HAL_RCC_ClockConfig+0x13a>
 8002698:	2b08      	cmp	r3, #8
 800269a:	d12a      	bne.n	80026f2 <HAL_RCC_ClockConfig+0x15a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800269c:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800269e:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80026a0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80026a4:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 80026a6:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 80026aa:	d129      	bne.n	8002700 <HAL_RCC_ClockConfig+0x168>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80026ac:	481b      	ldr	r0, [pc, #108]	; (800271c <HAL_RCC_ClockConfig+0x184>)
 80026ae:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80026b2:	fba1 0100 	umull	r0, r1, r1, r0
 80026b6:	f7fd fdbf 	bl	8000238 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 80026ba:	4b17      	ldr	r3, [pc, #92]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
 80026bc:	685b      	ldr	r3, [r3, #4]
 80026be:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80026c2:	3301      	adds	r3, #1
 80026c4:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 80026c6:	fbb0 f3f3 	udiv	r3, r0, r3
 80026ca:	e003      	b.n	80026d4 <HAL_RCC_ClockConfig+0x13c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80026cc:	039e      	lsls	r6, r3, #14
 80026ce:	d49d      	bmi.n	800260c <HAL_RCC_ClockConfig+0x74>
 80026d0:	e7c5      	b.n	800265e <HAL_RCC_ClockConfig+0xc6>
      sysclockfreq = HSE_VALUE;
 80026d2:	4b13      	ldr	r3, [pc, #76]	; (8002720 <HAL_RCC_ClockConfig+0x188>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80026d4:	4a10      	ldr	r2, [pc, #64]	; (8002718 <HAL_RCC_ClockConfig+0x180>)
  HAL_InitTick (TICK_INT_PRIORITY);
 80026d6:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80026d8:	4c12      	ldr	r4, [pc, #72]	; (8002724 <HAL_RCC_ClockConfig+0x18c>)
 80026da:	6892      	ldr	r2, [r2, #8]
 80026dc:	4912      	ldr	r1, [pc, #72]	; (8002728 <HAL_RCC_ClockConfig+0x190>)
 80026de:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80026e2:	5ca2      	ldrb	r2, [r4, r2]
 80026e4:	40d3      	lsrs	r3, r2
 80026e6:	600b      	str	r3, [r1, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80026e8:	f7fd ff26 	bl	8000538 <HAL_InitTick>
  return HAL_OK;
 80026ec:	2000      	movs	r0, #0
}
 80026ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      sysclockfreq = HSI_VALUE;
 80026f2:	4b0a      	ldr	r3, [pc, #40]	; (800271c <HAL_RCC_ClockConfig+0x184>)
 80026f4:	e7ee      	b.n	80026d4 <HAL_RCC_ClockConfig+0x13c>
        return HAL_TIMEOUT;
 80026f6:	2003      	movs	r0, #3
 80026f8:	e7b2      	b.n	8002660 <HAL_RCC_ClockConfig+0xc8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80026fa:	0198      	lsls	r0, r3, #6
 80026fc:	d486      	bmi.n	800260c <HAL_RCC_ClockConfig+0x74>
 80026fe:	e7ae      	b.n	800265e <HAL_RCC_ClockConfig+0xc6>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002700:	4807      	ldr	r0, [pc, #28]	; (8002720 <HAL_RCC_ClockConfig+0x188>)
 8002702:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8002706:	2300      	movs	r3, #0
 8002708:	fba1 0100 	umull	r0, r1, r1, r0
 800270c:	f7fd fd94 	bl	8000238 <__aeabi_uldivmod>
 8002710:	e7d3      	b.n	80026ba <HAL_RCC_ClockConfig+0x122>
 8002712:	bf00      	nop
 8002714:	40023c00 	.word	0x40023c00
 8002718:	40023800 	.word	0x40023800
 800271c:	00f42400 	.word	0x00f42400
 8002720:	007a1200 	.word	0x007a1200
 8002724:	0800995c 	.word	0x0800995c
 8002728:	20001f48 	.word	0x20001f48

0800272c <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800272c:	4916      	ldr	r1, [pc, #88]	; (8002788 <HAL_RCC_GetSysClockFreq+0x5c>)
{
 800272e:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002730:	688b      	ldr	r3, [r1, #8]
 8002732:	f003 030c 	and.w	r3, r3, #12
 8002736:	2b04      	cmp	r3, #4
 8002738:	d01b      	beq.n	8002772 <HAL_RCC_GetSysClockFreq+0x46>
 800273a:	2b08      	cmp	r3, #8
 800273c:	d117      	bne.n	800276e <HAL_RCC_GetSysClockFreq+0x42>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800273e:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002740:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002742:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002746:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002748:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 800274c:	d113      	bne.n	8002776 <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800274e:	480f      	ldr	r0, [pc, #60]	; (800278c <HAL_RCC_GetSysClockFreq+0x60>)
 8002750:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8002754:	fba1 0100 	umull	r0, r1, r1, r0
 8002758:	f7fd fd6e 	bl	8000238 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 800275c:	4b0a      	ldr	r3, [pc, #40]	; (8002788 <HAL_RCC_GetSysClockFreq+0x5c>)
 800275e:	685b      	ldr	r3, [r3, #4]
 8002760:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8002764:	3301      	adds	r3, #1
 8002766:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002768:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800276c:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 800276e:	4807      	ldr	r0, [pc, #28]	; (800278c <HAL_RCC_GetSysClockFreq+0x60>)
}
 8002770:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 8002772:	4807      	ldr	r0, [pc, #28]	; (8002790 <HAL_RCC_GetSysClockFreq+0x64>)
}
 8002774:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002776:	4806      	ldr	r0, [pc, #24]	; (8002790 <HAL_RCC_GetSysClockFreq+0x64>)
 8002778:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800277c:	2300      	movs	r3, #0
 800277e:	fba1 0100 	umull	r0, r1, r1, r0
 8002782:	f7fd fd59 	bl	8000238 <__aeabi_uldivmod>
 8002786:	e7e9      	b.n	800275c <HAL_RCC_GetSysClockFreq+0x30>
 8002788:	40023800 	.word	0x40023800
 800278c:	00f42400 	.word	0x00f42400
 8002790:	007a1200 	.word	0x007a1200

08002794 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8002794:	4b04      	ldr	r3, [pc, #16]	; (80027a8 <HAL_RCC_GetPCLK1Freq+0x14>)
 8002796:	4a05      	ldr	r2, [pc, #20]	; (80027ac <HAL_RCC_GetPCLK1Freq+0x18>)
 8002798:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800279a:	4905      	ldr	r1, [pc, #20]	; (80027b0 <HAL_RCC_GetPCLK1Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800279c:	f3c3 2382 	ubfx	r3, r3, #10, #3
 80027a0:	6808      	ldr	r0, [r1, #0]
 80027a2:	5cd3      	ldrb	r3, [r2, r3]
}
 80027a4:	40d8      	lsrs	r0, r3
 80027a6:	4770      	bx	lr
 80027a8:	40023800 	.word	0x40023800
 80027ac:	0800996c 	.word	0x0800996c
 80027b0:	20001f48 	.word	0x20001f48

080027b4 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80027b4:	4b04      	ldr	r3, [pc, #16]	; (80027c8 <HAL_RCC_GetPCLK2Freq+0x14>)
 80027b6:	4a05      	ldr	r2, [pc, #20]	; (80027cc <HAL_RCC_GetPCLK2Freq+0x18>)
 80027b8:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 80027ba:	4905      	ldr	r1, [pc, #20]	; (80027d0 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80027bc:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80027c0:	6808      	ldr	r0, [r1, #0]
 80027c2:	5cd3      	ldrb	r3, [r2, r3]
}
 80027c4:	40d8      	lsrs	r0, r3
 80027c6:	4770      	bx	lr
 80027c8:	40023800 	.word	0x40023800
 80027cc:	0800996c 	.word	0x0800996c
 80027d0:	20001f48 	.word	0x20001f48

080027d4 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80027d4:	6803      	ldr	r3, [r0, #0]
{
 80027d6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80027da:	f013 0601 	ands.w	r6, r3, #1
{
 80027de:	b083      	sub	sp, #12
 80027e0:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80027e2:	d00b      	beq.n	80027fc <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80027e4:	4a9f      	ldr	r2, [pc, #636]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80027e6:	6891      	ldr	r1, [r2, #8]
 80027e8:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 80027ec:	6091      	str	r1, [r2, #8]
 80027ee:	6b46      	ldr	r6, [r0, #52]	; 0x34
 80027f0:	6891      	ldr	r1, [r2, #8]
 80027f2:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 80027f4:	fab6 f686 	clz	r6, r6
 80027f8:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80027fa:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 80027fc:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8002800:	d010      	beq.n	8002824 <HAL_RCCEx_PeriphCLKConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002802:	4998      	ldr	r1, [pc, #608]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002804:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8002806:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800280a:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800280e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8002812:	ea42 0205 	orr.w	r2, r2, r5
 8002816:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800281a:	f000 81d4 	beq.w	8002bc6 <HAL_RCCEx_PeriphCLKConfig+0x3f2>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 800281e:	fab5 f585 	clz	r5, r5
 8002822:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8002824:	02d9      	lsls	r1, r3, #11
 8002826:	d510      	bpl.n	800284a <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8002828:	488e      	ldr	r0, [pc, #568]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800282a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800282c:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8002830:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8002834:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8002838:	ea42 0201 	orr.w	r2, r2, r1
 800283c:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8002840:	f000 81bf 	beq.w	8002bc2 <HAL_RCCEx_PeriphCLKConfig+0x3ee>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8002844:	2900      	cmp	r1, #0
 8002846:	bf08      	it	eq
 8002848:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 800284a:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 800284e:	bf18      	it	ne
 8002850:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002852:	069a      	lsls	r2, r3, #26
 8002854:	f100 816d 	bmi.w	8002b32 <HAL_RCCEx_PeriphCLKConfig+0x35e>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8002858:	06da      	lsls	r2, r3, #27
 800285a:	d50c      	bpl.n	8002876 <HAL_RCCEx_PeriphCLKConfig+0xa2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800285c:	4a81      	ldr	r2, [pc, #516]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800285e:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8002862:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8002866:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 800286a:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 800286e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002870:	4301      	orrs	r1, r0
 8002872:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8002876:	045f      	lsls	r7, r3, #17
 8002878:	d508      	bpl.n	800288c <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800287a:	497a      	ldr	r1, [pc, #488]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800287c:	6e60      	ldr	r0, [r4, #100]	; 0x64
 800287e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002882:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8002886:	4302      	orrs	r2, r0
 8002888:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800288c:	0418      	lsls	r0, r3, #16
 800288e:	d508      	bpl.n	80028a2 <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8002890:	4974      	ldr	r1, [pc, #464]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002892:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8002894:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002898:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 800289c:	4302      	orrs	r2, r0
 800289e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80028a2:	03d9      	lsls	r1, r3, #15
 80028a4:	d508      	bpl.n	80028b8 <HAL_RCCEx_PeriphCLKConfig+0xe4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80028a6:	496f      	ldr	r1, [pc, #444]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80028a8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80028aa:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80028ae:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80028b2:	4302      	orrs	r2, r0
 80028b4:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80028b8:	039a      	lsls	r2, r3, #14
 80028ba:	d508      	bpl.n	80028ce <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 80028bc:	4969      	ldr	r1, [pc, #420]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80028be:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80028c0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80028c4:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 80028c8:	4302      	orrs	r2, r0
 80028ca:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80028ce:	065f      	lsls	r7, r3, #25
 80028d0:	d508      	bpl.n	80028e4 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80028d2:	4964      	ldr	r1, [pc, #400]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80028d4:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80028d6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80028da:	f022 0203 	bic.w	r2, r2, #3
 80028de:	4302      	orrs	r2, r0
 80028e0:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80028e4:	0618      	lsls	r0, r3, #24
 80028e6:	d508      	bpl.n	80028fa <HAL_RCCEx_PeriphCLKConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80028e8:	495e      	ldr	r1, [pc, #376]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80028ea:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80028ec:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80028f0:	f022 020c 	bic.w	r2, r2, #12
 80028f4:	4302      	orrs	r2, r0
 80028f6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80028fa:	05d9      	lsls	r1, r3, #23
 80028fc:	d508      	bpl.n	8002910 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80028fe:	4959      	ldr	r1, [pc, #356]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002900:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8002902:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002906:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 800290a:	4302      	orrs	r2, r0
 800290c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8002910:	059a      	lsls	r2, r3, #22
 8002912:	d508      	bpl.n	8002926 <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002914:	4953      	ldr	r1, [pc, #332]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002916:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8002918:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800291c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8002920:	4302      	orrs	r2, r0
 8002922:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002926:	055f      	lsls	r7, r3, #21
 8002928:	d508      	bpl.n	800293c <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800292a:	494e      	ldr	r1, [pc, #312]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800292c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800292e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002932:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002936:	4302      	orrs	r2, r0
 8002938:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 800293c:	0518      	lsls	r0, r3, #20
 800293e:	d508      	bpl.n	8002952 <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8002940:	4948      	ldr	r1, [pc, #288]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002942:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8002944:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002948:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 800294c:	4302      	orrs	r2, r0
 800294e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8002952:	04d9      	lsls	r1, r3, #19
 8002954:	d508      	bpl.n	8002968 <HAL_RCCEx_PeriphCLKConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8002956:	4943      	ldr	r1, [pc, #268]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002958:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800295a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800295e:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002962:	4302      	orrs	r2, r0
 8002964:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8002968:	049a      	lsls	r2, r3, #18
 800296a:	d508      	bpl.n	800297e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 800296c:	493d      	ldr	r1, [pc, #244]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800296e:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8002970:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002974:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002978:	4302      	orrs	r2, r0
 800297a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800297e:	025f      	lsls	r7, r3, #9
 8002980:	d508      	bpl.n	8002994 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8002982:	4938      	ldr	r1, [pc, #224]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002984:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8002986:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800298a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800298e:	4302      	orrs	r2, r0
 8002990:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8002994:	0298      	lsls	r0, r3, #10
 8002996:	d50c      	bpl.n	80029b2 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8002998:	4932      	ldr	r1, [pc, #200]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800299a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800299c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 80029a0:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 80029a4:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
 80029a8:	bf08      	it	eq
 80029aa:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 80029ac:	4302      	orrs	r2, r0
 80029ae:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 80029b2:	f013 0f08 	tst.w	r3, #8
 80029b6:	bf18      	it	ne
 80029b8:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80029ba:	0359      	lsls	r1, r3, #13
 80029bc:	d508      	bpl.n	80029d0 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80029be:	4929      	ldr	r1, [pc, #164]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80029c0:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80029c2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80029c6:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80029ca:	4302      	orrs	r2, r0
 80029cc:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 80029d0:	021a      	lsls	r2, r3, #8
 80029d2:	d509      	bpl.n	80029e8 <HAL_RCCEx_PeriphCLKConfig+0x214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80029d4:	4923      	ldr	r1, [pc, #140]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80029d6:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 80029da:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80029de:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 80029e2:	4302      	orrs	r2, r0
 80029e4:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 80029e8:	015f      	lsls	r7, r3, #5
 80029ea:	d509      	bpl.n	8002a00 <HAL_RCCEx_PeriphCLKConfig+0x22c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 80029ec:	491d      	ldr	r1, [pc, #116]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 80029ee:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 80029f2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80029f6:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 80029fa:	4302      	orrs	r2, r0
 80029fc:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8002a00:	0118      	lsls	r0, r3, #4
 8002a02:	d509      	bpl.n	8002a18 <HAL_RCCEx_PeriphCLKConfig+0x244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8002a04:	4917      	ldr	r1, [pc, #92]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002a06:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8002a0a:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8002a0e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 8002a12:	4302      	orrs	r2, r0
 8002a14:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 8002a18:	00d9      	lsls	r1, r3, #3
 8002a1a:	d40b      	bmi.n	8002a34 <HAL_RCCEx_PeriphCLKConfig+0x260>
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8002a1c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8002a20:	d016      	beq.n	8002a50 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 8002a22:	07f2      	lsls	r2, r6, #31
 8002a24:	d414      	bmi.n	8002a50 <HAL_RCCEx_PeriphCLKConfig+0x27c>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8002a26:	2d01      	cmp	r5, #1
 8002a28:	f000 80d0 	beq.w	8002bcc <HAL_RCCEx_PeriphCLKConfig+0x3f8>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8002a2c:	2000      	movs	r0, #0
}
 8002a2e:	b003      	add	sp, #12
 8002a30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8002a34:	490b      	ldr	r1, [pc, #44]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8002a36:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8002a3a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8002a3e:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8002a42:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8002a46:	ea42 0200 	orr.w	r2, r2, r0
 8002a4a:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8002a4e:	d1e8      	bne.n	8002a22 <HAL_RCCEx_PeriphCLKConfig+0x24e>
    __HAL_RCC_PLLI2S_DISABLE();
 8002a50:	4b04      	ldr	r3, [pc, #16]	; (8002a64 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 8002a52:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002a54:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_DISABLE();
 8002a56:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8002a5a:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002a5c:	f7fd fda8 	bl	80005b0 <HAL_GetTick>
 8002a60:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002a62:	e006      	b.n	8002a72 <HAL_RCCEx_PeriphCLKConfig+0x29e>
 8002a64:	40023800 	.word	0x40023800
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002a68:	f7fd fda2 	bl	80005b0 <HAL_GetTick>
 8002a6c:	1bc0      	subs	r0, r0, r7
 8002a6e:	2864      	cmp	r0, #100	; 0x64
 8002a70:	d85b      	bhi.n	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002a72:	6833      	ldr	r3, [r6, #0]
 8002a74:	011b      	lsls	r3, r3, #4
 8002a76:	d4f7      	bmi.n	8002a68 <HAL_RCCEx_PeriphCLKConfig+0x294>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8002a78:	6823      	ldr	r3, [r4, #0]
 8002a7a:	07df      	lsls	r7, r3, #31
 8002a7c:	d512      	bpl.n	8002aa4 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
 8002a7e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002a80:	b982      	cbnz	r2, 8002aa4 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002a82:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002a86:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8002a8a:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8002a8e:	6860      	ldr	r0, [r4, #4]
 8002a90:	f007 6770 	and.w	r7, r7, #251658240	; 0xf000000
 8002a94:	68a1      	ldr	r1, [r4, #8]
 8002a96:	433a      	orrs	r2, r7
 8002a98:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002a9c:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8002aa0:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8002aa4:	031e      	lsls	r6, r3, #12
 8002aa6:	f100 810f 	bmi.w	8002cc8 <HAL_RCCEx_PeriphCLKConfig+0x4f4>
 8002aaa:	02d8      	lsls	r0, r3, #11
 8002aac:	d504      	bpl.n	8002ab8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8002aae:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002ab0:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 8002ab4:	f000 810d 	beq.w	8002cd2 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8002ab8:	01d9      	lsls	r1, r3, #7
 8002aba:	d511      	bpl.n	8002ae0 <HAL_RCCEx_PeriphCLKConfig+0x30c>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002abc:	4ea4      	ldr	r6, [pc, #656]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8002abe:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002ac0:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002ac4:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8002ac8:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8002acc:	6921      	ldr	r1, [r4, #16]
 8002ace:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 8002ad2:	433a      	orrs	r2, r7
 8002ad4:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002ad8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002adc:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8002ae0:	019a      	lsls	r2, r3, #6
 8002ae2:	d50d      	bpl.n	8002b00 <HAL_RCCEx_PeriphCLKConfig+0x32c>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8002ae4:	6923      	ldr	r3, [r4, #16]
 8002ae6:	6862      	ldr	r2, [r4, #4]
 8002ae8:	041b      	lsls	r3, r3, #16
 8002aea:	e9d4 1002 	ldrd	r1, r0, [r4, #8]
 8002aee:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8002af2:	4a97      	ldr	r2, [pc, #604]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002af4:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8002af8:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8002afc:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8002b00:	4b93      	ldr	r3, [pc, #588]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002b02:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002b04:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_ENABLE();
 8002b06:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002b0a:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002b0c:	f7fd fd50 	bl	80005b0 <HAL_GetTick>
 8002b10:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002b12:	e004      	b.n	8002b1e <HAL_RCCEx_PeriphCLKConfig+0x34a>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002b14:	f7fd fd4c 	bl	80005b0 <HAL_GetTick>
 8002b18:	1bc0      	subs	r0, r0, r7
 8002b1a:	2864      	cmp	r0, #100	; 0x64
 8002b1c:	d805      	bhi.n	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002b1e:	6833      	ldr	r3, [r6, #0]
 8002b20:	011b      	lsls	r3, r3, #4
 8002b22:	d5f7      	bpl.n	8002b14 <HAL_RCCEx_PeriphCLKConfig+0x340>
  if(pllsaiused == 1)
 8002b24:	2d01      	cmp	r5, #1
 8002b26:	d181      	bne.n	8002a2c <HAL_RCCEx_PeriphCLKConfig+0x258>
 8002b28:	e050      	b.n	8002bcc <HAL_RCCEx_PeriphCLKConfig+0x3f8>
        return HAL_TIMEOUT;
 8002b2a:	2003      	movs	r0, #3
}
 8002b2c:	b003      	add	sp, #12
 8002b2e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8002b32:	4a87      	ldr	r2, [pc, #540]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
    PWR->CR1 |= PWR_CR1_DBP;
 8002b34:	4b87      	ldr	r3, [pc, #540]	; (8002d54 <HAL_RCCEx_PeriphCLKConfig+0x580>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8002b36:	6c11      	ldr	r1, [r2, #64]	; 0x40
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002b38:	461f      	mov	r7, r3
    __HAL_RCC_PWR_CLK_ENABLE();
 8002b3a:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002b3e:	6411      	str	r1, [r2, #64]	; 0x40
 8002b40:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002b42:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8002b46:	9201      	str	r2, [sp, #4]
 8002b48:	9a01      	ldr	r2, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8002b4a:	681a      	ldr	r2, [r3, #0]
 8002b4c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002b50:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002b52:	f7fd fd2d 	bl	80005b0 <HAL_GetTick>
 8002b56:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002b58:	e005      	b.n	8002b66 <HAL_RCCEx_PeriphCLKConfig+0x392>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002b5a:	f7fd fd29 	bl	80005b0 <HAL_GetTick>
 8002b5e:	eba0 0008 	sub.w	r0, r0, r8
 8002b62:	2864      	cmp	r0, #100	; 0x64
 8002b64:	d8e1      	bhi.n	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002b66:	683b      	ldr	r3, [r7, #0]
 8002b68:	05db      	lsls	r3, r3, #23
 8002b6a:	d5f6      	bpl.n	8002b5a <HAL_RCCEx_PeriphCLKConfig+0x386>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002b6c:	4a78      	ldr	r2, [pc, #480]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002b6e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002b70:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002b72:	f403 7040 	and.w	r0, r3, #768	; 0x300
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002b76:	f411 7140 	ands.w	r1, r1, #768	; 0x300
 8002b7a:	d011      	beq.n	8002ba0 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 8002b7c:	4281      	cmp	r1, r0
 8002b7e:	d00f      	beq.n	8002ba0 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002b80:	6f11      	ldr	r1, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8002b82:	6f17      	ldr	r7, [r2, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002b84:	f421 7140 	bic.w	r1, r1, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002b88:	f447 3780 	orr.w	r7, r7, #65536	; 0x10000
 8002b8c:	6717      	str	r7, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002b8e:	6f17      	ldr	r7, [r2, #112]	; 0x70
 8002b90:	f427 3780 	bic.w	r7, r7, #65536	; 0x10000
 8002b94:	6717      	str	r7, [r2, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 8002b96:	6711      	str	r1, [r2, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8002b98:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002b9a:	07cf      	lsls	r7, r1, #31
 8002b9c:	f100 80c3 	bmi.w	8002d26 <HAL_RCCEx_PeriphCLKConfig+0x552>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002ba0:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
 8002ba4:	f000 80b1 	beq.w	8002d0a <HAL_RCCEx_PeriphCLKConfig+0x536>
 8002ba8:	4969      	ldr	r1, [pc, #420]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002baa:	688a      	ldr	r2, [r1, #8]
 8002bac:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002bb0:	608a      	str	r2, [r1, #8]
 8002bb2:	4a67      	ldr	r2, [pc, #412]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002bb4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002bb8:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002bba:	430b      	orrs	r3, r1
 8002bbc:	6713      	str	r3, [r2, #112]	; 0x70
 8002bbe:	6823      	ldr	r3, [r4, #0]
 8002bc0:	e64a      	b.n	8002858 <HAL_RCCEx_PeriphCLKConfig+0x84>
      plli2sused = 1;
 8002bc2:	2601      	movs	r6, #1
 8002bc4:	e641      	b.n	800284a <HAL_RCCEx_PeriphCLKConfig+0x76>
  uint32_t pllsaiused = 0;
 8002bc6:	2500      	movs	r5, #0
      plli2sused = 1;
 8002bc8:	2601      	movs	r6, #1
 8002bca:	e62b      	b.n	8002824 <HAL_RCCEx_PeriphCLKConfig+0x50>
    __HAL_RCC_PLLSAI_DISABLE();
 8002bcc:	4b60      	ldr	r3, [pc, #384]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002bce:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8002bd0:	461d      	mov	r5, r3
    __HAL_RCC_PLLSAI_DISABLE();
 8002bd2:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8002bd6:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002bd8:	f7fd fcea 	bl	80005b0 <HAL_GetTick>
 8002bdc:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8002bde:	e004      	b.n	8002bea <HAL_RCCEx_PeriphCLKConfig+0x416>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8002be0:	f7fd fce6 	bl	80005b0 <HAL_GetTick>
 8002be4:	1b80      	subs	r0, r0, r6
 8002be6:	2864      	cmp	r0, #100	; 0x64
 8002be8:	d89f      	bhi.n	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8002bea:	682b      	ldr	r3, [r5, #0]
 8002bec:	009f      	lsls	r7, r3, #2
 8002bee:	d4f7      	bmi.n	8002be0 <HAL_RCCEx_PeriphCLKConfig+0x40c>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8002bf0:	6823      	ldr	r3, [r4, #0]
 8002bf2:	031d      	lsls	r5, r3, #12
 8002bf4:	f100 8092 	bmi.w	8002d1c <HAL_RCCEx_PeriphCLKConfig+0x548>
 8002bf8:	02d8      	lsls	r0, r3, #11
 8002bfa:	d51d      	bpl.n	8002c38 <HAL_RCCEx_PeriphCLKConfig+0x464>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8002bfc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002bfe:	b9da      	cbnz	r2, 8002c38 <HAL_RCCEx_PeriphCLKConfig+0x464>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002c00:	4953      	ldr	r1, [pc, #332]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8002c02:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002c04:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8002c08:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8002c0c:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8002c10:	69a0      	ldr	r0, [r4, #24]
 8002c12:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8002c16:	4332      	orrs	r2, r6
 8002c18:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8002c1c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8002c20:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8002c24:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8002c28:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8002c2a:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8002c2e:	3801      	subs	r0, #1
 8002c30:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8002c34:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8002c38:	0299      	lsls	r1, r3, #10
 8002c3a:	d515      	bpl.n	8002c68 <HAL_RCCEx_PeriphCLKConfig+0x494>
 8002c3c:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8002c3e:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8002c42:	d111      	bne.n	8002c68 <HAL_RCCEx_PeriphCLKConfig+0x494>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002c44:	4942      	ldr	r1, [pc, #264]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8002c46:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002c48:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8002c4c:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8002c50:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8002c54:	6a20      	ldr	r0, [r4, #32]
 8002c56:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8002c5a:	4332      	orrs	r2, r6
 8002c5c:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8002c60:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8002c64:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8002c68:	071a      	lsls	r2, r3, #28
 8002c6a:	d519      	bpl.n	8002ca0 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002c6c:	4a38      	ldr	r2, [pc, #224]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8002c6e:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002c70:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002c74:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8002c78:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8002c7c:	69e0      	ldr	r0, [r4, #28]
 8002c7e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002c82:	430b      	orrs	r3, r1
 8002c84:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8002c88:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8002c8c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8002c90:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002c94:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8002c96:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8002c9a:	430b      	orrs	r3, r1
 8002c9c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 8002ca0:	4b2b      	ldr	r3, [pc, #172]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002ca2:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8002ca4:	461c      	mov	r4, r3
    __HAL_RCC_PLLSAI_ENABLE();
 8002ca6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002caa:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002cac:	f7fd fc80 	bl	80005b0 <HAL_GetTick>
 8002cb0:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8002cb2:	e005      	b.n	8002cc0 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8002cb4:	f7fd fc7c 	bl	80005b0 <HAL_GetTick>
 8002cb8:	1b40      	subs	r0, r0, r5
 8002cba:	2864      	cmp	r0, #100	; 0x64
 8002cbc:	f63f af35 	bhi.w	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8002cc0:	6823      	ldr	r3, [r4, #0]
 8002cc2:	009b      	lsls	r3, r3, #2
 8002cc4:	d5f6      	bpl.n	8002cb4 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
 8002cc6:	e6b1      	b.n	8002a2c <HAL_RCCEx_PeriphCLKConfig+0x258>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8002cc8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002cca:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8002cce:	f47f aeec 	bne.w	8002aaa <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002cd2:	4e1f      	ldr	r6, [pc, #124]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8002cd4:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002cd6:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002cda:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8002cde:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8002ce2:	68e1      	ldr	r1, [r4, #12]
 8002ce4:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 8002ce8:	433a      	orrs	r2, r7
 8002cea:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002cee:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8002cf2:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8002cf6:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 8002cfa:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002cfc:	f021 011f 	bic.w	r1, r1, #31
 8002d00:	3a01      	subs	r2, #1
 8002d02:	430a      	orrs	r2, r1
 8002d04:	f8c6 208c 	str.w	r2, [r6, #140]	; 0x8c
 8002d08:	e6d6      	b.n	8002ab8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002d0a:	4811      	ldr	r0, [pc, #68]	; (8002d50 <HAL_RCCEx_PeriphCLKConfig+0x57c>)
 8002d0c:	4912      	ldr	r1, [pc, #72]	; (8002d58 <HAL_RCCEx_PeriphCLKConfig+0x584>)
 8002d0e:	6882      	ldr	r2, [r0, #8]
 8002d10:	4019      	ands	r1, r3
 8002d12:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002d16:	430a      	orrs	r2, r1
 8002d18:	6082      	str	r2, [r0, #8]
 8002d1a:	e74a      	b.n	8002bb2 <HAL_RCCEx_PeriphCLKConfig+0x3de>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8002d1c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002d1e:	2a00      	cmp	r2, #0
 8002d20:	f43f af6e 	beq.w	8002c00 <HAL_RCCEx_PeriphCLKConfig+0x42c>
 8002d24:	e768      	b.n	8002bf8 <HAL_RCCEx_PeriphCLKConfig+0x424>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002d26:	4617      	mov	r7, r2
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002d28:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8002d2c:	f7fd fc40 	bl	80005b0 <HAL_GetTick>
 8002d30:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002d32:	e006      	b.n	8002d42 <HAL_RCCEx_PeriphCLKConfig+0x56e>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002d34:	f7fd fc3c 	bl	80005b0 <HAL_GetTick>
 8002d38:	eba0 0009 	sub.w	r0, r0, r9
 8002d3c:	4540      	cmp	r0, r8
 8002d3e:	f63f aef4 	bhi.w	8002b2a <HAL_RCCEx_PeriphCLKConfig+0x356>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002d42:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8002d44:	0799      	lsls	r1, r3, #30
 8002d46:	d5f5      	bpl.n	8002d34 <HAL_RCCEx_PeriphCLKConfig+0x560>
 8002d48:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002d4a:	f403 7040 	and.w	r0, r3, #768	; 0x300
 8002d4e:	e727      	b.n	8002ba0 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 8002d50:	40023800 	.word	0x40023800
 8002d54:	40007000 	.word	0x40007000
 8002d58:	0ffffcff 	.word	0x0ffffcff

08002d5c <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002d5c:	b570      	push	{r4, r5, r6, lr}
 8002d5e:	4604      	mov	r4, r0
 8002d60:	460d      	mov	r5, r1
 8002d62:	4616      	mov	r6, r2
 8002d64:	1c68      	adds	r0, r5, #1
  while ((hspi->Instance->SR & Fifo) != State)
 8002d66:	6823      	ldr	r3, [r4, #0]
 8002d68:	d110      	bne.n	8002d8c <SPI_EndRxTxTransaction+0x30>
 8002d6a:	689a      	ldr	r2, [r3, #8]
 8002d6c:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
 8002d70:	d1fb      	bne.n	8002d6a <SPI_EndRxTxTransaction+0xe>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8002d72:	689a      	ldr	r2, [r3, #8]
 8002d74:	0611      	lsls	r1, r2, #24
 8002d76:	d504      	bpl.n	8002d82 <SPI_EndRxTxTransaction+0x26>
 8002d78:	689a      	ldr	r2, [r3, #8]
 8002d7a:	0611      	lsls	r1, r2, #24
 8002d7c:	d4f9      	bmi.n	8002d72 <SPI_EndRxTxTransaction+0x16>
 8002d7e:	e000      	b.n	8002d82 <SPI_EndRxTxTransaction+0x26>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8002d80:	7b1a      	ldrb	r2, [r3, #12]
  while ((hspi->Instance->SR & Fifo) != State)
 8002d82:	6898      	ldr	r0, [r3, #8]
 8002d84:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 8002d88:	d1fa      	bne.n	8002d80 <SPI_EndRxTxTransaction+0x24>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 8002d8a:	bd70      	pop	{r4, r5, r6, pc}
  while ((hspi->Instance->SR & Fifo) != State)
 8002d8c:	689a      	ldr	r2, [r3, #8]
 8002d8e:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
 8002d92:	d02b      	beq.n	8002dec <SPI_EndRxTxTransaction+0x90>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002d94:	f7fd fc0c 	bl	80005b0 <HAL_GetTick>
 8002d98:	1b80      	subs	r0, r0, r6
 8002d9a:	4285      	cmp	r5, r0
 8002d9c:	d8e2      	bhi.n	8002d64 <SPI_EndRxTxTransaction+0x8>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002d9e:	6823      	ldr	r3, [r4, #0]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002da0:	6861      	ldr	r1, [r4, #4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002da2:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002da4:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002da8:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8002dac:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002dae:	d02d      	beq.n	8002e0c <SPI_EndRxTxTransaction+0xb0>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002db0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002db2:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002db6:	d107      	bne.n	8002dc8 <SPI_EndRxTxTransaction+0x6c>
          SPI_RESET_CRC(hspi);
 8002db8:	681a      	ldr	r2, [r3, #0]
 8002dba:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002dbe:	601a      	str	r2, [r3, #0]
 8002dc0:	681a      	ldr	r2, [r3, #0]
 8002dc2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002dc6:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8002dc8:	2301      	movs	r3, #1
        __HAL_UNLOCK(hspi);
 8002dca:	2200      	movs	r2, #0
    return HAL_TIMEOUT;
 8002dcc:	2003      	movs	r0, #3
        hspi->State = HAL_SPI_STATE_READY;
 8002dce:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002dd2:	6e23      	ldr	r3, [r4, #96]	; 0x60
        __HAL_UNLOCK(hspi);
 8002dd4:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002dd8:	f043 0320 	orr.w	r3, r3, #32
 8002ddc:	6623      	str	r3, [r4, #96]	; 0x60
}
 8002dde:	bd70      	pop	{r4, r5, r6, pc}
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002de0:	f7fd fbe6 	bl	80005b0 <HAL_GetTick>
 8002de4:	1b80      	subs	r0, r0, r6
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002de6:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002de8:	4285      	cmp	r5, r0
 8002dea:	d9d9      	bls.n	8002da0 <SPI_EndRxTxTransaction+0x44>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8002dec:	689a      	ldr	r2, [r3, #8]
 8002dee:	0612      	lsls	r2, r2, #24
 8002df0:	d4f6      	bmi.n	8002de0 <SPI_EndRxTxTransaction+0x84>
 8002df2:	e006      	b.n	8002e02 <SPI_EndRxTxTransaction+0xa6>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8002df4:	7b1b      	ldrb	r3, [r3, #12]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002df6:	f7fd fbdb 	bl	80005b0 <HAL_GetTick>
 8002dfa:	1b80      	subs	r0, r0, r6
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002dfc:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002dfe:	4285      	cmp	r5, r0
 8002e00:	d9ce      	bls.n	8002da0 <SPI_EndRxTxTransaction+0x44>
  while ((hspi->Instance->SR & Fifo) != State)
 8002e02:	6898      	ldr	r0, [r3, #8]
 8002e04:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 8002e08:	d1f4      	bne.n	8002df4 <SPI_EndRxTxTransaction+0x98>
}
 8002e0a:	bd70      	pop	{r4, r5, r6, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002e0c:	68a2      	ldr	r2, [r4, #8]
 8002e0e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8002e12:	d002      	beq.n	8002e1a <SPI_EndRxTxTransaction+0xbe>
 8002e14:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8002e18:	d1ca      	bne.n	8002db0 <SPI_EndRxTxTransaction+0x54>
          __HAL_SPI_DISABLE(hspi);
 8002e1a:	681a      	ldr	r2, [r3, #0]
 8002e1c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002e20:	601a      	str	r2, [r3, #0]
 8002e22:	e7c5      	b.n	8002db0 <SPI_EndRxTxTransaction+0x54>

08002e24 <HAL_SPI_Init>:
  if (hspi == NULL)
 8002e24:	2800      	cmp	r0, #0
 8002e26:	d05d      	beq.n	8002ee4 <HAL_SPI_Init+0xc0>
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002e28:	2200      	movs	r2, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002e2a:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
{
 8002e2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002e32:	6282      	str	r2, [r0, #40]	; 0x28
 8002e34:	4604      	mov	r4, r0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002e36:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002e3a:	2b00      	cmp	r3, #0
 8002e3c:	d04d      	beq.n	8002eda <HAL_SPI_Init+0xb6>
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002e3e:	68e7      	ldr	r7, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002e40:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8002e42:	6822      	ldr	r2, [r4, #0]
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8002e44:	f5b7 6fe0 	cmp.w	r7, #1792	; 0x700
  hspi->State = HAL_SPI_STATE_BUSY;
 8002e48:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002e4c:	f427 6100 	bic.w	r1, r7, #2048	; 0x800
  __HAL_SPI_DISABLE(hspi);
 8002e50:	6813      	ldr	r3, [r2, #0]
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8002e52:	bf94      	ite	ls
 8002e54:	f44f 5580 	movls.w	r5, #4096	; 0x1000
 8002e58:	2500      	movhi	r5, #0
  __HAL_SPI_DISABLE(hspi);
 8002e5a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002e5e:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 8002e62:	6013      	str	r3, [r2, #0]
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002e64:	d135      	bne.n	8002ed2 <HAL_SPI_Init+0xae>
 8002e66:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8002e68:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e6a:	b92b      	cbnz	r3, 8002e78 <HAL_SPI_Init+0x54>
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002e6c:	f5b7 6fe0 	cmp.w	r7, #1792	; 0x700
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8002e70:	bf8c      	ite	hi
 8002e72:	2302      	movhi	r3, #2
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8002e74:	2301      	movls	r3, #1
 8002e76:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002e78:	68a1      	ldr	r1, [r4, #8]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002e7a:	f04f 0800 	mov.w	r8, #0
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002e7e:	6863      	ldr	r3, [r4, #4]
 8002e80:	6920      	ldr	r0, [r4, #16]
 8002e82:	430b      	orrs	r3, r1
 8002e84:	6961      	ldr	r1, [r4, #20]
 8002e86:	4303      	orrs	r3, r0
 8002e88:	430b      	orrs	r3, r1
 8002e8a:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 8002e8e:	430b      	orrs	r3, r1
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002e90:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002e92:	ea4f 4c10 	mov.w	ip, r0, lsr #16
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002e96:	f400 7e00 	and.w	lr, r0, #512	; 0x200
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002e9a:	430f      	orrs	r7, r1
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002e9c:	6a21      	ldr	r1, [r4, #32]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002e9e:	f00c 0c04 	and.w	ip, ip, #4
  return HAL_OK;
 8002ea2:	4640      	mov	r0, r8
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002ea4:	430b      	orrs	r3, r1
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002ea6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8002ea8:	430f      	orrs	r7, r1
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002eaa:	ea43 030e 	orr.w	r3, r3, lr
  hspi->State     = HAL_SPI_STATE_READY;
 8002eae:	f04f 0e01 	mov.w	lr, #1
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002eb2:	ea47 070c 	orr.w	r7, r7, ip
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002eb6:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002eb8:	433d      	orrs	r5, r7
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002eba:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002ebc:	6055      	str	r5, [r2, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002ebe:	69d3      	ldr	r3, [r2, #28]
 8002ec0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002ec4:	61d3      	str	r3, [r2, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002ec6:	f8c4 8060 	str.w	r8, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8002eca:	f884 e05d 	strb.w	lr, [r4, #93]	; 0x5d
}
 8002ece:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002ed2:	2300      	movs	r3, #0
 8002ed4:	461e      	mov	r6, r3
 8002ed6:	62a3      	str	r3, [r4, #40]	; 0x28
 8002ed8:	e7c6      	b.n	8002e68 <HAL_SPI_Init+0x44>
    hspi->Lock = HAL_UNLOCKED;
 8002eda:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 8002ede:	f003 fa6b 	bl	80063b8 <HAL_SPI_MspInit>
 8002ee2:	e7ac      	b.n	8002e3e <HAL_SPI_Init+0x1a>
    return HAL_ERROR;
 8002ee4:	2001      	movs	r0, #1
}
 8002ee6:	4770      	bx	lr

08002ee8 <HAL_SPI_Transmit>:
{
 8002ee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hspi);
 8002eec:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
{
 8002ef0:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8002ef2:	2c01      	cmp	r4, #1
 8002ef4:	f000 8082 	beq.w	8002ffc <HAL_SPI_Transmit+0x114>
 8002ef8:	461d      	mov	r5, r3
 8002efa:	2301      	movs	r3, #1
 8002efc:	4604      	mov	r4, r0
 8002efe:	4617      	mov	r7, r2
 8002f00:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
 8002f04:	4688      	mov	r8, r1
  tickstart = HAL_GetTick();
 8002f06:	f7fd fb53 	bl	80005b0 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8002f0a:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tickstart = HAL_GetTick();
 8002f0e:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002f10:	2b01      	cmp	r3, #1
 8002f12:	d009      	beq.n	8002f28 <HAL_SPI_Transmit+0x40>
    errorcode = HAL_BUSY;
 8002f14:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002f16:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8002f18:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8002f1a:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8002f1e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8002f22:	b002      	add	sp, #8
 8002f24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8002f28:	f1b8 0f00 	cmp.w	r8, #0
 8002f2c:	d06a      	beq.n	8003004 <HAL_SPI_Transmit+0x11c>
 8002f2e:	fab7 f387 	clz	r3, r7
 8002f32:	095b      	lsrs	r3, r3, #5
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	d165      	bne.n	8003004 <HAL_SPI_Transmit+0x11c>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002f38:	68a2      	ldr	r2, [r4, #8]
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002f3a:	2103      	movs	r1, #3
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002f3c:	6423      	str	r3, [r4, #64]	; 0x40
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002f3e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002f42:	f884 105d 	strb.w	r1, [r4, #93]	; 0x5d
  hspi->RxXferSize  = 0U;
 8002f46:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002f4a:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002f4c:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->TxXferCount = Size;
 8002f50:	87e7      	strh	r7, [r4, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 8002f52:	87a7      	strh	r7, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8002f54:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;
 8002f58:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
 8002f5c:	6823      	ldr	r3, [r4, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002f5e:	d103      	bne.n	8002f68 <HAL_SPI_Transmit+0x80>
    SPI_1LINE_TX(hspi);
 8002f60:	681a      	ldr	r2, [r3, #0]
 8002f62:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002f66:	601a      	str	r2, [r3, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002f68:	681a      	ldr	r2, [r3, #0]
 8002f6a:	0651      	lsls	r1, r2, #25
 8002f6c:	d403      	bmi.n	8002f76 <HAL_SPI_Transmit+0x8e>
    __HAL_SPI_ENABLE(hspi);
 8002f6e:	681a      	ldr	r2, [r3, #0]
 8002f70:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002f74:	601a      	str	r2, [r3, #0]
 8002f76:	f1a7 0201 	sub.w	r2, r7, #1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002f7a:	68e1      	ldr	r1, [r4, #12]
 8002f7c:	6867      	ldr	r7, [r4, #4]
 8002f7e:	fab2 f282 	clz	r2, r2
 8002f82:	0952      	lsrs	r2, r2, #5
 8002f84:	2f00      	cmp	r7, #0
 8002f86:	bf08      	it	eq
 8002f88:	2201      	moveq	r2, #1
 8002f8a:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
 8002f8e:	d954      	bls.n	800303a <HAL_SPI_Transmit+0x152>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002f90:	b142      	cbz	r2, 8002fa4 <HAL_SPI_Transmit+0xbc>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002f92:	4641      	mov	r1, r8
 8002f94:	f831 2b02 	ldrh.w	r2, [r1], #2
 8002f98:	60da      	str	r2, [r3, #12]
      hspi->TxXferCount--;
 8002f9a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002f9c:	63a1      	str	r1, [r4, #56]	; 0x38
      hspi->TxXferCount--;
 8002f9e:	3b01      	subs	r3, #1
 8002fa0:	b29b      	uxth	r3, r3
 8002fa2:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8002fa4:	1c6b      	adds	r3, r5, #1
 8002fa6:	d12f      	bne.n	8003008 <HAL_SPI_Transmit+0x120>
    while (hspi->TxXferCount > 0U)
 8002fa8:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8002faa:	b292      	uxth	r2, r2
 8002fac:	b182      	cbz	r2, 8002fd0 <HAL_SPI_Transmit+0xe8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002fae:	6823      	ldr	r3, [r4, #0]
 8002fb0:	689a      	ldr	r2, [r3, #8]
 8002fb2:	0797      	lsls	r7, r2, #30
 8002fb4:	d53e      	bpl.n	8003034 <HAL_SPI_Transmit+0x14c>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002fb6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002fb8:	f832 1b02 	ldrh.w	r1, [r2], #2
 8002fbc:	60d9      	str	r1, [r3, #12]
        hspi->TxXferCount--;
 8002fbe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002fc0:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8002fc2:	3b01      	subs	r3, #1
 8002fc4:	b29b      	uxth	r3, r3
 8002fc6:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8002fc8:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8002fca:	b292      	uxth	r2, r2
 8002fcc:	2a00      	cmp	r2, #0
 8002fce:	d1ee      	bne.n	8002fae <HAL_SPI_Transmit+0xc6>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002fd0:	4632      	mov	r2, r6
 8002fd2:	4629      	mov	r1, r5
 8002fd4:	4620      	mov	r0, r4
 8002fd6:	f7ff fec1 	bl	8002d5c <SPI_EndRxTxTransaction>
 8002fda:	b108      	cbz	r0, 8002fe0 <HAL_SPI_Transmit+0xf8>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002fdc:	2320      	movs	r3, #32
 8002fde:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002fe0:	68a3      	ldr	r3, [r4, #8]
 8002fe2:	b933      	cbnz	r3, 8002ff2 <HAL_SPI_Transmit+0x10a>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002fe4:	6822      	ldr	r2, [r4, #0]
 8002fe6:	9301      	str	r3, [sp, #4]
 8002fe8:	68d3      	ldr	r3, [r2, #12]
 8002fea:	9301      	str	r3, [sp, #4]
 8002fec:	6893      	ldr	r3, [r2, #8]
 8002fee:	9301      	str	r3, [sp, #4]
 8002ff0:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002ff2:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 8002ff4:	3000      	adds	r0, #0
 8002ff6:	bf18      	it	ne
 8002ff8:	2001      	movne	r0, #1
error:
 8002ffa:	e78c      	b.n	8002f16 <HAL_SPI_Transmit+0x2e>
  __HAL_LOCK(hspi);
 8002ffc:	2002      	movs	r0, #2
}
 8002ffe:	b002      	add	sp, #8
 8003000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    errorcode = HAL_ERROR;
 8003004:	2001      	movs	r0, #1
 8003006:	e786      	b.n	8002f16 <HAL_SPI_Transmit+0x2e>
    while (hspi->TxXferCount > 0U)
 8003008:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800300a:	b29b      	uxth	r3, r3
 800300c:	2b00      	cmp	r3, #0
 800300e:	d0df      	beq.n	8002fd0 <HAL_SPI_Transmit+0xe8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8003010:	6823      	ldr	r3, [r4, #0]
 8003012:	689a      	ldr	r2, [r3, #8]
 8003014:	0792      	lsls	r2, r2, #30
 8003016:	d568      	bpl.n	80030ea <HAL_SPI_Transmit+0x202>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003018:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800301a:	f832 1b02 	ldrh.w	r1, [r2], #2
 800301e:	60d9      	str	r1, [r3, #12]
        hspi->TxXferCount--;
 8003020:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8003022:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8003024:	3b01      	subs	r3, #1
 8003026:	b29b      	uxth	r3, r3
 8003028:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 800302a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800302c:	b29b      	uxth	r3, r3
 800302e:	2b00      	cmp	r3, #0
 8003030:	d1ee      	bne.n	8003010 <HAL_SPI_Transmit+0x128>
 8003032:	e7cd      	b.n	8002fd0 <HAL_SPI_Transmit+0xe8>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8003034:	f7fd fabc 	bl	80005b0 <HAL_GetTick>
 8003038:	e7b6      	b.n	8002fa8 <HAL_SPI_Transmit+0xc0>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800303a:	b15a      	cbz	r2, 8003054 <HAL_SPI_Transmit+0x16c>
      if (hspi->TxXferCount > 1U)
 800303c:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800303e:	2a01      	cmp	r2, #1
 8003040:	d960      	bls.n	8003104 <HAL_SPI_Transmit+0x21c>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003042:	4641      	mov	r1, r8
 8003044:	f831 2b02 	ldrh.w	r2, [r1], #2
 8003048:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount -= 2U;
 800304a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800304c:	63a1      	str	r1, [r4, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 800304e:	3b02      	subs	r3, #2
 8003050:	b29b      	uxth	r3, r3
 8003052:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8003054:	1c69      	adds	r1, r5, #1
 8003056:	d128      	bne.n	80030aa <HAL_SPI_Transmit+0x1c2>
    while (hspi->TxXferCount > 0U)
 8003058:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800305a:	b292      	uxth	r2, r2
 800305c:	2a00      	cmp	r2, #0
 800305e:	d0b7      	beq.n	8002fd0 <HAL_SPI_Transmit+0xe8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8003060:	6823      	ldr	r3, [r4, #0]
 8003062:	689a      	ldr	r2, [r3, #8]
 8003064:	0792      	lsls	r2, r2, #30
 8003066:	d514      	bpl.n	8003092 <HAL_SPI_Transmit+0x1aa>
        if (hspi->TxXferCount > 1U)
 8003068:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800306a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800306c:	2a01      	cmp	r2, #1
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800306e:	460a      	mov	r2, r1
        if (hspi->TxXferCount > 1U)
 8003070:	d931      	bls.n	80030d6 <HAL_SPI_Transmit+0x1ee>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003072:	f832 1b02 	ldrh.w	r1, [r2], #2
 8003076:	60d9      	str	r1, [r3, #12]
          hspi->TxXferCount -= 2U;
 8003078:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 800307a:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 800307c:	3b02      	subs	r3, #2
 800307e:	b29b      	uxth	r3, r3
 8003080:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8003082:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8003084:	b292      	uxth	r2, r2
 8003086:	2a00      	cmp	r2, #0
 8003088:	d0a2      	beq.n	8002fd0 <HAL_SPI_Transmit+0xe8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 800308a:	6823      	ldr	r3, [r4, #0]
 800308c:	689a      	ldr	r2, [r3, #8]
 800308e:	0792      	lsls	r2, r2, #30
 8003090:	d4ea      	bmi.n	8003068 <HAL_SPI_Transmit+0x180>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8003092:	f7fd fa8d 	bl	80005b0 <HAL_GetTick>
 8003096:	e7df      	b.n	8003058 <HAL_SPI_Transmit+0x170>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8003098:	780a      	ldrb	r2, [r1, #0]
 800309a:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 800309c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 800309e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 80030a0:	3b01      	subs	r3, #1
          hspi->pTxBuffPtr++;
 80030a2:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 80030a4:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 80030a6:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 80030a8:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 80030aa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80030ac:	b29b      	uxth	r3, r3
 80030ae:	2b00      	cmp	r3, #0
 80030b0:	d08e      	beq.n	8002fd0 <HAL_SPI_Transmit+0xe8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80030b2:	6823      	ldr	r3, [r4, #0]
 80030b4:	689a      	ldr	r2, [r3, #8]
 80030b6:	0790      	lsls	r0, r2, #30
 80030b8:	d51e      	bpl.n	80030f8 <HAL_SPI_Transmit+0x210>
        if (hspi->TxXferCount > 1U)
 80030ba:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80030bc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80030be:	2a01      	cmp	r2, #1
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80030c0:	460a      	mov	r2, r1
        if (hspi->TxXferCount > 1U)
 80030c2:	d9e9      	bls.n	8003098 <HAL_SPI_Transmit+0x1b0>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80030c4:	f832 1b02 	ldrh.w	r1, [r2], #2
 80030c8:	60d9      	str	r1, [r3, #12]
          hspi->TxXferCount -= 2U;
 80030ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 80030cc:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 80030ce:	3b02      	subs	r3, #2
 80030d0:	b29b      	uxth	r3, r3
 80030d2:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80030d4:	e7e9      	b.n	80030aa <HAL_SPI_Transmit+0x1c2>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 80030d6:	780a      	ldrb	r2, [r1, #0]
 80030d8:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80030da:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 80030dc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 80030de:	3b01      	subs	r3, #1
          hspi->pTxBuffPtr++;
 80030e0:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 80030e2:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 80030e4:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 80030e6:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80030e8:	e7b6      	b.n	8003058 <HAL_SPI_Transmit+0x170>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80030ea:	f7fd fa61 	bl	80005b0 <HAL_GetTick>
 80030ee:	1b80      	subs	r0, r0, r6
 80030f0:	42a8      	cmp	r0, r5
 80030f2:	d389      	bcc.n	8003008 <HAL_SPI_Transmit+0x120>
          errorcode = HAL_TIMEOUT;
 80030f4:	2003      	movs	r0, #3
 80030f6:	e70e      	b.n	8002f16 <HAL_SPI_Transmit+0x2e>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80030f8:	f7fd fa5a 	bl	80005b0 <HAL_GetTick>
 80030fc:	1b80      	subs	r0, r0, r6
 80030fe:	42a8      	cmp	r0, r5
 8003100:	d2f8      	bcs.n	80030f4 <HAL_SPI_Transmit+0x20c>
 8003102:	e7d2      	b.n	80030aa <HAL_SPI_Transmit+0x1c2>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8003104:	f898 2000 	ldrb.w	r2, [r8]
 8003108:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 800310a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr ++;
 800310c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 800310e:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr ++;
 8003110:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8003112:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr ++;
 8003114:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8003116:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8003118:	e79c      	b.n	8003054 <HAL_SPI_Transmit+0x16c>
 800311a:	bf00      	nop

0800311c <HAL_SPI_TransmitReceive>:
{
 800311c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(hspi);
 8003120:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
{
 8003124:	9d08      	ldr	r5, [sp, #32]
  __HAL_LOCK(hspi);
 8003126:	2c01      	cmp	r4, #1
 8003128:	d028      	beq.n	800317c <HAL_SPI_TransmitReceive+0x60>
 800312a:	461e      	mov	r6, r3
 800312c:	2301      	movs	r3, #1
 800312e:	4604      	mov	r4, r0
 8003130:	4690      	mov	r8, r2
 8003132:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
 8003136:	460f      	mov	r7, r1
  tickstart = HAL_GetTick();
 8003138:	f7fd fa3a 	bl	80005b0 <HAL_GetTick>
 800313c:	4681      	mov	r9, r0
  tmp_state           = hspi->State;
 800313e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  tmp_mode            = hspi->Init.Mode;
 8003142:	6863      	ldr	r3, [r4, #4]
  tmp_state           = hspi->State;
 8003144:	b2c0      	uxtb	r0, r0
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8003146:	2801      	cmp	r0, #1
 8003148:	d010      	beq.n	800316c <HAL_SPI_TransmitReceive+0x50>
 800314a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800314e:	d008      	beq.n	8003162 <HAL_SPI_TransmitReceive+0x46>
    errorcode = HAL_BUSY;
 8003150:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8003152:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8003154:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8003156:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 800315a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 800315e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8003162:	68a2      	ldr	r2, [r4, #8]
 8003164:	2a00      	cmp	r2, #0
 8003166:	d1f3      	bne.n	8003150 <HAL_SPI_TransmitReceive+0x34>
 8003168:	2804      	cmp	r0, #4
 800316a:	d1f1      	bne.n	8003150 <HAL_SPI_TransmitReceive+0x34>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800316c:	f1b8 0f00 	cmp.w	r8, #0
 8003170:	bf18      	it	ne
 8003172:	2f00      	cmpne	r7, #0
 8003174:	d000      	beq.n	8003178 <HAL_SPI_TransmitReceive+0x5c>
 8003176:	b926      	cbnz	r6, 8003182 <HAL_SPI_TransmitReceive+0x66>
    errorcode = HAL_ERROR;
 8003178:	2001      	movs	r0, #1
 800317a:	e7ea      	b.n	8003152 <HAL_SPI_TransmitReceive+0x36>
  __HAL_LOCK(hspi);
 800317c:	2002      	movs	r0, #2
}
 800317e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8003182:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
 8003186:	2a04      	cmp	r2, #4
 8003188:	d002      	beq.n	8003190 <HAL_SPI_TransmitReceive+0x74>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800318a:	2205      	movs	r2, #5
 800318c:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003190:	2200      	movs	r2, #0
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8003192:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8003196:	f8a4 6044 	strh.w	r6, [r4, #68]	; 0x44
 800319a:	4293      	cmp	r3, r2
 800319c:	bf18      	it	ne
 800319e:	2e01      	cmpne	r6, #1
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80031a0:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80031a2:	63a7      	str	r7, [r4, #56]	; 0x38
 80031a4:	bf0c      	ite	eq
 80031a6:	2301      	moveq	r3, #1
 80031a8:	2300      	movne	r3, #0
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 80031aa:	2e01      	cmp	r6, #1
  hspi->RxXferCount = Size;
 80031ac:	f8a4 6046 	strh.w	r6, [r4, #70]	; 0x46
  hspi->TxXferSize  = Size;
 80031b0:	87a6      	strh	r6, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 80031b2:	87e6      	strh	r6, [r4, #62]	; 0x3e
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 80031b4:	68e0      	ldr	r0, [r4, #12]
  hspi->TxISR       = NULL;
 80031b6:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
 80031ba:	6822      	ldr	r2, [r4, #0]
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80031bc:	6851      	ldr	r1, [r2, #4]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 80031be:	d851      	bhi.n	8003264 <HAL_SPI_TransmitReceive+0x148>
 80031c0:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
 80031c4:	d84e      	bhi.n	8003264 <HAL_SPI_TransmitReceive+0x148>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80031c6:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80031ca:	6051      	str	r1, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80031cc:	6811      	ldr	r1, [r2, #0]
 80031ce:	0649      	lsls	r1, r1, #25
 80031d0:	d44f      	bmi.n	8003272 <HAL_SPI_TransmitReceive+0x156>
    __HAL_SPI_ENABLE(hspi);
 80031d2:	6811      	ldr	r1, [r2, #0]
 80031d4:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80031d8:	6011      	str	r1, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80031da:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
 80031de:	d948      	bls.n	8003272 <HAL_SPI_TransmitReceive+0x156>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80031e0:	b13b      	cbz	r3, 80031f2 <HAL_SPI_TransmitReceive+0xd6>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80031e2:	f837 3b02 	ldrh.w	r3, [r7], #2
 80031e6:	60d3      	str	r3, [r2, #12]
      hspi->TxXferCount--;
 80031e8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      hspi->pTxBuffPtr += sizeof(uint16_t);
 80031ea:	63a7      	str	r7, [r4, #56]	; 0x38
      hspi->TxXferCount--;
 80031ec:	3b01      	subs	r3, #1
 80031ee:	b29b      	uxth	r3, r3
 80031f0:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 80031f2:	2601      	movs	r6, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80031f4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80031f6:	b29b      	uxth	r3, r3
 80031f8:	b92b      	cbnz	r3, 8003206 <HAL_SPI_TransmitReceive+0xea>
 80031fa:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80031fe:	b29b      	uxth	r3, r3
 8003200:	2b00      	cmp	r3, #0
 8003202:	f000 8092 	beq.w	800332a <HAL_SPI_TransmitReceive+0x20e>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8003206:	6823      	ldr	r3, [r4, #0]
 8003208:	689a      	ldr	r2, [r3, #8]
 800320a:	0792      	lsls	r2, r2, #30
 800320c:	d50d      	bpl.n	800322a <HAL_SPI_TransmitReceive+0x10e>
 800320e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8003210:	b292      	uxth	r2, r2
 8003212:	b152      	cbz	r2, 800322a <HAL_SPI_TransmitReceive+0x10e>
 8003214:	b14e      	cbz	r6, 800322a <HAL_SPI_TransmitReceive+0x10e>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003216:	6ba1      	ldr	r1, [r4, #56]	; 0x38
        txallowed = 0U;
 8003218:	2600      	movs	r6, #0
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800321a:	f831 2b02 	ldrh.w	r2, [r1], #2
 800321e:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount--;
 8003220:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8003222:	63a1      	str	r1, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8003224:	3a01      	subs	r2, #1
 8003226:	b292      	uxth	r2, r2
 8003228:	87e2      	strh	r2, [r4, #62]	; 0x3e
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800322a:	689a      	ldr	r2, [r3, #8]
 800322c:	07d7      	lsls	r7, r2, #31
 800322e:	d50f      	bpl.n	8003250 <HAL_SPI_TransmitReceive+0x134>
 8003230:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8003234:	b292      	uxth	r2, r2
 8003236:	b15a      	cbz	r2, 8003250 <HAL_SPI_TransmitReceive+0x134>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8003238:	68db      	ldr	r3, [r3, #12]
        txallowed = 1U;
 800323a:	2601      	movs	r6, #1
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800323c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800323e:	f822 3b02 	strh.w	r3, [r2], #2
        hspi->RxXferCount--;
 8003242:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8003246:	6422      	str	r2, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 8003248:	3b01      	subs	r3, #1
 800324a:	b29b      	uxth	r3, r3
 800324c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8003250:	f7fd f9ae 	bl	80005b0 <HAL_GetTick>
 8003254:	eba0 0009 	sub.w	r0, r0, r9
 8003258:	4285      	cmp	r5, r0
 800325a:	d8cb      	bhi.n	80031f4 <HAL_SPI_TransmitReceive+0xd8>
 800325c:	1c68      	adds	r0, r5, #1
 800325e:	d0c9      	beq.n	80031f4 <HAL_SPI_TransmitReceive+0xd8>
        errorcode = HAL_TIMEOUT;
 8003260:	2003      	movs	r0, #3
 8003262:	e776      	b.n	8003152 <HAL_SPI_TransmitReceive+0x36>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003264:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8003268:	6051      	str	r1, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800326a:	6811      	ldr	r1, [r2, #0]
 800326c:	064e      	lsls	r6, r1, #25
 800326e:	d4b4      	bmi.n	80031da <HAL_SPI_TransmitReceive+0xbe>
 8003270:	e7af      	b.n	80031d2 <HAL_SPI_TransmitReceive+0xb6>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8003272:	b153      	cbz	r3, 800328a <HAL_SPI_TransmitReceive+0x16e>
      if (hspi->TxXferCount > 1U)
 8003274:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8003276:	2b01      	cmp	r3, #1
 8003278:	d975      	bls.n	8003366 <HAL_SPI_TransmitReceive+0x24a>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800327a:	f837 3b02 	ldrh.w	r3, [r7], #2
 800327e:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount -= 2U;
 8003280:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8003282:	63a7      	str	r7, [r4, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8003284:	3b02      	subs	r3, #2
 8003286:	b29b      	uxth	r3, r3
 8003288:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 800328a:	2601      	movs	r6, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800328c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800328e:	b29b      	uxth	r3, r3
 8003290:	b923      	cbnz	r3, 800329c <HAL_SPI_TransmitReceive+0x180>
 8003292:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8003296:	b29b      	uxth	r3, r3
 8003298:	2b00      	cmp	r3, #0
 800329a:	d046      	beq.n	800332a <HAL_SPI_TransmitReceive+0x20e>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800329c:	6823      	ldr	r3, [r4, #0]
 800329e:	689a      	ldr	r2, [r3, #8]
 80032a0:	0791      	lsls	r1, r2, #30
 80032a2:	d503      	bpl.n	80032ac <HAL_SPI_TransmitReceive+0x190>
 80032a4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80032a6:	b292      	uxth	r2, r2
 80032a8:	b102      	cbz	r2, 80032ac <HAL_SPI_TransmitReceive+0x190>
 80032aa:	bb86      	cbnz	r6, 800330e <HAL_SPI_TransmitReceive+0x1f2>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80032ac:	689a      	ldr	r2, [r3, #8]
 80032ae:	07d2      	lsls	r2, r2, #31
 80032b0:	d517      	bpl.n	80032e2 <HAL_SPI_TransmitReceive+0x1c6>
 80032b2:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 80032b6:	b292      	uxth	r2, r2
 80032b8:	b19a      	cbz	r2, 80032e2 <HAL_SPI_TransmitReceive+0x1c6>
        if (hspi->RxXferCount > 1U)
 80032ba:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 80032be:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80032c0:	2901      	cmp	r1, #1
 80032c2:	d917      	bls.n	80032f4 <HAL_SPI_TransmitReceive+0x1d8>
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 80032c4:	68d9      	ldr	r1, [r3, #12]
 80032c6:	f822 1b02 	strh.w	r1, [r2], #2
          hspi->RxXferCount -= 2U;
 80032ca:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
          hspi->pRxBuffPtr += sizeof(uint16_t);
 80032ce:	6422      	str	r2, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 80032d0:	1e8a      	subs	r2, r1, #2
 80032d2:	b292      	uxth	r2, r2
 80032d4:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 80032d8:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 80032dc:	2a01      	cmp	r2, #1
 80032de:	d930      	bls.n	8003342 <HAL_SPI_TransmitReceive+0x226>
        txallowed = 1U;
 80032e0:	2601      	movs	r6, #1
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 80032e2:	f7fd f965 	bl	80005b0 <HAL_GetTick>
 80032e6:	eba0 0009 	sub.w	r0, r0, r9
 80032ea:	4285      	cmp	r5, r0
 80032ec:	d8ce      	bhi.n	800328c <HAL_SPI_TransmitReceive+0x170>
 80032ee:	1c6b      	adds	r3, r5, #1
 80032f0:	d0cc      	beq.n	800328c <HAL_SPI_TransmitReceive+0x170>
 80032f2:	e7b5      	b.n	8003260 <HAL_SPI_TransmitReceive+0x144>
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80032f4:	7b1b      	ldrb	r3, [r3, #12]
        txallowed = 1U;
 80032f6:	2601      	movs	r6, #1
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80032f8:	7013      	strb	r3, [r2, #0]
          hspi->RxXferCount--;
 80032fa:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
          hspi->pRxBuffPtr++;
 80032fe:	6c22      	ldr	r2, [r4, #64]	; 0x40
          hspi->RxXferCount--;
 8003300:	3b01      	subs	r3, #1
          hspi->pRxBuffPtr++;
 8003302:	4432      	add	r2, r6
          hspi->RxXferCount--;
 8003304:	b29b      	uxth	r3, r3
          hspi->pRxBuffPtr++;
 8003306:	6422      	str	r2, [r4, #64]	; 0x40
          hspi->RxXferCount--;
 8003308:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 800330c:	e7e9      	b.n	80032e2 <HAL_SPI_TransmitReceive+0x1c6>
        if (hspi->TxXferCount > 1U)
 800330e:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 8003310:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8003312:	2901      	cmp	r1, #1
 8003314:	d91b      	bls.n	800334e <HAL_SPI_TransmitReceive+0x232>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003316:	f832 1b02 	ldrh.w	r1, [r2], #2
        txallowed = 0U;
 800331a:	2600      	movs	r6, #0
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800331c:	60d9      	str	r1, [r3, #12]
          hspi->TxXferCount -= 2U;
 800331e:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8003320:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 8003322:	1e8a      	subs	r2, r1, #2
 8003324:	b292      	uxth	r2, r2
 8003326:	87e2      	strh	r2, [r4, #62]	; 0x3e
 8003328:	e7c0      	b.n	80032ac <HAL_SPI_TransmitReceive+0x190>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800332a:	464a      	mov	r2, r9
 800332c:	4629      	mov	r1, r5
 800332e:	4620      	mov	r0, r4
 8003330:	f7ff fd14 	bl	8002d5c <SPI_EndRxTxTransaction>
 8003334:	2800      	cmp	r0, #0
 8003336:	f43f af0c 	beq.w	8003152 <HAL_SPI_TransmitReceive+0x36>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800333a:	2320      	movs	r3, #32
    errorcode = HAL_ERROR;
 800333c:	2001      	movs	r0, #1
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800333e:	6623      	str	r3, [r4, #96]	; 0x60
 8003340:	e707      	b.n	8003152 <HAL_SPI_TransmitReceive+0x36>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003342:	685a      	ldr	r2, [r3, #4]
        txallowed = 1U;
 8003344:	2601      	movs	r6, #1
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003346:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800334a:	605a      	str	r2, [r3, #4]
 800334c:	e7c9      	b.n	80032e2 <HAL_SPI_TransmitReceive+0x1c6>
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800334e:	7812      	ldrb	r2, [r2, #0]
        txallowed = 0U;
 8003350:	2600      	movs	r6, #0
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8003352:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8003354:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8003356:	6ba1      	ldr	r1, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8003358:	3a01      	subs	r2, #1
 800335a:	6823      	ldr	r3, [r4, #0]
          hspi->pTxBuffPtr++;
 800335c:	3101      	adds	r1, #1
          hspi->TxXferCount--;
 800335e:	b292      	uxth	r2, r2
          hspi->pTxBuffPtr++;
 8003360:	63a1      	str	r1, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8003362:	87e2      	strh	r2, [r4, #62]	; 0x3e
 8003364:	e7a2      	b.n	80032ac <HAL_SPI_TransmitReceive+0x190>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8003366:	783b      	ldrb	r3, [r7, #0]
 8003368:	7313      	strb	r3, [r2, #12]
        hspi->TxXferCount--;
 800336a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr++;
 800336c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 800336e:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr++;
 8003370:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8003372:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr++;
 8003374:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8003376:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8003378:	e787      	b.n	800328a <HAL_SPI_TransmitReceive+0x16e>
 800337a:	bf00      	nop

0800337c <HAL_SPI_ErrorCallback>:
 800337c:	4770      	bx	lr
 800337e:	bf00      	nop

08003380 <HAL_SPI_IRQHandler>:
{
 8003380:	b570      	push	{r4, r5, r6, lr}
  uint32_t itsource = hspi->Instance->CR2;
 8003382:	6805      	ldr	r5, [r0, #0]
{
 8003384:	b084      	sub	sp, #16
 8003386:	4604      	mov	r4, r0
  uint32_t itsource = hspi->Instance->CR2;
 8003388:	686e      	ldr	r6, [r5, #4]
  uint32_t itflag   = hspi->Instance->SR;
 800338a:	68ab      	ldr	r3, [r5, #8]
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 800338c:	f3c3 1180 	ubfx	r1, r3, #6, #1
 8003390:	b941      	cbnz	r1, 80033a4 <HAL_SPI_IRQHandler+0x24>
 8003392:	07da      	lsls	r2, r3, #31
 8003394:	d506      	bpl.n	80033a4 <HAL_SPI_IRQHandler+0x24>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8003396:	0672      	lsls	r2, r6, #25
 8003398:	d504      	bpl.n	80033a4 <HAL_SPI_IRQHandler+0x24>
    hspi->RxISR(hspi);
 800339a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
}
 800339c:	b004      	add	sp, #16
 800339e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hspi->TxISR(hspi);
 80033a2:	4718      	bx	r3
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 80033a4:	0798      	lsls	r0, r3, #30
 80033a6:	d507      	bpl.n	80033b8 <HAL_SPI_IRQHandler+0x38>
 80033a8:	0632      	lsls	r2, r6, #24
 80033aa:	d505      	bpl.n	80033b8 <HAL_SPI_IRQHandler+0x38>
    hspi->TxISR(hspi);
 80033ac:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80033ae:	4620      	mov	r0, r4
}
 80033b0:	b004      	add	sp, #16
 80033b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hspi->TxISR(hspi);
 80033b6:	4718      	bx	r3
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 80033b8:	f3c3 1040 	ubfx	r0, r3, #5, #1
 80033bc:	2800      	cmp	r0, #0
 80033be:	d13e      	bne.n	800343e <HAL_SPI_IRQHandler+0xbe>
 80033c0:	2900      	cmp	r1, #0
 80033c2:	d04f      	beq.n	8003464 <HAL_SPI_IRQHandler+0xe4>
 80033c4:	06b2      	lsls	r2, r6, #26
 80033c6:	d538      	bpl.n	800343a <HAL_SPI_IRQHandler+0xba>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 80033c8:	f894 105d 	ldrb.w	r1, [r4, #93]	; 0x5d
 80033cc:	2903      	cmp	r1, #3
 80033ce:	d05b      	beq.n	8003488 <HAL_SPI_IRQHandler+0x108>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80033d0:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80033d2:	f3c3 2300 	ubfx	r3, r3, #8, #1
 80033d6:	f041 0104 	orr.w	r1, r1, #4
 80033da:	6621      	str	r1, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80033dc:	9000      	str	r0, [sp, #0]
 80033de:	68e9      	ldr	r1, [r5, #12]
 80033e0:	9100      	str	r1, [sp, #0]
 80033e2:	68a9      	ldr	r1, [r5, #8]
 80033e4:	9100      	str	r1, [sp, #0]
 80033e6:	9900      	ldr	r1, [sp, #0]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 80033e8:	2b00      	cmp	r3, #0
 80033ea:	d13f      	bne.n	800346c <HAL_SPI_IRQHandler+0xec>
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80033ec:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80033ee:	b323      	cbz	r3, 800343a <HAL_SPI_IRQHandler+0xba>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 80033f0:	686b      	ldr	r3, [r5, #4]
      hspi->State = HAL_SPI_STATE_READY;
 80033f2:	2201      	movs	r2, #1
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 80033f4:	07b1      	lsls	r1, r6, #30
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 80033f6:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80033fa:	606b      	str	r3, [r5, #4]
      hspi->State = HAL_SPI_STATE_READY;
 80033fc:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8003400:	d04a      	beq.n	8003498 <HAL_SPI_IRQHandler+0x118>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8003402:	686b      	ldr	r3, [r5, #4]
        if (hspi->hdmarx != NULL)
 8003404:	6da2      	ldr	r2, [r4, #88]	; 0x58
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8003406:	f023 0303 	bic.w	r3, r3, #3
 800340a:	606b      	str	r3, [r5, #4]
        if (hspi->hdmarx != NULL)
 800340c:	b14a      	cbz	r2, 8003422 <HAL_SPI_IRQHandler+0xa2>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 800340e:	4b2b      	ldr	r3, [pc, #172]	; (80034bc <HAL_SPI_IRQHandler+0x13c>)
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8003410:	4610      	mov	r0, r2
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8003412:	6513      	str	r3, [r2, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8003414:	f7fe fa60 	bl	80018d8 <HAL_DMA_Abort_IT>
 8003418:	b118      	cbz	r0, 8003422 <HAL_SPI_IRQHandler+0xa2>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 800341a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800341c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003420:	6623      	str	r3, [r4, #96]	; 0x60
        if (hspi->hdmatx != NULL)
 8003422:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8003424:	b14b      	cbz	r3, 800343a <HAL_SPI_IRQHandler+0xba>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8003426:	4a25      	ldr	r2, [pc, #148]	; (80034bc <HAL_SPI_IRQHandler+0x13c>)
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 8003428:	4618      	mov	r0, r3
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 800342a:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 800342c:	f7fe fa54 	bl	80018d8 <HAL_DMA_Abort_IT>
 8003430:	b118      	cbz	r0, 800343a <HAL_SPI_IRQHandler+0xba>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8003432:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8003434:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003438:	6623      	str	r3, [r4, #96]	; 0x60
}
 800343a:	b004      	add	sp, #16
 800343c:	bd70      	pop	{r4, r5, r6, pc}
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 800343e:	06b0      	lsls	r0, r6, #26
 8003440:	d5fb      	bpl.n	800343a <HAL_SPI_IRQHandler+0xba>
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8003442:	b9e9      	cbnz	r1, 8003480 <HAL_SPI_IRQHandler+0x100>
 8003444:	f3c3 2300 	ubfx	r3, r3, #8, #1
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8003448:	6e21      	ldr	r1, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800344a:	2000      	movs	r0, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 800344c:	f041 0101 	orr.w	r1, r1, #1
 8003450:	6621      	str	r1, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8003452:	9002      	str	r0, [sp, #8]
 8003454:	68a9      	ldr	r1, [r5, #8]
 8003456:	9102      	str	r1, [sp, #8]
 8003458:	6829      	ldr	r1, [r5, #0]
 800345a:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800345e:	6029      	str	r1, [r5, #0]
 8003460:	9902      	ldr	r1, [sp, #8]
 8003462:	e7c1      	b.n	80033e8 <HAL_SPI_IRQHandler+0x68>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8003464:	05db      	lsls	r3, r3, #23
 8003466:	d5e8      	bpl.n	800343a <HAL_SPI_IRQHandler+0xba>
 8003468:	06b3      	lsls	r3, r6, #26
 800346a:	d5e6      	bpl.n	800343a <HAL_SPI_IRQHandler+0xba>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 800346c:	6e23      	ldr	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800346e:	2100      	movs	r1, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8003470:	f043 0308 	orr.w	r3, r3, #8
 8003474:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8003476:	9103      	str	r1, [sp, #12]
 8003478:	68ab      	ldr	r3, [r5, #8]
 800347a:	9303      	str	r3, [sp, #12]
 800347c:	9b03      	ldr	r3, [sp, #12]
 800347e:	e7b5      	b.n	80033ec <HAL_SPI_IRQHandler+0x6c>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8003480:	f894 105d 	ldrb.w	r1, [r4, #93]	; 0x5d
 8003484:	2903      	cmp	r1, #3
 8003486:	d10b      	bne.n	80034a0 <HAL_SPI_IRQHandler+0x120>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8003488:	2300      	movs	r3, #0
 800348a:	9301      	str	r3, [sp, #4]
 800348c:	68eb      	ldr	r3, [r5, #12]
 800348e:	9301      	str	r3, [sp, #4]
 8003490:	68ab      	ldr	r3, [r5, #8]
 8003492:	9301      	str	r3, [sp, #4]
 8003494:	9b01      	ldr	r3, [sp, #4]
        return;
 8003496:	e7d0      	b.n	800343a <HAL_SPI_IRQHandler+0xba>
        HAL_SPI_ErrorCallback(hspi);
 8003498:	4620      	mov	r0, r4
 800349a:	f7ff ff6f 	bl	800337c <HAL_SPI_ErrorCallback>
 800349e:	e7cc      	b.n	800343a <HAL_SPI_IRQHandler+0xba>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80034a0:	6e21      	ldr	r1, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80034a2:	2000      	movs	r0, #0
 80034a4:	f3c3 2300 	ubfx	r3, r3, #8, #1
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80034a8:	f041 0104 	orr.w	r1, r1, #4
 80034ac:	6621      	str	r1, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80034ae:	9000      	str	r0, [sp, #0]
 80034b0:	68e9      	ldr	r1, [r5, #12]
 80034b2:	9100      	str	r1, [sp, #0]
 80034b4:	68a9      	ldr	r1, [r5, #8]
 80034b6:	9100      	str	r1, [sp, #0]
 80034b8:	9900      	ldr	r1, [sp, #0]
 80034ba:	e7c5      	b.n	8003448 <HAL_SPI_IRQHandler+0xc8>
 80034bc:	080034c1 	.word	0x080034c1

080034c0 <SPI_DMAAbortOnError>:
{
 80034c0:	b508      	push	{r3, lr}
  hspi->RxXferCount = 0U;
 80034c2:	2200      	movs	r2, #0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 80034c4:	6b83      	ldr	r3, [r0, #56]	; 0x38
  hspi->RxXferCount = 0U;
 80034c6:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  HAL_SPI_ErrorCallback(hspi);
 80034ca:	4618      	mov	r0, r3
  hspi->TxXferCount = 0U;
 80034cc:	87da      	strh	r2, [r3, #62]	; 0x3e
  HAL_SPI_ErrorCallback(hspi);
 80034ce:	f7ff ff55 	bl	800337c <HAL_SPI_ErrorCallback>
}
 80034d2:	bd08      	pop	{r3, pc}

080034d4 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80034d4:	2800      	cmp	r0, #0
 80034d6:	d065      	beq.n	80035a4 <HAL_TIM_Base_Init+0xd0>
{
 80034d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80034da:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80034de:	4604      	mov	r4, r0
 80034e0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80034e4:	2b00      	cmp	r3, #0
 80034e6:	d03b      	beq.n	8003560 <HAL_TIM_Base_Init+0x8c>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80034e8:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80034ea:	2002      	movs	r0, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80034ec:	4e36      	ldr	r6, [pc, #216]	; (80035c8 <HAL_TIM_Base_Init+0xf4>)
 80034ee:	4f37      	ldr	r7, [pc, #220]	; (80035cc <HAL_TIM_Base_Init+0xf8>)
 80034f0:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80034f4:	eba2 0606 	sub.w	r6, r2, r6
  htim->State = HAL_TIM_STATE_BUSY;
 80034f8:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 80034fc:	eba2 0707 	sub.w	r7, r2, r7
  tmpcr1 = TIMx->CR1;
 8003500:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8003502:	fab6 f686 	clz	r6, r6
 8003506:	fab7 f787 	clz	r7, r7
 800350a:	ea4f 1656 	mov.w	r6, r6, lsr #5
 800350e:	ea4f 1757 	mov.w	r7, r7, lsr #5
 8003512:	d02a      	beq.n	800356a <HAL_TIM_Base_Init+0x96>
 8003514:	bb4e      	cbnz	r6, 800356a <HAL_TIM_Base_Init+0x96>
 8003516:	492e      	ldr	r1, [pc, #184]	; (80035d0 <HAL_TIM_Base_Init+0xfc>)
 8003518:	428a      	cmp	r2, r1
 800351a:	d045      	beq.n	80035a8 <HAL_TIM_Base_Init+0xd4>
 800351c:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003520:	428a      	cmp	r2, r1
 8003522:	d041      	beq.n	80035a8 <HAL_TIM_Base_Init+0xd4>
 8003524:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003528:	428a      	cmp	r2, r1
 800352a:	d042      	beq.n	80035b2 <HAL_TIM_Base_Init+0xde>
 800352c:	2f00      	cmp	r7, #0
 800352e:	d140      	bne.n	80035b2 <HAL_TIM_Base_Init+0xde>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8003530:	4928      	ldr	r1, [pc, #160]	; (80035d4 <HAL_TIM_Base_Init+0x100>)
 8003532:	428a      	cmp	r2, r1
 8003534:	d01e      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 8003536:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800353a:	428a      	cmp	r2, r1
 800353c:	d01a      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 800353e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003542:	428a      	cmp	r2, r1
 8003544:	d016      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 8003546:	f5a1 3198 	sub.w	r1, r1, #77824	; 0x13000
 800354a:	428a      	cmp	r2, r1
 800354c:	d012      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 800354e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003552:	428a      	cmp	r2, r1
 8003554:	d00e      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 8003556:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800355a:	428a      	cmp	r2, r1
 800355c:	d10e      	bne.n	800357c <HAL_TIM_Base_Init+0xa8>
 800355e:	e009      	b.n	8003574 <HAL_TIM_Base_Init+0xa0>
    htim->Lock = HAL_UNLOCKED;
 8003560:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8003564:	f002 ffe2 	bl	800652c <HAL_TIM_Base_MspInit>
 8003568:	e7be      	b.n	80034e8 <HAL_TIM_Base_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800356a:	f023 0570 	bic.w	r5, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800356e:	68a0      	ldr	r0, [r4, #8]
 8003570:	ea45 0300 	orr.w	r3, r5, r0
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8003574:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8003578:	6920      	ldr	r0, [r4, #16]
 800357a:	4303      	orrs	r3, r0
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800357c:	69a1      	ldr	r1, [r4, #24]
 800357e:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8003582:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8003584:	430b      	orrs	r3, r1

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8003586:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8003588:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800358a:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800358c:	6291      	str	r1, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800358e:	b936      	cbnz	r6, 800359e <HAL_TIM_Base_Init+0xca>
 8003590:	b92f      	cbnz	r7, 800359e <HAL_TIM_Base_Init+0xca>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8003592:	2301      	movs	r3, #1
  return HAL_OK;
 8003594:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 8003596:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 8003598:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800359c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 800359e:	6963      	ldr	r3, [r4, #20]
 80035a0:	6313      	str	r3, [r2, #48]	; 0x30
 80035a2:	e7f6      	b.n	8003592 <HAL_TIM_Base_Init+0xbe>
    return HAL_ERROR;
 80035a4:	2001      	movs	r0, #1
}
 80035a6:	4770      	bx	lr
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80035a8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80035ac:	68a1      	ldr	r1, [r4, #8]
 80035ae:	430b      	orrs	r3, r1
 80035b0:	e7e0      	b.n	8003574 <HAL_TIM_Base_Init+0xa0>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80035b2:	4909      	ldr	r1, [pc, #36]	; (80035d8 <HAL_TIM_Base_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80035b4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80035b8:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80035ba:	428a      	cmp	r2, r1
    tmpcr1 |= Structure->CounterMode;
 80035bc:	ea43 0300 	orr.w	r3, r3, r0
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80035c0:	d0d8      	beq.n	8003574 <HAL_TIM_Base_Init+0xa0>
 80035c2:	2f00      	cmp	r7, #0
 80035c4:	d1d6      	bne.n	8003574 <HAL_TIM_Base_Init+0xa0>
 80035c6:	e7b3      	b.n	8003530 <HAL_TIM_Base_Init+0x5c>
 80035c8:	40010000 	.word	0x40010000
 80035cc:	40010400 	.word	0x40010400
 80035d0:	40000400 	.word	0x40000400
 80035d4:	40014000 	.word	0x40014000
 80035d8:	40000c00 	.word	0x40000c00

080035dc <HAL_TIM_Base_Start>:
{
 80035dc:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 80035de:	2002      	movs	r0, #2
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80035e0:	4b09      	ldr	r3, [pc, #36]	; (8003608 <HAL_TIM_Base_Start+0x2c>)
 80035e2:	6811      	ldr	r1, [r2, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80035e4:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80035e8:	6888      	ldr	r0, [r1, #8]
 80035ea:	4003      	ands	r3, r0
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80035ec:	2b06      	cmp	r3, #6
 80035ee:	d006      	beq.n	80035fe <HAL_TIM_Base_Start+0x22>
 80035f0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80035f4:	d003      	beq.n	80035fe <HAL_TIM_Base_Start+0x22>
    __HAL_TIM_ENABLE(htim);
 80035f6:	680b      	ldr	r3, [r1, #0]
 80035f8:	f043 0301 	orr.w	r3, r3, #1
 80035fc:	600b      	str	r3, [r1, #0]
  htim->State = HAL_TIM_STATE_READY;
 80035fe:	2301      	movs	r3, #1
}
 8003600:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8003602:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
}
 8003606:	4770      	bx	lr
 8003608:	00010007 	.word	0x00010007

0800360c <HAL_TIM_Base_Stop>:
{
 800360c:	4603      	mov	r3, r0
  htim->State = HAL_TIM_STATE_BUSY;
 800360e:	2002      	movs	r0, #2
  __HAL_TIM_DISABLE(htim);
 8003610:	f241 1111 	movw	r1, #4369	; 0x1111
 8003614:	681a      	ldr	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8003616:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 800361a:	6a10      	ldr	r0, [r2, #32]
 800361c:	4208      	tst	r0, r1
 800361e:	d108      	bne.n	8003632 <HAL_TIM_Base_Stop+0x26>
 8003620:	6a10      	ldr	r0, [r2, #32]
 8003622:	f240 4144 	movw	r1, #1092	; 0x444
 8003626:	4208      	tst	r0, r1
 8003628:	d103      	bne.n	8003632 <HAL_TIM_Base_Stop+0x26>
 800362a:	6811      	ldr	r1, [r2, #0]
 800362c:	f021 0101 	bic.w	r1, r1, #1
 8003630:	6011      	str	r1, [r2, #0]
  htim->State = HAL_TIM_STATE_READY;
 8003632:	2201      	movs	r2, #1
}
 8003634:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8003636:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
}
 800363a:	4770      	bx	lr

0800363c <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800363c:	6803      	ldr	r3, [r0, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800363e:	4a09      	ldr	r2, [pc, #36]	; (8003664 <HAL_TIM_Base_Start_IT+0x28>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8003640:	68d9      	ldr	r1, [r3, #12]
 8003642:	f041 0101 	orr.w	r1, r1, #1
 8003646:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8003648:	6899      	ldr	r1, [r3, #8]
 800364a:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800364c:	2a06      	cmp	r2, #6
 800364e:	d006      	beq.n	800365e <HAL_TIM_Base_Start_IT+0x22>
 8003650:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8003654:	d003      	beq.n	800365e <HAL_TIM_Base_Start_IT+0x22>
    __HAL_TIM_ENABLE(htim);
 8003656:	681a      	ldr	r2, [r3, #0]
 8003658:	f042 0201 	orr.w	r2, r2, #1
 800365c:	601a      	str	r2, [r3, #0]
}
 800365e:	2000      	movs	r0, #0
 8003660:	4770      	bx	lr
 8003662:	bf00      	nop
 8003664:	00010007 	.word	0x00010007

08003668 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8003668:	6803      	ldr	r3, [r0, #0]
  __HAL_TIM_DISABLE(htim);
 800366a:	f241 1111 	movw	r1, #4369	; 0x1111
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 800366e:	68da      	ldr	r2, [r3, #12]
 8003670:	f022 0201 	bic.w	r2, r2, #1
 8003674:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8003676:	6a1a      	ldr	r2, [r3, #32]
 8003678:	420a      	tst	r2, r1
 800367a:	d108      	bne.n	800368e <HAL_TIM_Base_Stop_IT+0x26>
 800367c:	6a19      	ldr	r1, [r3, #32]
 800367e:	f240 4244 	movw	r2, #1092	; 0x444
 8003682:	4211      	tst	r1, r2
 8003684:	d103      	bne.n	800368e <HAL_TIM_Base_Stop_IT+0x26>
 8003686:	681a      	ldr	r2, [r3, #0]
 8003688:	f022 0201 	bic.w	r2, r2, #1
 800368c:	601a      	str	r2, [r3, #0]
}
 800368e:	2000      	movs	r0, #0
 8003690:	4770      	bx	lr
 8003692:	bf00      	nop

08003694 <HAL_TIM_PWM_MspInit>:
 8003694:	4770      	bx	lr
 8003696:	bf00      	nop

08003698 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8003698:	2800      	cmp	r0, #0
 800369a:	d065      	beq.n	8003768 <HAL_TIM_PWM_Init+0xd0>
{
 800369c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800369e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80036a2:	4604      	mov	r4, r0
 80036a4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80036a8:	2b00      	cmp	r3, #0
 80036aa:	d03b      	beq.n	8003724 <HAL_TIM_PWM_Init+0x8c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80036ac:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80036ae:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80036b0:	4e36      	ldr	r6, [pc, #216]	; (800378c <HAL_TIM_PWM_Init+0xf4>)
 80036b2:	4f37      	ldr	r7, [pc, #220]	; (8003790 <HAL_TIM_PWM_Init+0xf8>)
 80036b4:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80036b8:	eba2 0606 	sub.w	r6, r2, r6
  htim->State = HAL_TIM_STATE_BUSY;
 80036bc:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 80036c0:	eba2 0707 	sub.w	r7, r2, r7
  tmpcr1 = TIMx->CR1;
 80036c4:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80036c6:	fab6 f686 	clz	r6, r6
 80036ca:	fab7 f787 	clz	r7, r7
 80036ce:	ea4f 1656 	mov.w	r6, r6, lsr #5
 80036d2:	ea4f 1757 	mov.w	r7, r7, lsr #5
 80036d6:	d02a      	beq.n	800372e <HAL_TIM_PWM_Init+0x96>
 80036d8:	bb4e      	cbnz	r6, 800372e <HAL_TIM_PWM_Init+0x96>
 80036da:	492e      	ldr	r1, [pc, #184]	; (8003794 <HAL_TIM_PWM_Init+0xfc>)
 80036dc:	428a      	cmp	r2, r1
 80036de:	d045      	beq.n	800376c <HAL_TIM_PWM_Init+0xd4>
 80036e0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80036e4:	428a      	cmp	r2, r1
 80036e6:	d041      	beq.n	800376c <HAL_TIM_PWM_Init+0xd4>
 80036e8:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80036ec:	428a      	cmp	r2, r1
 80036ee:	d042      	beq.n	8003776 <HAL_TIM_PWM_Init+0xde>
 80036f0:	2f00      	cmp	r7, #0
 80036f2:	d140      	bne.n	8003776 <HAL_TIM_PWM_Init+0xde>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80036f4:	4928      	ldr	r1, [pc, #160]	; (8003798 <HAL_TIM_PWM_Init+0x100>)
 80036f6:	428a      	cmp	r2, r1
 80036f8:	d01e      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 80036fa:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80036fe:	428a      	cmp	r2, r1
 8003700:	d01a      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 8003702:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003706:	428a      	cmp	r2, r1
 8003708:	d016      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 800370a:	f5a1 3198 	sub.w	r1, r1, #77824	; 0x13000
 800370e:	428a      	cmp	r2, r1
 8003710:	d012      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 8003712:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8003716:	428a      	cmp	r2, r1
 8003718:	d00e      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 800371a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800371e:	428a      	cmp	r2, r1
 8003720:	d10e      	bne.n	8003740 <HAL_TIM_PWM_Init+0xa8>
 8003722:	e009      	b.n	8003738 <HAL_TIM_PWM_Init+0xa0>
    htim->Lock = HAL_UNLOCKED;
 8003724:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8003728:	f7ff ffb4 	bl	8003694 <HAL_TIM_PWM_MspInit>
 800372c:	e7be      	b.n	80036ac <HAL_TIM_PWM_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800372e:	f023 0570 	bic.w	r5, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8003732:	68a0      	ldr	r0, [r4, #8]
 8003734:	ea45 0300 	orr.w	r3, r5, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8003738:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800373c:	6920      	ldr	r0, [r4, #16]
 800373e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8003740:	69a1      	ldr	r1, [r4, #24]
 8003742:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8003746:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8003748:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 800374a:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 800374c:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800374e:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8003750:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8003752:	b936      	cbnz	r6, 8003762 <HAL_TIM_PWM_Init+0xca>
 8003754:	b92f      	cbnz	r7, 8003762 <HAL_TIM_PWM_Init+0xca>
  TIMx->EGR = TIM_EGR_UG;
 8003756:	2301      	movs	r3, #1
  return HAL_OK;
 8003758:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800375a:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800375c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8003760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 8003762:	6963      	ldr	r3, [r4, #20]
 8003764:	6313      	str	r3, [r2, #48]	; 0x30
 8003766:	e7f6      	b.n	8003756 <HAL_TIM_PWM_Init+0xbe>
    return HAL_ERROR;
 8003768:	2001      	movs	r0, #1
}
 800376a:	4770      	bx	lr
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800376c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8003770:	68a1      	ldr	r1, [r4, #8]
 8003772:	430b      	orrs	r3, r1
 8003774:	e7e0      	b.n	8003738 <HAL_TIM_PWM_Init+0xa0>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8003776:	4909      	ldr	r1, [pc, #36]	; (800379c <HAL_TIM_PWM_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8003778:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800377c:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800377e:	428a      	cmp	r2, r1
    tmpcr1 |= Structure->CounterMode;
 8003780:	ea43 0300 	orr.w	r3, r3, r0
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8003784:	d0d8      	beq.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 8003786:	2f00      	cmp	r7, #0
 8003788:	d1d6      	bne.n	8003738 <HAL_TIM_PWM_Init+0xa0>
 800378a:	e7b3      	b.n	80036f4 <HAL_TIM_PWM_Init+0x5c>
 800378c:	40010000 	.word	0x40010000
 8003790:	40010400 	.word	0x40010400
 8003794:	40000400 	.word	0x40000400
 8003798:	40014000 	.word	0x40014000
 800379c:	40000c00 	.word	0x40000c00

080037a0 <HAL_TIM_PWM_Start>:
 80037a0:	6803      	ldr	r3, [r0, #0]
 80037a2:	2201      	movs	r2, #1
 80037a4:	f001 011f 	and.w	r1, r1, #31
 80037a8:	6a18      	ldr	r0, [r3, #32]
 80037aa:	fa02 f101 	lsl.w	r1, r2, r1
 80037ae:	ea20 0001 	bic.w	r0, r0, r1
 80037b2:	b410      	push	{r4}
 80037b4:	6218      	str	r0, [r3, #32]
 80037b6:	4c0f      	ldr	r4, [pc, #60]	; (80037f4 <HAL_TIM_PWM_Start+0x54>)
 80037b8:	6a1a      	ldr	r2, [r3, #32]
 80037ba:	42a3      	cmp	r3, r4
 80037bc:	ea41 0102 	orr.w	r1, r1, r2
 80037c0:	6219      	str	r1, [r3, #32]
 80037c2:	d012      	beq.n	80037ea <HAL_TIM_PWM_Start+0x4a>
 80037c4:	4a0c      	ldr	r2, [pc, #48]	; (80037f8 <HAL_TIM_PWM_Start+0x58>)
 80037c6:	4293      	cmp	r3, r2
 80037c8:	d00f      	beq.n	80037ea <HAL_TIM_PWM_Start+0x4a>
 80037ca:	6899      	ldr	r1, [r3, #8]
 80037cc:	4a0b      	ldr	r2, [pc, #44]	; (80037fc <HAL_TIM_PWM_Start+0x5c>)
 80037ce:	400a      	ands	r2, r1
 80037d0:	2a06      	cmp	r2, #6
 80037d2:	d006      	beq.n	80037e2 <HAL_TIM_PWM_Start+0x42>
 80037d4:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80037d8:	d003      	beq.n	80037e2 <HAL_TIM_PWM_Start+0x42>
 80037da:	681a      	ldr	r2, [r3, #0]
 80037dc:	f042 0201 	orr.w	r2, r2, #1
 80037e0:	601a      	str	r2, [r3, #0]
 80037e2:	2000      	movs	r0, #0
 80037e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80037e8:	4770      	bx	lr
 80037ea:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80037ec:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80037f0:	645a      	str	r2, [r3, #68]	; 0x44
 80037f2:	e7ea      	b.n	80037ca <HAL_TIM_PWM_Start+0x2a>
 80037f4:	40010000 	.word	0x40010000
 80037f8:	40010400 	.word	0x40010400
 80037fc:	00010007 	.word	0x00010007

08003800 <HAL_TIM_PWM_Stop>:
{
 8003800:	b410      	push	{r4}
 8003802:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8003804:	f001 011f 	and.w	r1, r1, #31
 8003808:	2201      	movs	r2, #1
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800380a:	4819      	ldr	r0, [pc, #100]	; (8003870 <HAL_TIM_PWM_Stop+0x70>)
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800380c:	6823      	ldr	r3, [r4, #0]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800380e:	408a      	lsls	r2, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8003810:	6a19      	ldr	r1, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8003812:	4283      	cmp	r3, r0
  TIMx->CCER &= ~tmp;
 8003814:	ea21 0102 	bic.w	r1, r1, r2
 8003818:	6219      	str	r1, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800381a:	6a1a      	ldr	r2, [r3, #32]
 800381c:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800381e:	d017      	beq.n	8003850 <HAL_TIM_PWM_Stop+0x50>
 8003820:	4a14      	ldr	r2, [pc, #80]	; (8003874 <HAL_TIM_PWM_Stop+0x74>)
 8003822:	4293      	cmp	r3, r2
 8003824:	d014      	beq.n	8003850 <HAL_TIM_PWM_Stop+0x50>
  __HAL_TIM_DISABLE(htim);
 8003826:	6a19      	ldr	r1, [r3, #32]
 8003828:	f241 1211 	movw	r2, #4369	; 0x1111
 800382c:	4211      	tst	r1, r2
 800382e:	d108      	bne.n	8003842 <HAL_TIM_PWM_Stop+0x42>
 8003830:	6a19      	ldr	r1, [r3, #32]
 8003832:	f240 4244 	movw	r2, #1092	; 0x444
 8003836:	4211      	tst	r1, r2
 8003838:	d103      	bne.n	8003842 <HAL_TIM_PWM_Stop+0x42>
 800383a:	681a      	ldr	r2, [r3, #0]
 800383c:	f022 0201 	bic.w	r2, r2, #1
 8003840:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8003842:	2301      	movs	r3, #1
}
 8003844:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8003846:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800384a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800384e:	4770      	bx	lr
    __HAL_TIM_MOE_DISABLE(htim);
 8003850:	6a19      	ldr	r1, [r3, #32]
 8003852:	f241 1211 	movw	r2, #4369	; 0x1111
 8003856:	4211      	tst	r1, r2
 8003858:	d1e5      	bne.n	8003826 <HAL_TIM_PWM_Stop+0x26>
 800385a:	6a19      	ldr	r1, [r3, #32]
 800385c:	f240 4244 	movw	r2, #1092	; 0x444
 8003860:	4211      	tst	r1, r2
 8003862:	d1e0      	bne.n	8003826 <HAL_TIM_PWM_Stop+0x26>
 8003864:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003866:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800386a:	645a      	str	r2, [r3, #68]	; 0x44
 800386c:	e7db      	b.n	8003826 <HAL_TIM_PWM_Stop+0x26>
 800386e:	bf00      	nop
 8003870:	40010000 	.word	0x40010000
 8003874:	40010400 	.word	0x40010400

08003878 <HAL_TIM_PWM_ConfigChannel>:
{
 8003878:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 800387a:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 800387e:	2801      	cmp	r0, #1
 8003880:	f000 813e 	beq.w	8003b00 <HAL_TIM_PWM_ConfigChannel+0x288>
  htim->State = HAL_TIM_STATE_BUSY;
 8003884:	2002      	movs	r0, #2
{
 8003886:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 8003888:	2401      	movs	r4, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800388a:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
  __HAL_LOCK(htim);
 800388e:	f883 403c 	strb.w	r4, [r3, #60]	; 0x3c
  switch (Channel)
 8003892:	2a14      	cmp	r2, #20
 8003894:	d843      	bhi.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
 8003896:	e8df f012 	tbh	[pc, r2, lsl #1]
 800389a:	0015      	.short	0x0015
 800389c:	00420042 	.word	0x00420042
 80038a0:	007b0042 	.word	0x007b0042
 80038a4:	00420042 	.word	0x00420042
 80038a8:	00da0042 	.word	0x00da0042
 80038ac:	00420042 	.word	0x00420042
 80038b0:	00aa0042 	.word	0x00aa0042
 80038b4:	00420042 	.word	0x00420042
 80038b8:	01060042 	.word	0x01060042
 80038bc:	00420042 	.word	0x00420042
 80038c0:	004b0042 	.word	0x004b0042
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80038c4:	681a      	ldr	r2, [r3, #0]
  tmpccer |= OC_Config->OCPolarity;
 80038c6:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80038ca:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 80038cc:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80038ce:	f025 0501 	bic.w	r5, r5, #1
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80038d2:	4cab      	ldr	r4, [pc, #684]	; (8003b80 <HAL_TIM_PWM_ConfigChannel+0x308>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80038d4:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 80038d6:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 80038d8:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 80038da:	6995      	ldr	r5, [r2, #24]
  tmpccer &= ~TIM_CCER_CC1P;
 80038dc:	f020 0002 	bic.w	r0, r0, #2
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80038e0:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80038e2:	4da8      	ldr	r5, [pc, #672]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= OC_Config->OCPolarity;
 80038e4:	ea40 000c 	orr.w	r0, r0, ip
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80038e8:	42aa      	cmp	r2, r5
  tmpccmrx |= OC_Config->OCMode;
 80038ea:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80038ee:	f000 8115 	beq.w	8003b1c <HAL_TIM_PWM_ConfigChannel+0x2a4>
 80038f2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80038f6:	42aa      	cmp	r2, r5
 80038f8:	f000 8110 	beq.w	8003b1c <HAL_TIM_PWM_ConfigChannel+0x2a4>
  TIMx->CCR1 = OC_Config->Pulse;
 80038fc:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80038fe:	6056      	str	r6, [r2, #4]
  TIMx->CCMR1 = tmpccmrx;
 8003900:	6194      	str	r4, [r2, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8003902:	6355      	str	r5, [r2, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8003904:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8003906:	6990      	ldr	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003908:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800390a:	f040 0008 	orr.w	r0, r0, #8
 800390e:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8003910:	6990      	ldr	r0, [r2, #24]
 8003912:	f020 0004 	bic.w	r0, r0, #4
 8003916:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003918:	6991      	ldr	r1, [r2, #24]
 800391a:	4321      	orrs	r1, r4
 800391c:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 800391e:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8003920:	2101      	movs	r1, #1
  return HAL_OK;
 8003922:	4610      	mov	r0, r2
  htim->State = HAL_TIM_STATE_READY;
 8003924:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8003928:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 800392c:	bcf0      	pop	{r4, r5, r6, r7}
 800392e:	4770      	bx	lr
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8003930:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8003932:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8003934:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003936:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8003938:	f425 1580 	bic.w	r5, r5, #1048576	; 0x100000
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800393c:	4c92      	ldr	r4, [pc, #584]	; (8003b88 <HAL_TIM_PWM_ConfigChannel+0x310>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800393e:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8003940:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8003942:	6855      	ldr	r5, [r2, #4]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8003944:	f420 1000 	bic.w	r0, r0, #2097152	; 0x200000
  tmpccmrx = TIMx->CCMR3;
 8003948:	f8d2 c054 	ldr.w	ip, [r2, #84]	; 0x54
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800394c:	ea40 5006 	orr.w	r0, r0, r6, lsl #20
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003950:	4e8c      	ldr	r6, [pc, #560]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8003952:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003956:	42b2      	cmp	r2, r6
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003958:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800395c:	f000 80d2 	beq.w	8003b04 <HAL_TIM_PWM_ConfigChannel+0x28c>
 8003960:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8003964:	42b2      	cmp	r2, r6
 8003966:	f000 80cd 	beq.w	8003b04 <HAL_TIM_PWM_ConfigChannel+0x28c>
  TIMx->CCR6 = OC_Config->Pulse;
 800396a:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800396c:	6055      	str	r5, [r2, #4]
  TIMx->CCMR3 = tmpccmrx;
 800396e:	6554      	str	r4, [r2, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
 8003970:	65d6      	str	r6, [r2, #92]	; 0x5c
  TIMx->CCER = tmpccer;
 8003972:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8003974:	6d50      	ldr	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8003976:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8003978:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 800397c:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800397e:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8003980:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8003984:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8003986:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8003988:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 800398c:	6551      	str	r1, [r2, #84]	; 0x54
      break;
 800398e:	e7c6      	b.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8003990:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8003992:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003996:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003998:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800399a:	f025 0510 	bic.w	r5, r5, #16
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800399e:	4c7b      	ldr	r4, [pc, #492]	; (8003b8c <HAL_TIM_PWM_ConfigChannel+0x314>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80039a0:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 80039a2:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 80039a4:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 80039a6:	6995      	ldr	r5, [r2, #24]
  tmpccer &= ~TIM_CCER_CC2P;
 80039a8:	f020 0020 	bic.w	r0, r0, #32
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80039ac:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80039ae:	4d75      	ldr	r5, [pc, #468]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80039b0:	ea40 100c 	orr.w	r0, r0, ip, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80039b4:	42aa      	cmp	r2, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80039b6:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80039ba:	f000 80c3 	beq.w	8003b44 <HAL_TIM_PWM_ConfigChannel+0x2cc>
 80039be:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80039c2:	42aa      	cmp	r2, r5
 80039c4:	f000 80be 	beq.w	8003b44 <HAL_TIM_PWM_ConfigChannel+0x2cc>
  TIMx->CCR2 = OC_Config->Pulse;
 80039c8:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80039ca:	6056      	str	r6, [r2, #4]
  TIMx->CCMR1 = tmpccmrx;
 80039cc:	6194      	str	r4, [r2, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 80039ce:	6395      	str	r5, [r2, #56]	; 0x38
  TIMx->CCER = tmpccer;
 80039d0:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80039d2:	6990      	ldr	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80039d4:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80039d6:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 80039da:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80039dc:	6990      	ldr	r0, [r2, #24]
 80039de:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 80039e2:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80039e4:	6991      	ldr	r1, [r2, #24]
 80039e6:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 80039ea:	6191      	str	r1, [r2, #24]
      break;
 80039ec:	e797      	b.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80039ee:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80039f0:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80039f2:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80039f4:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80039f6:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80039fa:	4c64      	ldr	r4, [pc, #400]	; (8003b8c <HAL_TIM_PWM_ConfigChannel+0x314>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80039fc:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 80039fe:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8003a00:	6855      	ldr	r5, [r2, #4]
  tmpccer &= ~TIM_CCER_CC4P;
 8003a02:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
  tmpccmrx = TIMx->CCMR2;
 8003a06:	f8d2 c01c 	ldr.w	ip, [r2, #28]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8003a0a:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003a0e:	4e5d      	ldr	r6, [pc, #372]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8003a10:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003a14:	42b2      	cmp	r2, r6
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003a16:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003a1a:	f000 808d 	beq.w	8003b38 <HAL_TIM_PWM_ConfigChannel+0x2c0>
 8003a1e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8003a22:	42b2      	cmp	r2, r6
 8003a24:	f000 8088 	beq.w	8003b38 <HAL_TIM_PWM_ConfigChannel+0x2c0>
  TIMx->CCR4 = OC_Config->Pulse;
 8003a28:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8003a2a:	6055      	str	r5, [r2, #4]
  TIMx->CCMR2 = tmpccmrx;
 8003a2c:	61d4      	str	r4, [r2, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8003a2e:	6416      	str	r6, [r2, #64]	; 0x40
  TIMx->CCER = tmpccer;
 8003a30:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8003a32:	69d0      	ldr	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8003a34:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8003a36:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8003a3a:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8003a3c:	69d0      	ldr	r0, [r2, #28]
 8003a3e:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8003a42:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8003a44:	69d1      	ldr	r1, [r2, #28]
 8003a46:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8003a4a:	61d1      	str	r1, [r2, #28]
      break;
 8003a4c:	e767      	b.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8003a4e:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8003a50:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003a54:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 8003a56:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003a58:	f425 7580 	bic.w	r5, r5, #256	; 0x100
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8003a5c:	4c48      	ldr	r4, [pc, #288]	; (8003b80 <HAL_TIM_PWM_ConfigChannel+0x308>)
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003a5e:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8003a60:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8003a62:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR2;
 8003a64:	69d5      	ldr	r5, [r2, #28]
  tmpccer &= ~TIM_CCER_CC3P;
 8003a66:	f420 7000 	bic.w	r0, r0, #512	; 0x200
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8003a6a:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8003a6c:	4d45      	ldr	r5, [pc, #276]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8003a6e:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8003a72:	42aa      	cmp	r2, r5
  tmpccmrx |= OC_Config->OCMode;
 8003a74:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8003a78:	d073      	beq.n	8003b62 <HAL_TIM_PWM_ConfigChannel+0x2ea>
 8003a7a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003a7e:	42aa      	cmp	r2, r5
 8003a80:	d06f      	beq.n	8003b62 <HAL_TIM_PWM_ConfigChannel+0x2ea>
  TIMx->CCR3 = OC_Config->Pulse;
 8003a82:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8003a84:	6056      	str	r6, [r2, #4]
  TIMx->CCMR2 = tmpccmrx;
 8003a86:	61d4      	str	r4, [r2, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8003a88:	63d5      	str	r5, [r2, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 8003a8a:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8003a8c:	69d0      	ldr	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8003a8e:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8003a90:	f040 0008 	orr.w	r0, r0, #8
 8003a94:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8003a96:	69d0      	ldr	r0, [r2, #28]
 8003a98:	f020 0004 	bic.w	r0, r0, #4
 8003a9c:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8003a9e:	69d1      	ldr	r1, [r2, #28]
 8003aa0:	4321      	orrs	r1, r4
 8003aa2:	61d1      	str	r1, [r2, #28]
      break;
 8003aa4:	e73b      	b.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8003aa6:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8003aa8:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8003aaa:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 8003aac:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8003aae:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8003ab2:	4c37      	ldr	r4, [pc, #220]	; (8003b90 <HAL_TIM_PWM_ConfigChannel+0x318>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8003ab4:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8003ab6:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8003ab8:	6855      	ldr	r5, [r2, #4]
  tmpccer &= ~TIM_CCER_CC5P;
 8003aba:	f420 3000 	bic.w	r0, r0, #131072	; 0x20000
  tmpccmrx = TIMx->CCMR3;
 8003abe:	f8d2 c054 	ldr.w	ip, [r2, #84]	; 0x54
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8003ac2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003ac6:	4e2f      	ldr	r6, [pc, #188]	; (8003b84 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8003ac8:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003acc:	42b2      	cmp	r2, r6
  tmpccmrx |= OC_Config->OCMode;
 8003ace:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003ad2:	d01d      	beq.n	8003b10 <HAL_TIM_PWM_ConfigChannel+0x298>
 8003ad4:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8003ad8:	42b2      	cmp	r2, r6
 8003ada:	d019      	beq.n	8003b10 <HAL_TIM_PWM_ConfigChannel+0x298>
  TIMx->CCR5 = OC_Config->Pulse;
 8003adc:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8003ade:	6055      	str	r5, [r2, #4]
  TIMx->CCMR3 = tmpccmrx;
 8003ae0:	6554      	str	r4, [r2, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 8003ae2:	6596      	str	r6, [r2, #88]	; 0x58
  TIMx->CCER = tmpccer;
 8003ae4:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8003ae6:	6d50      	ldr	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8003ae8:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8003aea:	f040 0008 	orr.w	r0, r0, #8
 8003aee:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8003af0:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8003af2:	f020 0004 	bic.w	r0, r0, #4
 8003af6:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8003af8:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8003afa:	4321      	orrs	r1, r4
 8003afc:	6551      	str	r1, [r2, #84]	; 0x54
      break;
 8003afe:	e70e      	b.n	800391e <HAL_TIM_PWM_ConfigChannel+0xa6>
  __HAL_LOCK(htim);
 8003b00:	2002      	movs	r0, #2
}
 8003b02:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_OIS6;
 8003b04:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8003b08:	694e      	ldr	r6, [r1, #20]
 8003b0a:	ea45 2586 	orr.w	r5, r5, r6, lsl #10
 8003b0e:	e72c      	b.n	800396a <HAL_TIM_PWM_ConfigChannel+0xf2>
    tmpcr2 &= ~TIM_CR2_OIS5;
 8003b10:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8003b14:	694e      	ldr	r6, [r1, #20]
 8003b16:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8003b1a:	e7df      	b.n	8003adc <HAL_TIM_PWM_ConfigChannel+0x264>
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8003b1c:	f426 7c40 	bic.w	ip, r6, #768	; 0x300
    tmpccer &= ~TIM_CCER_CC1NP;
 8003b20:	f020 0008 	bic.w	r0, r0, #8
    tmpcr2 |= OC_Config->OCNIdleState;
 8003b24:	698e      	ldr	r6, [r1, #24]
    tmpccer |= OC_Config->OCNPolarity;
 8003b26:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= OC_Config->OCNIdleState;
 8003b28:	694d      	ldr	r5, [r1, #20]
    tmpccer |= OC_Config->OCNPolarity;
 8003b2a:	4338      	orrs	r0, r7
    tmpcr2 |= OC_Config->OCNIdleState;
 8003b2c:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC1NE;
 8003b2e:	f020 0004 	bic.w	r0, r0, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8003b32:	ea45 060c 	orr.w	r6, r5, ip
 8003b36:	e6e1      	b.n	80038fc <HAL_TIM_PWM_ConfigChannel+0x84>
    tmpcr2 &= ~TIM_CR2_OIS4;
 8003b38:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8003b3c:	694e      	ldr	r6, [r1, #20]
 8003b3e:	ea45 1586 	orr.w	r5, r5, r6, lsl #6
 8003b42:	e771      	b.n	8003a28 <HAL_TIM_PWM_ConfigChannel+0x1b0>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8003b44:	f426 6c40 	bic.w	ip, r6, #3072	; 0xc00
    tmpccer &= ~TIM_CCER_CC2NP;
 8003b48:	f020 0080 	bic.w	r0, r0, #128	; 0x80
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8003b4c:	698e      	ldr	r6, [r1, #24]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8003b4e:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8003b50:	694d      	ldr	r5, [r1, #20]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8003b52:	ea40 1007 	orr.w	r0, r0, r7, lsl #4
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8003b56:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC2NE;
 8003b58:	f020 0040 	bic.w	r0, r0, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8003b5c:	ea4c 0685 	orr.w	r6, ip, r5, lsl #2
 8003b60:	e732      	b.n	80039c8 <HAL_TIM_PWM_ConfigChannel+0x150>
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8003b62:	f426 5c40 	bic.w	ip, r6, #12288	; 0x3000
    tmpccer &= ~TIM_CCER_CC3NP;
 8003b66:	f420 6000 	bic.w	r0, r0, #2048	; 0x800
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8003b6a:	698e      	ldr	r6, [r1, #24]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8003b6c:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8003b6e:	694d      	ldr	r5, [r1, #20]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8003b70:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8003b74:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC3NE;
 8003b76:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8003b7a:	ea4c 1605 	orr.w	r6, ip, r5, lsl #4
 8003b7e:	e780      	b.n	8003a82 <HAL_TIM_PWM_ConfigChannel+0x20a>
 8003b80:	fffeff8c 	.word	0xfffeff8c
 8003b84:	40010000 	.word	0x40010000
 8003b88:	feff8fff 	.word	0xfeff8fff
 8003b8c:	feff8cff 	.word	0xfeff8cff
 8003b90:	fffeff8f 	.word	0xfffeff8f

08003b94 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8003b94:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003b98:	2b01      	cmp	r3, #1
 8003b9a:	d05b      	beq.n	8003c54 <HAL_TIM_ConfigClockSource+0xc0>
 8003b9c:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8003b9e:	2002      	movs	r0, #2
  tmpsmcr = htim->Instance->SMCR;
 8003ba0:	6813      	ldr	r3, [r2, #0]
{
 8003ba2:	b470      	push	{r4, r5, r6}
  htim->State = HAL_TIM_STATE_BUSY;
 8003ba4:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  __HAL_LOCK(htim);
 8003ba8:	2501      	movs	r5, #1
  tmpsmcr = htim->Instance->SMCR;
 8003baa:	6898      	ldr	r0, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8003bac:	4c4c      	ldr	r4, [pc, #304]	; (8003ce0 <HAL_TIM_ConfigClockSource+0x14c>)
  __HAL_LOCK(htim);
 8003bae:	f882 503c 	strb.w	r5, [r2, #60]	; 0x3c
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8003bb2:	4004      	ands	r4, r0
  switch (sClockSourceConfig->ClockSource)
 8003bb4:	6808      	ldr	r0, [r1, #0]
 8003bb6:	2840      	cmp	r0, #64	; 0x40
  htim->Instance->SMCR = tmpsmcr;
 8003bb8:	609c      	str	r4, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 8003bba:	d076      	beq.n	8003caa <HAL_TIM_ConfigClockSource+0x116>
 8003bbc:	d94c      	bls.n	8003c58 <HAL_TIM_ConfigClockSource+0xc4>
 8003bbe:	2860      	cmp	r0, #96	; 0x60
 8003bc0:	d02f      	beq.n	8003c22 <HAL_TIM_ConfigClockSource+0x8e>
 8003bc2:	d958      	bls.n	8003c76 <HAL_TIM_ConfigClockSource+0xe2>
 8003bc4:	2870      	cmp	r0, #112	; 0x70
 8003bc6:	d01b      	beq.n	8003c00 <HAL_TIM_ConfigClockSource+0x6c>
 8003bc8:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8003bcc:	d10f      	bne.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003bce:	68cc      	ldr	r4, [r1, #12]
 8003bd0:	e9d1 5001 	ldrd	r5, r0, [r1, #4]
 8003bd4:	ea40 0105 	orr.w	r1, r0, r5
  tmpsmcr = TIMx->SMCR;
 8003bd8:	6898      	ldr	r0, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003bda:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8003bde:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003be2:	4301      	orrs	r1, r0
  TIMx->SMCR = tmpsmcr;
 8003be4:	6099      	str	r1, [r3, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8003be6:	6899      	ldr	r1, [r3, #8]
 8003be8:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8003bec:	6099      	str	r1, [r3, #8]
  __HAL_UNLOCK(htim);
 8003bee:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8003bf0:	2101      	movs	r1, #1
  return HAL_OK;
 8003bf2:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 8003bf4:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8003bf8:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8003bfc:	bc70      	pop	{r4, r5, r6}
 8003bfe:	4770      	bx	lr
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003c00:	e9d1 5001 	ldrd	r5, r0, [r1, #4]
 8003c04:	68cc      	ldr	r4, [r1, #12]
 8003c06:	ea40 0105 	orr.w	r1, r0, r5
  tmpsmcr = TIMx->SMCR;
 8003c0a:	6898      	ldr	r0, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003c0c:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8003c10:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8003c14:	4301      	orrs	r1, r0
  TIMx->SMCR = tmpsmcr;
 8003c16:	6099      	str	r1, [r3, #8]
      tmpsmcr = htim->Instance->SMCR;
 8003c18:	6899      	ldr	r1, [r3, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8003c1a:	f041 0177 	orr.w	r1, r1, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 8003c1e:	6099      	str	r1, [r3, #8]
      break;
 8003c20:	e7e5      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003c22:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8003c24:	684d      	ldr	r5, [r1, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003c26:	f024 0410 	bic.w	r4, r4, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
 8003c2a:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003c2c:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8003c2e:	6998      	ldr	r0, [r3, #24]
  tmpccer = TIMx->CCER;
 8003c30:	6a19      	ldr	r1, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8003c32:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8003c36:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8003c3a:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 8003c3e:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 8003c42:	6198      	str	r0, [r3, #24]
  TIMx->CCER = tmpccer;
 8003c44:	6219      	str	r1, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8003c46:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003c48:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003c4c:	f041 0167 	orr.w	r1, r1, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 8003c50:	6099      	str	r1, [r3, #8]
 8003c52:	e7cc      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  __HAL_LOCK(htim);
 8003c54:	2002      	movs	r0, #2
}
 8003c56:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8003c58:	2810      	cmp	r0, #16
 8003c5a:	d004      	beq.n	8003c66 <HAL_TIM_ConfigClockSource+0xd2>
 8003c5c:	d93d      	bls.n	8003cda <HAL_TIM_ConfigClockSource+0x146>
 8003c5e:	2820      	cmp	r0, #32
 8003c60:	d001      	beq.n	8003c66 <HAL_TIM_ConfigClockSource+0xd2>
 8003c62:	2830      	cmp	r0, #48	; 0x30
 8003c64:	d1c3      	bne.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  tmpsmcr = TIMx->SMCR;
 8003c66:	6899      	ldr	r1, [r3, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003c68:	f040 0007 	orr.w	r0, r0, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 8003c6c:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003c70:	4308      	orrs	r0, r1
  TIMx->SMCR = tmpsmcr;
 8003c72:	6098      	str	r0, [r3, #8]
 8003c74:	e7bb      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
 8003c76:	2850      	cmp	r0, #80	; 0x50
 8003c78:	d1b9      	bne.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  tmpccer = TIMx->CCER;
 8003c7a:	6a1d      	ldr	r5, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003c7c:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8003c7e:	6848      	ldr	r0, [r1, #4]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8003c80:	f025 050a 	bic.w	r5, r5, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003c84:	f024 0401 	bic.w	r4, r4, #1
      TIM_TI1_ConfigInputStage(htim->Instance,
 8003c88:	68ce      	ldr	r6, [r1, #12]
  tmpccer |= TIM_ICPolarity;
 8003c8a:	4328      	orrs	r0, r5
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003c8c:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8003c8e:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8003c90:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8003c94:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8003c98:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8003c9a:	6218      	str	r0, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8003c9c:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003c9e:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003ca2:	f041 0157 	orr.w	r1, r1, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
 8003ca6:	6099      	str	r1, [r3, #8]
 8003ca8:	e7a1      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  tmpccer = TIMx->CCER;
 8003caa:	6a1d      	ldr	r5, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003cac:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8003cae:	6848      	ldr	r0, [r1, #4]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8003cb0:	f025 050a 	bic.w	r5, r5, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003cb4:	f024 0401 	bic.w	r4, r4, #1
      TIM_TI1_ConfigInputStage(htim->Instance,
 8003cb8:	68ce      	ldr	r6, [r1, #12]
  tmpccer |= TIM_ICPolarity;
 8003cba:	4328      	orrs	r0, r5
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003cbc:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8003cbe:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8003cc0:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8003cc4:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8003cc8:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8003cca:	6218      	str	r0, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8003ccc:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003cce:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003cd2:	f041 0147 	orr.w	r1, r1, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8003cd6:	6099      	str	r1, [r3, #8]
 8003cd8:	e789      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
 8003cda:	2800      	cmp	r0, #0
 8003cdc:	d0c3      	beq.n	8003c66 <HAL_TIM_ConfigClockSource+0xd2>
 8003cde:	e786      	b.n	8003bee <HAL_TIM_ConfigClockSource+0x5a>
 8003ce0:	fffe0088 	.word	0xfffe0088

08003ce4 <HAL_TIM_OC_DelayElapsedCallback>:
 8003ce4:	4770      	bx	lr
 8003ce6:	bf00      	nop

08003ce8 <HAL_TIM_IC_CaptureCallback>:
 8003ce8:	4770      	bx	lr
 8003cea:	bf00      	nop

08003cec <HAL_TIM_PWM_PulseFinishedCallback>:
 8003cec:	4770      	bx	lr
 8003cee:	bf00      	nop

08003cf0 <HAL_TIM_TriggerCallback>:
 8003cf0:	4770      	bx	lr
 8003cf2:	bf00      	nop

08003cf4 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8003cf4:	6803      	ldr	r3, [r0, #0]
 8003cf6:	691a      	ldr	r2, [r3, #16]
 8003cf8:	0791      	lsls	r1, r2, #30
{
 8003cfa:	b510      	push	{r4, lr}
 8003cfc:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8003cfe:	d502      	bpl.n	8003d06 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8003d00:	68da      	ldr	r2, [r3, #12]
 8003d02:	0792      	lsls	r2, r2, #30
 8003d04:	d468      	bmi.n	8003dd8 <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8003d06:	691a      	ldr	r2, [r3, #16]
 8003d08:	0752      	lsls	r2, r2, #29
 8003d0a:	d502      	bpl.n	8003d12 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8003d0c:	68da      	ldr	r2, [r3, #12]
 8003d0e:	0750      	lsls	r0, r2, #29
 8003d10:	d44f      	bmi.n	8003db2 <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8003d12:	691a      	ldr	r2, [r3, #16]
 8003d14:	0711      	lsls	r1, r2, #28
 8003d16:	d502      	bpl.n	8003d1e <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8003d18:	68da      	ldr	r2, [r3, #12]
 8003d1a:	0712      	lsls	r2, r2, #28
 8003d1c:	d437      	bmi.n	8003d8e <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8003d1e:	691a      	ldr	r2, [r3, #16]
 8003d20:	06d0      	lsls	r0, r2, #27
 8003d22:	d502      	bpl.n	8003d2a <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8003d24:	68da      	ldr	r2, [r3, #12]
 8003d26:	06d1      	lsls	r1, r2, #27
 8003d28:	d41e      	bmi.n	8003d68 <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8003d2a:	691a      	ldr	r2, [r3, #16]
 8003d2c:	07d2      	lsls	r2, r2, #31
 8003d2e:	d502      	bpl.n	8003d36 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8003d30:	68da      	ldr	r2, [r3, #12]
 8003d32:	07d0      	lsls	r0, r2, #31
 8003d34:	d469      	bmi.n	8003e0a <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8003d36:	691a      	ldr	r2, [r3, #16]
 8003d38:	0611      	lsls	r1, r2, #24
 8003d3a:	d502      	bpl.n	8003d42 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8003d3c:	68da      	ldr	r2, [r3, #12]
 8003d3e:	0612      	lsls	r2, r2, #24
 8003d40:	d46b      	bmi.n	8003e1a <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8003d42:	691a      	ldr	r2, [r3, #16]
 8003d44:	05d0      	lsls	r0, r2, #23
 8003d46:	d502      	bpl.n	8003d4e <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8003d48:	68da      	ldr	r2, [r3, #12]
 8003d4a:	0611      	lsls	r1, r2, #24
 8003d4c:	d46d      	bmi.n	8003e2a <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8003d4e:	691a      	ldr	r2, [r3, #16]
 8003d50:	0652      	lsls	r2, r2, #25
 8003d52:	d502      	bpl.n	8003d5a <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8003d54:	68da      	ldr	r2, [r3, #12]
 8003d56:	0650      	lsls	r0, r2, #25
 8003d58:	d46f      	bmi.n	8003e3a <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8003d5a:	691a      	ldr	r2, [r3, #16]
 8003d5c:	0691      	lsls	r1, r2, #26
 8003d5e:	d502      	bpl.n	8003d66 <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8003d60:	68da      	ldr	r2, [r3, #12]
 8003d62:	0692      	lsls	r2, r2, #26
 8003d64:	d449      	bmi.n	8003dfa <HAL_TIM_IRQHandler+0x106>
}
 8003d66:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8003d68:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8003d6c:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 8003d6e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8003d70:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003d72:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8003d74:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003d76:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003d7a:	d16f      	bne.n	8003e5c <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003d7c:	f7ff ffb2 	bl	8003ce4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003d80:	4620      	mov	r0, r4
 8003d82:	f7ff ffb3 	bl	8003cec <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003d86:	2200      	movs	r2, #0
 8003d88:	6823      	ldr	r3, [r4, #0]
 8003d8a:	7722      	strb	r2, [r4, #28]
 8003d8c:	e7cd      	b.n	8003d2a <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8003d8e:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8003d92:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 8003d94:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8003d96:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003d98:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8003d9a:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003d9c:	079b      	lsls	r3, r3, #30
 8003d9e:	d15a      	bne.n	8003e56 <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003da0:	f7ff ffa0 	bl	8003ce4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003da4:	4620      	mov	r0, r4
 8003da6:	f7ff ffa1 	bl	8003cec <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003daa:	2200      	movs	r2, #0
 8003dac:	6823      	ldr	r3, [r4, #0]
 8003dae:	7722      	strb	r2, [r4, #28]
 8003db0:	e7b5      	b.n	8003d1e <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8003db2:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003db6:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 8003db8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8003dba:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003dbc:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003dbe:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003dc0:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003dc4:	d144      	bne.n	8003e50 <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003dc6:	f7ff ff8d 	bl	8003ce4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003dca:	4620      	mov	r0, r4
 8003dcc:	f7ff ff8e 	bl	8003cec <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003dd0:	2200      	movs	r2, #0
 8003dd2:	6823      	ldr	r3, [r4, #0]
 8003dd4:	7722      	strb	r2, [r4, #28]
 8003dd6:	e79c      	b.n	8003d12 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8003dd8:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003ddc:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8003dde:	6119      	str	r1, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003de0:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003de2:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003de4:	0799      	lsls	r1, r3, #30
 8003de6:	d130      	bne.n	8003e4a <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8003de8:	f7ff ff7c 	bl	8003ce4 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003dec:	4620      	mov	r0, r4
 8003dee:	f7ff ff7d 	bl	8003cec <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003df2:	2200      	movs	r2, #0
 8003df4:	6823      	ldr	r3, [r4, #0]
 8003df6:	7722      	strb	r2, [r4, #28]
 8003df8:	e785      	b.n	8003d06 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8003dfa:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8003dfe:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8003e00:	611a      	str	r2, [r3, #16]
}
 8003e02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8003e06:	f000 b8f7 	b.w	8003ff8 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8003e0a:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8003e0e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8003e10:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8003e12:	f000 ff2b 	bl	8004c6c <HAL_TIM_PeriodElapsedCallback>
 8003e16:	6823      	ldr	r3, [r4, #0]
 8003e18:	e78d      	b.n	8003d36 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8003e1a:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8003e1e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8003e20:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8003e22:	f000 f8eb 	bl	8003ffc <HAL_TIMEx_BreakCallback>
 8003e26:	6823      	ldr	r3, [r4, #0]
 8003e28:	e78b      	b.n	8003d42 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8003e2a:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 8003e2e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8003e30:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8003e32:	f000 f8e5 	bl	8004000 <HAL_TIMEx_Break2Callback>
 8003e36:	6823      	ldr	r3, [r4, #0]
 8003e38:	e789      	b.n	8003d4e <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8003e3a:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 8003e3e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8003e40:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8003e42:	f7ff ff55 	bl	8003cf0 <HAL_TIM_TriggerCallback>
 8003e46:	6823      	ldr	r3, [r4, #0]
 8003e48:	e787      	b.n	8003d5a <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 8003e4a:	f7ff ff4d 	bl	8003ce8 <HAL_TIM_IC_CaptureCallback>
 8003e4e:	e7d0      	b.n	8003df2 <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 8003e50:	f7ff ff4a 	bl	8003ce8 <HAL_TIM_IC_CaptureCallback>
 8003e54:	e7bc      	b.n	8003dd0 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 8003e56:	f7ff ff47 	bl	8003ce8 <HAL_TIM_IC_CaptureCallback>
 8003e5a:	e7a6      	b.n	8003daa <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 8003e5c:	f7ff ff44 	bl	8003ce8 <HAL_TIM_IC_CaptureCallback>
 8003e60:	e791      	b.n	8003d86 <HAL_TIM_IRQHandler+0x92>
 8003e62:	bf00      	nop

08003e64 <HAL_TIMEx_PWMN_Start>:
 8003e64:	6803      	ldr	r3, [r0, #0]
 8003e66:	2204      	movs	r2, #4
 8003e68:	f001 011f 	and.w	r1, r1, #31
 8003e6c:	480e      	ldr	r0, [pc, #56]	; (8003ea8 <HAL_TIMEx_PWMN_Start+0x44>)
 8003e6e:	b410      	push	{r4}
 8003e70:	fa02 f101 	lsl.w	r1, r2, r1
 8003e74:	6a1c      	ldr	r4, [r3, #32]
 8003e76:	ea24 0401 	bic.w	r4, r4, r1
 8003e7a:	621c      	str	r4, [r3, #32]
 8003e7c:	6a1a      	ldr	r2, [r3, #32]
 8003e7e:	4311      	orrs	r1, r2
 8003e80:	6219      	str	r1, [r3, #32]
 8003e82:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003e84:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003e88:	645a      	str	r2, [r3, #68]	; 0x44
 8003e8a:	689a      	ldr	r2, [r3, #8]
 8003e8c:	4010      	ands	r0, r2
 8003e8e:	2806      	cmp	r0, #6
 8003e90:	d006      	beq.n	8003ea0 <HAL_TIMEx_PWMN_Start+0x3c>
 8003e92:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8003e96:	d003      	beq.n	8003ea0 <HAL_TIMEx_PWMN_Start+0x3c>
 8003e98:	681a      	ldr	r2, [r3, #0]
 8003e9a:	f042 0201 	orr.w	r2, r2, #1
 8003e9e:	601a      	str	r2, [r3, #0]
 8003ea0:	2000      	movs	r0, #0
 8003ea2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003ea6:	4770      	bx	lr
 8003ea8:	00010007 	.word	0x00010007

08003eac <HAL_TIMEx_PWMN_Stop>:
 8003eac:	6803      	ldr	r3, [r0, #0]
 8003eae:	f241 1011 	movw	r0, #4369	; 0x1111
 8003eb2:	b410      	push	{r4}
 8003eb4:	f001 041f 	and.w	r4, r1, #31
 8003eb8:	2104      	movs	r1, #4
 8003eba:	6a1a      	ldr	r2, [r3, #32]
 8003ebc:	40a1      	lsls	r1, r4
 8003ebe:	ea22 0101 	bic.w	r1, r2, r1
 8003ec2:	6219      	str	r1, [r3, #32]
 8003ec4:	6a1a      	ldr	r2, [r3, #32]
 8003ec6:	621a      	str	r2, [r3, #32]
 8003ec8:	6a1a      	ldr	r2, [r3, #32]
 8003eca:	4202      	tst	r2, r0
 8003ecc:	d104      	bne.n	8003ed8 <HAL_TIMEx_PWMN_Stop+0x2c>
 8003ece:	6a19      	ldr	r1, [r3, #32]
 8003ed0:	f240 4244 	movw	r2, #1092	; 0x444
 8003ed4:	4211      	tst	r1, r2
 8003ed6:	d011      	beq.n	8003efc <HAL_TIMEx_PWMN_Stop+0x50>
 8003ed8:	6a19      	ldr	r1, [r3, #32]
 8003eda:	f241 1211 	movw	r2, #4369	; 0x1111
 8003ede:	4211      	tst	r1, r2
 8003ee0:	d108      	bne.n	8003ef4 <HAL_TIMEx_PWMN_Stop+0x48>
 8003ee2:	6a19      	ldr	r1, [r3, #32]
 8003ee4:	f240 4244 	movw	r2, #1092	; 0x444
 8003ee8:	4211      	tst	r1, r2
 8003eea:	d103      	bne.n	8003ef4 <HAL_TIMEx_PWMN_Stop+0x48>
 8003eec:	681a      	ldr	r2, [r3, #0]
 8003eee:	f022 0201 	bic.w	r2, r2, #1
 8003ef2:	601a      	str	r2, [r3, #0]
 8003ef4:	2000      	movs	r0, #0
 8003ef6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003efa:	4770      	bx	lr
 8003efc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003efe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003f02:	645a      	str	r2, [r3, #68]	; 0x44
 8003f04:	e7e8      	b.n	8003ed8 <HAL_TIMEx_PWMN_Stop+0x2c>
 8003f06:	bf00      	nop

08003f08 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8003f08:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003f0c:	2b01      	cmp	r3, #1
 8003f0e:	d025      	beq.n	8003f5c <HAL_TIMEx_MasterConfigSynchronization+0x54>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8003f10:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8003f12:	2302      	movs	r3, #2
{
 8003f14:	b470      	push	{r4, r5, r6}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8003f16:	4d13      	ldr	r5, [pc, #76]	; (8003f64 <HAL_TIMEx_MasterConfigSynchronization+0x5c>)
  htim->State = HAL_TIM_STATE_BUSY;
 8003f18:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8003f1c:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 8003f1e:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 8003f20:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8003f22:	d016      	beq.n	8003f52 <HAL_TIMEx_MasterConfigSynchronization+0x4a>
 8003f24:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003f28:	42aa      	cmp	r2, r5
 8003f2a:	d012      	beq.n	8003f52 <HAL_TIMEx_MasterConfigSynchronization+0x4a>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8003f2c:	680d      	ldr	r5, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 8003f2e:	f024 0480 	bic.w	r4, r4, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8003f32:	6889      	ldr	r1, [r1, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 8003f34:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8003f38:	2601      	movs	r6, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8003f3a:	432b      	orrs	r3, r5
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8003f3c:	4321      	orrs	r1, r4

  __HAL_UNLOCK(htim);
 8003f3e:	2500      	movs	r5, #0
  htim->Instance->CR2 = tmpcr2;
 8003f40:	6053      	str	r3, [r2, #4]
  htim->Instance->SMCR = tmpsmcr;
 8003f42:	6091      	str	r1, [r2, #8]
  htim->State = HAL_TIM_STATE_READY;
 8003f44:	f880 603d 	strb.w	r6, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8003f48:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c

  return HAL_OK;
}
 8003f4c:	4628      	mov	r0, r5
 8003f4e:	bc70      	pop	{r4, r5, r6}
 8003f50:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_MMS2;
 8003f52:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8003f56:	684d      	ldr	r5, [r1, #4]
 8003f58:	432b      	orrs	r3, r5
 8003f5a:	e7e7      	b.n	8003f2c <HAL_TIMEx_MasterConfigSynchronization+0x24>
  __HAL_LOCK(htim);
 8003f5c:	2302      	movs	r3, #2
}
 8003f5e:	4618      	mov	r0, r3
 8003f60:	4770      	bx	lr
 8003f62:	bf00      	nop
 8003f64:	40010000 	.word	0x40010000

08003f68 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 8003f68:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8003f6c:	2b01      	cmp	r3, #1
 8003f6e:	d03b      	beq.n	8003fe8 <HAL_TIMEx_ConfigBreakDeadTime+0x80>
{
 8003f70:	b470      	push	{r4, r5, r6}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003f72:	e9d1 5302 	ldrd	r5, r3, [r1, #8]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8003f76:	e9d1 2400 	ldrd	r2, r4, [r1]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003f7a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8003f7e:	690e      	ldr	r6, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003f80:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8003f82:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8003f84:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003f88:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003f8a:	6a8c      	ldr	r4, [r1, #40]	; 0x28
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8003f8c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003f90:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8003f92:	698a      	ldr	r2, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8003f94:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003f98:	4333      	orrs	r3, r6

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003f9a:	6806      	ldr	r6, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8003f9c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003fa0:	432b      	orrs	r3, r5
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003fa2:	4d13      	ldr	r5, [pc, #76]	; (8003ff0 <HAL_TIMEx_ConfigBreakDeadTime+0x88>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003fa4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003fa8:	42ae      	cmp	r6, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003faa:	ea43 0304 	orr.w	r3, r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8003fae:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8003fb2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003fb6:	d009      	beq.n	8003fcc <HAL_TIMEx_ConfigBreakDeadTime+0x64>
 8003fb8:	4a0e      	ldr	r2, [pc, #56]	; (8003ff4 <HAL_TIMEx_ConfigBreakDeadTime+0x8c>)
 8003fba:	4296      	cmp	r6, r2
 8003fbc:	d006      	beq.n	8003fcc <HAL_TIMEx_ConfigBreakDeadTime+0x64>
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 8003fbe:	2200      	movs	r2, #0
  htim->Instance->BDTR = tmpbdtr;
 8003fc0:	6473      	str	r3, [r6, #68]	; 0x44
  __HAL_UNLOCK(htim);
 8003fc2:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

  return HAL_OK;
}
 8003fc6:	4610      	mov	r0, r2
 8003fc8:	bc70      	pop	{r4, r5, r6}
 8003fca:	4770      	bx	lr
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8003fcc:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003fce:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8003fd2:	69cc      	ldr	r4, [r1, #28]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8003fd4:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8003fd8:	6a0a      	ldr	r2, [r1, #32]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8003fda:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003fde:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8003fe0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8003fe4:	4313      	orrs	r3, r2
 8003fe6:	e7ea      	b.n	8003fbe <HAL_TIMEx_ConfigBreakDeadTime+0x56>
  __HAL_LOCK(htim);
 8003fe8:	2302      	movs	r3, #2
}
 8003fea:	4618      	mov	r0, r3
 8003fec:	4770      	bx	lr
 8003fee:	bf00      	nop
 8003ff0:	40010000 	.word	0x40010000
 8003ff4:	40010400 	.word	0x40010400

08003ff8 <HAL_TIMEx_CommutCallback>:
 8003ff8:	4770      	bx	lr
 8003ffa:	bf00      	nop

08003ffc <HAL_TIMEx_BreakCallback>:
 8003ffc:	4770      	bx	lr
 8003ffe:	bf00      	nop

08004000 <HAL_TIMEx_Break2Callback>:
 8004000:	4770      	bx	lr
 8004002:	bf00      	nop

08004004 <HAL_UART_Transmit>:
  * @param Size    Amount of data to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8004004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004008:	461d      	mov	r5, r3
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800400a:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 800400c:	b082      	sub	sp, #8
  if (huart->gState == HAL_UART_STATE_READY)
 800400e:	2b20      	cmp	r3, #32
 8004010:	d146      	bne.n	80040a0 <HAL_UART_Transmit+0x9c>
 8004012:	4688      	mov	r8, r1
  {
    if ((pData == NULL) || (Size == 0U))
 8004014:	2900      	cmp	r1, #0
 8004016:	d047      	beq.n	80040a8 <HAL_UART_Transmit+0xa4>
 8004018:	fab2 f682 	clz	r6, r2
 800401c:	9201      	str	r2, [sp, #4]
 800401e:	0976      	lsrs	r6, r6, #5
 8004020:	2e00      	cmp	r6, #0
 8004022:	d141      	bne.n	80040a8 <HAL_UART_Transmit+0xa4>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8004024:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 8004028:	4604      	mov	r4, r0
 800402a:	2b01      	cmp	r3, #1
 800402c:	d038      	beq.n	80040a0 <HAL_UART_Transmit+0x9c>

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800402e:	2321      	movs	r3, #33	; 0x21
    __HAL_LOCK(huart);
 8004030:	2101      	movs	r1, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004032:	67c6      	str	r6, [r0, #124]	; 0x7c
    __HAL_LOCK(huart);
 8004034:	f880 1070 	strb.w	r1, [r0, #112]	; 0x70
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8004038:	6743      	str	r3, [r0, #116]	; 0x74

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 800403a:	f7fc fab9 	bl	80005b0 <HAL_GetTick>

    huart->TxXferSize  = Size;
    huart->TxXferCount = Size;

        /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800403e:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
 8004040:	9a01      	ldr	r2, [sp, #4]
    tickstart = HAL_GetTick();
 8004042:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004044:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 8004048:	f8a4 2050 	strh.w	r2, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
 800404c:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004050:	d05d      	beq.n	800410e <HAL_UART_Transmit+0x10a>
    {
      pdata8bits  = pData;
      pdata16bits = NULL;
    }

    while (huart->TxXferCount > 0U)
 8004052:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8004056:	6820      	ldr	r0, [r4, #0]
 8004058:	b29b      	uxth	r3, r3
 800405a:	b1ab      	cbz	r3, 8004088 <HAL_UART_Transmit+0x84>
 800405c:	1c69      	adds	r1, r5, #1
 800405e:	d127      	bne.n	80040b0 <HAL_UART_Transmit+0xac>
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004060:	69c2      	ldr	r2, [r0, #28]
 8004062:	0612      	lsls	r2, r2, #24
 8004064:	d5fc      	bpl.n	8004060 <HAL_UART_Transmit+0x5c>
      if (pdata8bits == NULL)
 8004066:	f1b8 0f00 	cmp.w	r8, #0
 800406a:	d02c      	beq.n	80040c6 <HAL_UART_Transmit+0xc2>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800406c:	f818 3b01 	ldrb.w	r3, [r8], #1
 8004070:	6283      	str	r3, [r0, #40]	; 0x28
      huart->TxXferCount--;
 8004072:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8004076:	3b01      	subs	r3, #1
 8004078:	b29b      	uxth	r3, r3
 800407a:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 800407e:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8004082:	b29b      	uxth	r3, r3
 8004084:	2b00      	cmp	r3, #0
 8004086:	d1e9      	bne.n	800405c <HAL_UART_Transmit+0x58>
 8004088:	1c69      	adds	r1, r5, #1
 800408a:	d134      	bne.n	80040f6 <HAL_UART_Transmit+0xf2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800408c:	69c3      	ldr	r3, [r0, #28]
 800408e:	065a      	lsls	r2, r3, #25
 8004090:	d5fc      	bpl.n	800408c <HAL_UART_Transmit+0x88>
    __HAL_UNLOCK(huart);
 8004092:	2300      	movs	r3, #0
    huart->gState = HAL_UART_STATE_READY;
 8004094:	2220      	movs	r2, #32
    return HAL_OK;
 8004096:	4618      	mov	r0, r3
    huart->gState = HAL_UART_STATE_READY;
 8004098:	6762      	str	r2, [r4, #116]	; 0x74
    __HAL_UNLOCK(huart);
 800409a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    return HAL_OK;
 800409e:	e000      	b.n	80040a2 <HAL_UART_Transmit+0x9e>
    return HAL_BUSY;
 80040a0:	2002      	movs	r0, #2
}
 80040a2:	b002      	add	sp, #8
 80040a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 80040a8:	2001      	movs	r0, #1
}
 80040aa:	b002      	add	sp, #8
 80040ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80040b0:	69c3      	ldr	r3, [r0, #28]
 80040b2:	061b      	lsls	r3, r3, #24
 80040b4:	d4d7      	bmi.n	8004066 <HAL_UART_Transmit+0x62>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80040b6:	f7fc fa7b 	bl	80005b0 <HAL_GetTick>
 80040ba:	1bc0      	subs	r0, r0, r7
 80040bc:	4285      	cmp	r5, r0
 80040be:	d307      	bcc.n	80040d0 <HAL_UART_Transmit+0xcc>
 80040c0:	b135      	cbz	r5, 80040d0 <HAL_UART_Transmit+0xcc>
 80040c2:	6820      	ldr	r0, [r4, #0]
 80040c4:	e7ca      	b.n	800405c <HAL_UART_Transmit+0x58>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80040c6:	f836 3b02 	ldrh.w	r3, [r6], #2
 80040ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80040ce:	e7cf      	b.n	8004070 <HAL_UART_Transmit+0x6c>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80040d0:	6823      	ldr	r3, [r4, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);

        huart->gState = HAL_UART_STATE_READY;
 80040d2:	2120      	movs	r1, #32
        huart->RxState = HAL_UART_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 80040d4:	2500      	movs	r5, #0
      return HAL_TIMEOUT;
 80040d6:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80040d8:	681a      	ldr	r2, [r3, #0]
 80040da:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 80040de:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80040e0:	689a      	ldr	r2, [r3, #8]
 80040e2:	f022 0201 	bic.w	r2, r2, #1
 80040e6:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 80040e8:	6761      	str	r1, [r4, #116]	; 0x74
        __HAL_UNLOCK(huart);
 80040ea:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 80040ee:	67a1      	str	r1, [r4, #120]	; 0x78
}
 80040f0:	b002      	add	sp, #8
 80040f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80040f6:	69c3      	ldr	r3, [r0, #28]
 80040f8:	065b      	lsls	r3, r3, #25
 80040fa:	d4ca      	bmi.n	8004092 <HAL_UART_Transmit+0x8e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80040fc:	f7fc fa58 	bl	80005b0 <HAL_GetTick>
 8004100:	1bc0      	subs	r0, r0, r7
 8004102:	4285      	cmp	r5, r0
 8004104:	d3e4      	bcc.n	80040d0 <HAL_UART_Transmit+0xcc>
 8004106:	2d00      	cmp	r5, #0
 8004108:	d0e2      	beq.n	80040d0 <HAL_UART_Transmit+0xcc>
 800410a:	6820      	ldr	r0, [r4, #0]
 800410c:	e7bc      	b.n	8004088 <HAL_UART_Transmit+0x84>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800410e:	6923      	ldr	r3, [r4, #16]
 8004110:	2b00      	cmp	r3, #0
 8004112:	d19e      	bne.n	8004052 <HAL_UART_Transmit+0x4e>
 8004114:	4646      	mov	r6, r8
      pdata8bits  = NULL;
 8004116:	4698      	mov	r8, r3
 8004118:	e79b      	b.n	8004052 <HAL_UART_Transmit+0x4e>
 800411a:	bf00      	nop

0800411c <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800411c:	6f83      	ldr	r3, [r0, #120]	; 0x78
 800411e:	2b20      	cmp	r3, #32
 8004120:	d137      	bne.n	8004192 <HAL_UART_Receive_IT+0x76>
    if ((pData == NULL) || (Size == 0U))
 8004122:	2900      	cmp	r1, #0
 8004124:	d033      	beq.n	800418e <HAL_UART_Receive_IT+0x72>
 8004126:	fab2 f382 	clz	r3, r2
 800412a:	095b      	lsrs	r3, r3, #5
 800412c:	2b00      	cmp	r3, #0
 800412e:	d12e      	bne.n	800418e <HAL_UART_Receive_IT+0x72>
{
 8004130:	b430      	push	{r4, r5}
    __HAL_LOCK(huart);
 8004132:	f890 4070 	ldrb.w	r4, [r0, #112]	; 0x70
 8004136:	2c01      	cmp	r4, #1
 8004138:	d042      	beq.n	80041c0 <HAL_UART_Receive_IT+0xa4>
    UART_MASK_COMPUTATION(huart);
 800413a:	6884      	ldr	r4, [r0, #8]
    __HAL_LOCK(huart);
 800413c:	2501      	movs	r5, #1
    huart->RxXferSize  = Size;
 800413e:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
    UART_MASK_COMPUTATION(huart);
 8004142:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    huart->RxXferCount = Size;
 8004146:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr  = pData;
 800414a:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxISR       = NULL;
 800414c:	6603      	str	r3, [r0, #96]	; 0x60
    __HAL_LOCK(huart);
 800414e:	f880 5070 	strb.w	r5, [r0, #112]	; 0x70
 8004152:	6802      	ldr	r2, [r0, #0]
    UART_MASK_COMPUTATION(huart);
 8004154:	d01f      	beq.n	8004196 <HAL_UART_Receive_IT+0x7a>
 8004156:	2c00      	cmp	r4, #0
 8004158:	d12c      	bne.n	80041b4 <HAL_UART_Receive_IT+0x98>
 800415a:	6903      	ldr	r3, [r0, #16]
 800415c:	2b00      	cmp	r3, #0
 800415e:	d03d      	beq.n	80041dc <HAL_UART_Receive_IT+0xc0>
 8004160:	237f      	movs	r3, #127	; 0x7f
 8004162:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8004166:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004168:	2100      	movs	r1, #0
      huart->RxISR = UART_RxISR_8BIT;
 800416a:	4c22      	ldr	r4, [pc, #136]	; (80041f4 <HAL_UART_Receive_IT+0xd8>)
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800416c:	67c1      	str	r1, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800416e:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004170:	6893      	ldr	r3, [r2, #8]
 8004172:	f043 0301 	orr.w	r3, r3, #1
 8004176:	6093      	str	r3, [r2, #8]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8004178:	6811      	ldr	r1, [r2, #0]
    __HAL_UNLOCK(huart);
 800417a:	2300      	movs	r3, #0
 800417c:	6604      	str	r4, [r0, #96]	; 0x60
 800417e:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8004182:	f441 7190 	orr.w	r1, r1, #288	; 0x120
    return HAL_OK;
 8004186:	4618      	mov	r0, r3
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8004188:	6011      	str	r1, [r2, #0]
}
 800418a:	bc30      	pop	{r4, r5}
 800418c:	4770      	bx	lr
      return HAL_ERROR;
 800418e:	2001      	movs	r0, #1
}
 8004190:	4770      	bx	lr
    return HAL_BUSY;
 8004192:	2002      	movs	r0, #2
 8004194:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 8004196:	6901      	ldr	r1, [r0, #16]
 8004198:	b9a1      	cbnz	r1, 80041c4 <HAL_UART_Receive_IT+0xa8>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800419a:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800419c:	67c1      	str	r1, [r0, #124]	; 0x7c
 800419e:	f240 11ff 	movw	r1, #511	; 0x1ff
      huart->RxISR = UART_RxISR_16BIT;
 80041a2:	4c15      	ldr	r4, [pc, #84]	; (80041f8 <HAL_UART_Receive_IT+0xdc>)
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80041a4:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80041a6:	6893      	ldr	r3, [r2, #8]
 80041a8:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 80041ac:	f043 0301 	orr.w	r3, r3, #1
 80041b0:	6093      	str	r3, [r2, #8]
 80041b2:	e7e1      	b.n	8004178 <HAL_UART_Receive_IT+0x5c>
    UART_MASK_COMPUTATION(huart);
 80041b4:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
 80041b8:	d014      	beq.n	80041e4 <HAL_UART_Receive_IT+0xc8>
 80041ba:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 80041be:	e7d2      	b.n	8004166 <HAL_UART_Receive_IT+0x4a>
    return HAL_BUSY;
 80041c0:	2002      	movs	r0, #2
 80041c2:	e7e2      	b.n	800418a <HAL_UART_Receive_IT+0x6e>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80041c4:	2522      	movs	r5, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80041c6:	67c3      	str	r3, [r0, #124]	; 0x7c
 80041c8:	21ff      	movs	r1, #255	; 0xff
      huart->RxISR = UART_RxISR_8BIT;
 80041ca:	4c0a      	ldr	r4, [pc, #40]	; (80041f4 <HAL_UART_Receive_IT+0xd8>)
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80041cc:	6785      	str	r5, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80041ce:	6893      	ldr	r3, [r2, #8]
 80041d0:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 80041d4:	f043 0301 	orr.w	r3, r3, #1
 80041d8:	6093      	str	r3, [r2, #8]
 80041da:	e7cd      	b.n	8004178 <HAL_UART_Receive_IT+0x5c>
    UART_MASK_COMPUTATION(huart);
 80041dc:	23ff      	movs	r3, #255	; 0xff
 80041de:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 80041e2:	e7c0      	b.n	8004166 <HAL_UART_Receive_IT+0x4a>
 80041e4:	6903      	ldr	r3, [r0, #16]
 80041e6:	2b00      	cmp	r3, #0
 80041e8:	d0ba      	beq.n	8004160 <HAL_UART_Receive_IT+0x44>
 80041ea:	233f      	movs	r3, #63	; 0x3f
 80041ec:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 80041f0:	e7b9      	b.n	8004166 <HAL_UART_Receive_IT+0x4a>
 80041f2:	bf00      	nop
 80041f4:	080042dd 	.word	0x080042dd
 80041f8:	08004339 	.word	0x08004339

080041fc <HAL_UART_Transmit_DMA>:
{
 80041fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (huart->gState == HAL_UART_STATE_READY)
 80041fe:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8004200:	2e20      	cmp	r6, #32
 8004202:	d13b      	bne.n	800427c <HAL_UART_Transmit_DMA+0x80>
    if ((pData == NULL) || (Size == 0U))
 8004204:	2900      	cmp	r1, #0
 8004206:	d03b      	beq.n	8004280 <HAL_UART_Transmit_DMA+0x84>
 8004208:	fab2 f782 	clz	r7, r2
 800420c:	097f      	lsrs	r7, r7, #5
 800420e:	2f00      	cmp	r7, #0
 8004210:	d136      	bne.n	8004280 <HAL_UART_Transmit_DMA+0x84>
    __HAL_LOCK(huart);
 8004212:	f890 4070 	ldrb.w	r4, [r0, #112]	; 0x70
 8004216:	2c01      	cmp	r4, #1
 8004218:	d030      	beq.n	800427c <HAL_UART_Transmit_DMA+0x80>
 800421a:	4613      	mov	r3, r2
 800421c:	4605      	mov	r5, r0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800421e:	2221      	movs	r2, #33	; 0x21
    __HAL_LOCK(huart);
 8004220:	2401      	movs	r4, #1
    if (huart->hdmatx != NULL)
 8004222:	f8d0 e068 	ldr.w	lr, [r0, #104]	; 0x68
    huart->TxXferCount = Size;
 8004226:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
    huart->pTxBuffPtr  = pData;
 800422a:	64e9      	str	r1, [r5, #76]	; 0x4c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800422c:	67c7      	str	r7, [r0, #124]	; 0x7c
    huart->TxXferSize  = Size;
 800422e:	f8a0 3050 	strh.w	r3, [r0, #80]	; 0x50
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8004232:	6742      	str	r2, [r0, #116]	; 0x74
    __HAL_LOCK(huart);
 8004234:	f880 4070 	strb.w	r4, [r0, #112]	; 0x70
 8004238:	6802      	ldr	r2, [r0, #0]
    if (huart->hdmatx != NULL)
 800423a:	f1be 0f00 	cmp.w	lr, #0
 800423e:	d012      	beq.n	8004266 <HAL_UART_Transmit_DMA+0x6a>
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8004240:	f8df c054 	ldr.w	ip, [pc, #84]	; 8004298 <HAL_UART_Transmit_DMA+0x9c>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8004244:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8004246:	4813      	ldr	r0, [pc, #76]	; (8004294 <HAL_UART_Transmit_DMA+0x98>)
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8004248:	f8ce c040 	str.w	ip, [lr, #64]	; 0x40
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 800424c:	f8df c04c 	ldr.w	ip, [pc, #76]	; 800429c <HAL_UART_Transmit_DMA+0xa0>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8004250:	f8ce 003c 	str.w	r0, [lr, #60]	; 0x3c
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8004254:	4670      	mov	r0, lr
      huart->hdmatx->XferAbortCallback = NULL;
 8004256:	f8ce 7050 	str.w	r7, [lr, #80]	; 0x50
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 800425a:	f8ce c04c 	str.w	ip, [lr, #76]	; 0x4c
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 800425e:	f7fd faf5 	bl	800184c <HAL_DMA_Start_IT>
 8004262:	b978      	cbnz	r0, 8004284 <HAL_UART_Transmit_DMA+0x88>
 8004264:	682a      	ldr	r2, [r5, #0]
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 8004266:	2340      	movs	r3, #64	; 0x40
    __HAL_UNLOCK(huart);
 8004268:	2100      	movs	r1, #0
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 800426a:	6213      	str	r3, [r2, #32]
    return HAL_OK;
 800426c:	4608      	mov	r0, r1
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800426e:	6893      	ldr	r3, [r2, #8]
    __HAL_UNLOCK(huart);
 8004270:	f885 1070 	strb.w	r1, [r5, #112]	; 0x70
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8004274:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004278:	6093      	str	r3, [r2, #8]
}
 800427a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 800427c:	2002      	movs	r0, #2
}
 800427e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_ERROR;
 8004280:	2001      	movs	r0, #1
}
 8004282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 8004284:	2310      	movs	r3, #16
        __HAL_UNLOCK(huart);
 8004286:	f885 7070 	strb.w	r7, [r5, #112]	; 0x70
        return HAL_ERROR;
 800428a:	4620      	mov	r0, r4
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 800428c:	67eb      	str	r3, [r5, #124]	; 0x7c
        huart->gState = HAL_UART_STATE_READY;
 800428e:	676e      	str	r6, [r5, #116]	; 0x74
}
 8004290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004292:	bf00      	nop
 8004294:	080042a1 	.word	0x080042a1
 8004298:	080042d1 	.word	0x080042d1
 800429c:	08004395 	.word	0x08004395

080042a0 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 80042a0:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);

  /* DMA Normal mode */
  if (hdma->Init.Mode != DMA_CIRCULAR)
 80042a2:	69c3      	ldr	r3, [r0, #28]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80042a4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 80042a6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80042aa:	d00c      	beq.n	80042c6 <UART_DMATransmitCplt+0x26>
  {
    huart->TxXferCount = 0U;

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80042ac:	6803      	ldr	r3, [r0, #0]
    huart->TxXferCount = 0U;
 80042ae:	2200      	movs	r2, #0
 80042b0:	f8a0 2052 	strh.w	r2, [r0, #82]	; 0x52
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80042b4:	689a      	ldr	r2, [r3, #8]
 80042b6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80042ba:	609a      	str	r2, [r3, #8]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80042bc:	681a      	ldr	r2, [r3, #0]
 80042be:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80042c2:	601a      	str	r2, [r3, #0]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 80042c4:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 80042c6:	f002 fd93 	bl	8006df0 <HAL_UART_TxCpltCallback>
}
 80042ca:	bd08      	pop	{r3, pc}

080042cc <HAL_UART_TxHalfCpltCallback>:
 80042cc:	4770      	bx	lr
 80042ce:	bf00      	nop

080042d0 <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 80042d0:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 80042d2:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80042d4:	f7ff fffa 	bl	80042cc <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80042d8:	bd08      	pop	{r3, pc}
 80042da:	bf00      	nop

080042dc <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80042dc:	6f81      	ldr	r1, [r0, #120]	; 0x78
 80042de:	6802      	ldr	r2, [r0, #0]
 80042e0:	2922      	cmp	r1, #34	; 0x22
{
 80042e2:	b538      	push	{r3, r4, r5, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80042e4:	d004      	beq.n	80042f0 <UART_RxISR_8BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80042e6:	6993      	ldr	r3, [r2, #24]
 80042e8:	f043 0308 	orr.w	r3, r3, #8
 80042ec:	6193      	str	r3, [r2, #24]
  }
}
 80042ee:	bd38      	pop	{r3, r4, r5, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80042f0:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80042f2:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
 80042f6:	6d41      	ldr	r1, [r0, #84]	; 0x54
 80042f8:	4022      	ands	r2, r4
 80042fa:	700a      	strb	r2, [r1, #0]
    huart->RxXferCount--;
 80042fc:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr++;
 8004300:	6d41      	ldr	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 8004302:	3a01      	subs	r2, #1
    huart->pRxBuffPtr++;
 8004304:	3101      	adds	r1, #1
    huart->RxXferCount--;
 8004306:	b292      	uxth	r2, r2
    huart->pRxBuffPtr++;
 8004308:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800430a:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 800430e:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
 8004312:	b292      	uxth	r2, r2
 8004314:	2a00      	cmp	r2, #0
 8004316:	d1ea      	bne.n	80042ee <UART_RxISR_8BIT+0x12>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004318:	6801      	ldr	r1, [r0, #0]
      huart->RxState = HAL_UART_STATE_READY;
 800431a:	2520      	movs	r5, #32
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800431c:	680c      	ldr	r4, [r1, #0]
 800431e:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 8004322:	600c      	str	r4, [r1, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004324:	688c      	ldr	r4, [r1, #8]
 8004326:	f024 0401 	bic.w	r4, r4, #1
 800432a:	608c      	str	r4, [r1, #8]
      huart->RxISR = NULL;
 800432c:	6602      	str	r2, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 800432e:	6785      	str	r5, [r0, #120]	; 0x78
      HAL_UART_RxCpltCallback(huart);
 8004330:	f002 fccc 	bl	8006ccc <HAL_UART_RxCpltCallback>
}
 8004334:	bd38      	pop	{r3, r4, r5, pc}
 8004336:	bf00      	nop

08004338 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004338:	6f81      	ldr	r1, [r0, #120]	; 0x78
 800433a:	6802      	ldr	r2, [r0, #0]
 800433c:	2922      	cmp	r1, #34	; 0x22
{
 800433e:	b538      	push	{r3, r4, r5, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004340:	d004      	beq.n	800434c <UART_RxISR_16BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004342:	6993      	ldr	r3, [r2, #24]
 8004344:	f043 0308 	orr.w	r3, r3, #8
 8004348:	6193      	str	r3, [r2, #24]
  }
}
 800434a:	bd38      	pop	{r3, r4, r5, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800434c:	6a51      	ldr	r1, [r2, #36]	; 0x24
    *tmp = (uint16_t)(uhdata & uhMask);
 800434e:	f8b0 505c 	ldrh.w	r5, [r0, #92]	; 0x5c
 8004352:	6d44      	ldr	r4, [r0, #84]	; 0x54
 8004354:	4029      	ands	r1, r5
 8004356:	f824 1b02 	strh.w	r1, [r4], #2
    huart->RxXferCount--;
 800435a:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
    huart->pRxBuffPtr += 2U;
 800435e:	6544      	str	r4, [r0, #84]	; 0x54
    huart->RxXferCount--;
 8004360:	3901      	subs	r1, #1
 8004362:	b289      	uxth	r1, r1
 8004364:	f8a0 105a 	strh.w	r1, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 8004368:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
 800436c:	b289      	uxth	r1, r1
 800436e:	2900      	cmp	r1, #0
 8004370:	d1eb      	bne.n	800434a <UART_RxISR_16BIT+0x12>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004372:	6814      	ldr	r4, [r2, #0]
      huart->RxState = HAL_UART_STATE_READY;
 8004374:	2520      	movs	r5, #32
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004376:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 800437a:	6014      	str	r4, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800437c:	6894      	ldr	r4, [r2, #8]
 800437e:	f024 0401 	bic.w	r4, r4, #1
 8004382:	6094      	str	r4, [r2, #8]
      huart->RxISR = NULL;
 8004384:	6601      	str	r1, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 8004386:	6785      	str	r5, [r0, #120]	; 0x78
      HAL_UART_RxCpltCallback(huart);
 8004388:	f002 fca0 	bl	8006ccc <HAL_UART_RxCpltCallback>
}
 800438c:	bd38      	pop	{r3, r4, r5, pc}
 800438e:	bf00      	nop

08004390 <HAL_UART_ErrorCallback>:
 8004390:	4770      	bx	lr
 8004392:	bf00      	nop

08004394 <UART_DMAError>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8004394:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8004396:	681a      	ldr	r2, [r3, #0]
{
 8004398:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef gstate = huart->gState;
 800439a:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800439c:	6f98      	ldr	r0, [r3, #120]	; 0x78
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800439e:	6891      	ldr	r1, [r2, #8]
 80043a0:	0609      	lsls	r1, r1, #24
 80043a2:	d501      	bpl.n	80043a8 <UART_DMAError+0x14>
 80043a4:	2c21      	cmp	r4, #33	; 0x21
 80043a6:	d01b      	beq.n	80043e0 <UART_DMAError+0x4c>
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 80043a8:	6891      	ldr	r1, [r2, #8]
 80043aa:	0649      	lsls	r1, r1, #25
 80043ac:	d501      	bpl.n	80043b2 <UART_DMAError+0x1e>
 80043ae:	2822      	cmp	r0, #34	; 0x22
 80043b0:	d007      	beq.n	80043c2 <UART_DMAError+0x2e>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 80043b2:	6fda      	ldr	r2, [r3, #124]	; 0x7c
  HAL_UART_ErrorCallback(huart);
 80043b4:	4618      	mov	r0, r3
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 80043b6:	f042 0210 	orr.w	r2, r2, #16
 80043ba:	67da      	str	r2, [r3, #124]	; 0x7c
  HAL_UART_ErrorCallback(huart);
 80043bc:	f7ff ffe8 	bl	8004390 <HAL_UART_ErrorCallback>
}
 80043c0:	bd10      	pop	{r4, pc}
    huart->RxXferCount = 0U;
 80043c2:	2000      	movs	r0, #0
  huart->RxState = HAL_UART_STATE_READY;
 80043c4:	2420      	movs	r4, #32
    huart->RxXferCount = 0U;
 80043c6:	f8a3 005a 	strh.w	r0, [r3, #90]	; 0x5a
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80043ca:	6811      	ldr	r1, [r2, #0]
 80043cc:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 80043d0:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80043d2:	6891      	ldr	r1, [r2, #8]
 80043d4:	f021 0101 	bic.w	r1, r1, #1
 80043d8:	6091      	str	r1, [r2, #8]
  huart->RxISR = NULL;
 80043da:	6618      	str	r0, [r3, #96]	; 0x60
  huart->RxState = HAL_UART_STATE_READY;
 80043dc:	679c      	str	r4, [r3, #120]	; 0x78
 80043de:	e7e8      	b.n	80043b2 <UART_DMAError+0x1e>
    huart->TxXferCount = 0U;
 80043e0:	2100      	movs	r1, #0
  huart->gState = HAL_UART_STATE_READY;
 80043e2:	2420      	movs	r4, #32
    huart->TxXferCount = 0U;
 80043e4:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 80043e8:	6811      	ldr	r1, [r2, #0]
 80043ea:	f021 01c0 	bic.w	r1, r1, #192	; 0xc0
 80043ee:	6011      	str	r1, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 80043f0:	675c      	str	r4, [r3, #116]	; 0x74
 80043f2:	e7d9      	b.n	80043a8 <UART_DMAError+0x14>

080043f4 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80043f4:	6803      	ldr	r3, [r0, #0]
 80043f6:	69da      	ldr	r2, [r3, #28]
{
 80043f8:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == 0U)
 80043fa:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80043fc:	681d      	ldr	r5, [r3, #0]
{
 80043fe:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8004400:	6899      	ldr	r1, [r3, #8]
  if (errorflags == 0U)
 8004402:	d047      	beq.n	8004494 <HAL_UART_IRQHandler+0xa0>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8004404:	f011 0101 	ands.w	r1, r1, #1
 8004408:	d04b      	beq.n	80044a2 <HAL_UART_IRQHandler+0xae>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800440a:	07d0      	lsls	r0, r2, #31
 800440c:	d507      	bpl.n	800441e <HAL_UART_IRQHandler+0x2a>
 800440e:	05ee      	lsls	r6, r5, #23
 8004410:	d505      	bpl.n	800441e <HAL_UART_IRQHandler+0x2a>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8004412:	2001      	movs	r0, #1
 8004414:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8004416:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8004418:	f040 0001 	orr.w	r0, r0, #1
 800441c:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800441e:	0790      	lsls	r0, r2, #30
 8004420:	d45d      	bmi.n	80044de <HAL_UART_IRQHandler+0xea>
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004422:	0750      	lsls	r0, r2, #29
 8004424:	d501      	bpl.n	800442a <HAL_UART_IRQHandler+0x36>
 8004426:	2900      	cmp	r1, #0
 8004428:	d163      	bne.n	80044f2 <HAL_UART_IRQHandler+0xfe>
    if (((isrflags & USART_ISR_ORE) != 0U)
 800442a:	0716      	lsls	r6, r2, #28
 800442c:	d503      	bpl.n	8004436 <HAL_UART_IRQHandler+0x42>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800442e:	06a8      	lsls	r0, r5, #26
 8004430:	d466      	bmi.n	8004500 <HAL_UART_IRQHandler+0x10c>
 8004432:	2900      	cmp	r1, #0
 8004434:	d164      	bne.n	8004500 <HAL_UART_IRQHandler+0x10c>
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004436:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8004438:	2900      	cmp	r1, #0
 800443a:	d031      	beq.n	80044a0 <HAL_UART_IRQHandler+0xac>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800443c:	0696      	lsls	r6, r2, #26
 800443e:	d501      	bpl.n	8004444 <HAL_UART_IRQHandler+0x50>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8004440:	06a8      	lsls	r0, r5, #26
 8004442:	d468      	bmi.n	8004516 <HAL_UART_IRQHandler+0x122>
      errorcode = huart->ErrorCode;
 8004444:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8004446:	6899      	ldr	r1, [r3, #8]
 8004448:	0649      	lsls	r1, r1, #25
 800444a:	d402      	bmi.n	8004452 <HAL_UART_IRQHandler+0x5e>
 800444c:	f015 0508 	ands.w	r5, r5, #8
 8004450:	d068      	beq.n	8004524 <HAL_UART_IRQHandler+0x130>
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004452:	681a      	ldr	r2, [r3, #0]
  huart->RxState = HAL_UART_STATE_READY;
 8004454:	2020      	movs	r0, #32
  huart->RxISR = NULL;
 8004456:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004458:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 800445c:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800445e:	689a      	ldr	r2, [r3, #8]
 8004460:	f022 0201 	bic.w	r2, r2, #1
 8004464:	609a      	str	r2, [r3, #8]
  huart->RxState = HAL_UART_STATE_READY;
 8004466:	67a0      	str	r0, [r4, #120]	; 0x78
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004468:	689a      	ldr	r2, [r3, #8]
  huart->RxISR = NULL;
 800446a:	6621      	str	r1, [r4, #96]	; 0x60
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800446c:	0652      	lsls	r2, r2, #25
 800446e:	d54e      	bpl.n	800450e <HAL_UART_IRQHandler+0x11a>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8004470:	689a      	ldr	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 8004472:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8004474:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8004478:	609a      	str	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 800447a:	2900      	cmp	r1, #0
 800447c:	d047      	beq.n	800450e <HAL_UART_IRQHandler+0x11a>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800447e:	4b2c      	ldr	r3, [pc, #176]	; (8004530 <HAL_UART_IRQHandler+0x13c>)
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8004480:	4608      	mov	r0, r1
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8004482:	650b      	str	r3, [r1, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8004484:	f7fd fa28 	bl	80018d8 <HAL_DMA_Abort_IT>
 8004488:	b150      	cbz	r0, 80044a0 <HAL_UART_IRQHandler+0xac>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800448a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
}
 800448c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8004490:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8004492:	4718      	bx	r3
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8004494:	0691      	lsls	r1, r2, #26
 8004496:	d507      	bpl.n	80044a8 <HAL_UART_IRQHandler+0xb4>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8004498:	06ae      	lsls	r6, r5, #26
 800449a:	d505      	bpl.n	80044a8 <HAL_UART_IRQHandler+0xb4>
      if (huart->RxISR != NULL)
 800449c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800449e:	b9db      	cbnz	r3, 80044d8 <HAL_UART_IRQHandler+0xe4>
}
 80044a0:	bd70      	pop	{r4, r5, r6, pc}
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 80044a2:	f415 7f90 	tst.w	r5, #288	; 0x120
 80044a6:	d1b0      	bne.n	800440a <HAL_UART_IRQHandler+0x16>
  if (((isrflags & USART_ISR_TXE) != 0U)
 80044a8:	0616      	lsls	r6, r2, #24
 80044aa:	d40f      	bmi.n	80044cc <HAL_UART_IRQHandler+0xd8>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 80044ac:	0651      	lsls	r1, r2, #25
 80044ae:	d5f7      	bpl.n	80044a0 <HAL_UART_IRQHandler+0xac>
 80044b0:	066a      	lsls	r2, r5, #25
 80044b2:	d5f5      	bpl.n	80044a0 <HAL_UART_IRQHandler+0xac>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80044b4:	681a      	ldr	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 80044b6:	2520      	movs	r5, #32
  huart->TxISR = NULL;
 80044b8:	2100      	movs	r1, #0
  HAL_UART_TxCpltCallback(huart);
 80044ba:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80044bc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80044c0:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 80044c2:	6765      	str	r5, [r4, #116]	; 0x74
  huart->TxISR = NULL;
 80044c4:	6661      	str	r1, [r4, #100]	; 0x64
  HAL_UART_TxCpltCallback(huart);
 80044c6:	f002 fc93 	bl	8006df0 <HAL_UART_TxCpltCallback>
}
 80044ca:	bd70      	pop	{r4, r5, r6, pc}
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 80044cc:	0628      	lsls	r0, r5, #24
 80044ce:	d5ed      	bpl.n	80044ac <HAL_UART_IRQHandler+0xb8>
    if (huart->TxISR != NULL)
 80044d0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80044d2:	2b00      	cmp	r3, #0
 80044d4:	d0e4      	beq.n	80044a0 <HAL_UART_IRQHandler+0xac>
      huart->TxISR(huart);
 80044d6:	4620      	mov	r0, r4
}
 80044d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 80044dc:	4718      	bx	r3
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80044de:	2900      	cmp	r1, #0
 80044e0:	d0a3      	beq.n	800442a <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80044e2:	2002      	movs	r0, #2
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80044e4:	0756      	lsls	r6, r2, #29
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80044e6:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80044e8:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80044ea:	f040 0004 	orr.w	r0, r0, #4
 80044ee:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80044f0:	d59b      	bpl.n	800442a <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80044f2:	2004      	movs	r0, #4
 80044f4:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80044f6:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80044f8:	f040 0002 	orr.w	r0, r0, #2
 80044fc:	67e0      	str	r0, [r4, #124]	; 0x7c
 80044fe:	e794      	b.n	800442a <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8004500:	2108      	movs	r1, #8
 8004502:	6219      	str	r1, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8004504:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8004506:	f041 0108 	orr.w	r1, r1, #8
 800450a:	67e1      	str	r1, [r4, #124]	; 0x7c
 800450c:	e793      	b.n	8004436 <HAL_UART_IRQHandler+0x42>
            HAL_UART_ErrorCallback(huart);
 800450e:	4620      	mov	r0, r4
 8004510:	f7ff ff3e 	bl	8004390 <HAL_UART_ErrorCallback>
}
 8004514:	bd70      	pop	{r4, r5, r6, pc}
        if (huart->RxISR != NULL)
 8004516:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8004518:	2a00      	cmp	r2, #0
 800451a:	d093      	beq.n	8004444 <HAL_UART_IRQHandler+0x50>
          huart->RxISR(huart);
 800451c:	4620      	mov	r0, r4
 800451e:	4790      	blx	r2
 8004520:	6823      	ldr	r3, [r4, #0]
 8004522:	e78f      	b.n	8004444 <HAL_UART_IRQHandler+0x50>
        HAL_UART_ErrorCallback(huart);
 8004524:	4620      	mov	r0, r4
 8004526:	f7ff ff33 	bl	8004390 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800452a:	67e5      	str	r5, [r4, #124]	; 0x7c
}
 800452c:	bd70      	pop	{r4, r5, r6, pc}
 800452e:	bf00      	nop
 8004530:	08004535 	.word	0x08004535

08004534 <UART_DMAAbortOnError>:
{
 8004534:	b508      	push	{r3, lr}
  huart->RxXferCount = 0U;
 8004536:	2200      	movs	r2, #0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8004538:	6b83      	ldr	r3, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 800453a:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  HAL_UART_ErrorCallback(huart);
 800453e:	4618      	mov	r0, r3
  huart->TxXferCount = 0U;
 8004540:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 8004544:	f7ff ff24 	bl	8004390 <HAL_UART_ErrorCallback>
}
 8004548:	bd08      	pop	{r3, pc}
 800454a:	bf00      	nop

0800454c <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800454c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800454e:	07da      	lsls	r2, r3, #31
{
 8004550:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004552:	d506      	bpl.n	8004562 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8004554:	6801      	ldr	r1, [r0, #0]
 8004556:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8004558:	684a      	ldr	r2, [r1, #4]
 800455a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800455e:	4322      	orrs	r2, r4
 8004560:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8004562:	079c      	lsls	r4, r3, #30
 8004564:	d506      	bpl.n	8004574 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8004566:	6801      	ldr	r1, [r0, #0]
 8004568:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800456a:	684a      	ldr	r2, [r1, #4]
 800456c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004570:	4322      	orrs	r2, r4
 8004572:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8004574:	0759      	lsls	r1, r3, #29
 8004576:	d506      	bpl.n	8004586 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8004578:	6801      	ldr	r1, [r0, #0]
 800457a:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800457c:	684a      	ldr	r2, [r1, #4]
 800457e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004582:	4322      	orrs	r2, r4
 8004584:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8004586:	071a      	lsls	r2, r3, #28
 8004588:	d506      	bpl.n	8004598 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800458a:	6801      	ldr	r1, [r0, #0]
 800458c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800458e:	684a      	ldr	r2, [r1, #4]
 8004590:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004594:	4322      	orrs	r2, r4
 8004596:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8004598:	06dc      	lsls	r4, r3, #27
 800459a:	d506      	bpl.n	80045aa <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800459c:	6801      	ldr	r1, [r0, #0]
 800459e:	6b84      	ldr	r4, [r0, #56]	; 0x38
 80045a0:	688a      	ldr	r2, [r1, #8]
 80045a2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80045a6:	4322      	orrs	r2, r4
 80045a8:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80045aa:	0699      	lsls	r1, r3, #26
 80045ac:	d506      	bpl.n	80045bc <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80045ae:	6801      	ldr	r1, [r0, #0]
 80045b0:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80045b2:	688a      	ldr	r2, [r1, #8]
 80045b4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80045b8:	4322      	orrs	r2, r4
 80045ba:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80045bc:	065a      	lsls	r2, r3, #25
 80045be:	d50a      	bpl.n	80045d6 <UART_AdvFeatureConfig+0x8a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80045c0:	6801      	ldr	r1, [r0, #0]
 80045c2:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80045c4:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80045c6:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80045ca:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80045ce:	ea42 0204 	orr.w	r2, r2, r4
 80045d2:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80045d4:	d00b      	beq.n	80045ee <UART_AdvFeatureConfig+0xa2>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80045d6:	061b      	lsls	r3, r3, #24
 80045d8:	d506      	bpl.n	80045e8 <UART_AdvFeatureConfig+0x9c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80045da:	6802      	ldr	r2, [r0, #0]
 80045dc:	6c81      	ldr	r1, [r0, #72]	; 0x48
 80045de:	6853      	ldr	r3, [r2, #4]
 80045e0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80045e4:	430b      	orrs	r3, r1
 80045e6:	6053      	str	r3, [r2, #4]
}
 80045e8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80045ec:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80045ee:	684a      	ldr	r2, [r1, #4]
 80045f0:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80045f2:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80045f6:	4322      	orrs	r2, r4
 80045f8:	604a      	str	r2, [r1, #4]
 80045fa:	e7ec      	b.n	80045d6 <UART_AdvFeatureConfig+0x8a>

080045fc <HAL_UART_Init>:
  if (huart == NULL)
 80045fc:	2800      	cmp	r0, #0
 80045fe:	d04f      	beq.n	80046a0 <HAL_UART_Init+0xa4>
  if (huart->gState == HAL_UART_STATE_RESET)
 8004600:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 8004602:	b570      	push	{r4, r5, r6, lr}
 8004604:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8004606:	2b00      	cmp	r3, #0
 8004608:	d045      	beq.n	8004696 <HAL_UART_Init+0x9a>
  __HAL_UART_DISABLE(huart);
 800460a:	6823      	ldr	r3, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800460c:	2124      	movs	r1, #36	; 0x24
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800460e:	6920      	ldr	r0, [r4, #16]
  huart->gState = HAL_UART_STATE_BUSY;
 8004610:	6761      	str	r1, [r4, #116]	; 0x74
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004612:	68a2      	ldr	r2, [r4, #8]
  __HAL_UART_DISABLE(huart);
 8004614:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004616:	4302      	orrs	r2, r0
 8004618:	6960      	ldr	r0, [r4, #20]
  __HAL_UART_DISABLE(huart);
 800461a:	f021 0101 	bic.w	r1, r1, #1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800461e:	4dbe      	ldr	r5, [pc, #760]	; (8004918 <HAL_UART_Init+0x31c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004620:	4302      	orrs	r2, r0
 8004622:	69e0      	ldr	r0, [r4, #28]
  __HAL_UART_DISABLE(huart);
 8004624:	6019      	str	r1, [r3, #0]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004626:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004628:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800462a:	68e6      	ldr	r6, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800462c:	400d      	ands	r5, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800462e:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004630:	432a      	orrs	r2, r5
  tmpreg |= huart->Init.OneBitSampling;
 8004632:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004634:	601a      	str	r2, [r3, #0]
  tmpreg |= huart->Init.OneBitSampling;
 8004636:	ea41 0205 	orr.w	r2, r1, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800463a:	6859      	ldr	r1, [r3, #4]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800463c:	4db7      	ldr	r5, [pc, #732]	; (800491c <HAL_UART_Init+0x320>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800463e:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004642:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8004644:	ea41 0106 	orr.w	r1, r1, r6
 8004648:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800464a:	6899      	ldr	r1, [r3, #8]
 800464c:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 8004650:	ea42 0201 	orr.w	r2, r2, r1
 8004654:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004656:	d025      	beq.n	80046a4 <HAL_UART_Init+0xa8>
 8004658:	4ab1      	ldr	r2, [pc, #708]	; (8004920 <HAL_UART_Init+0x324>)
 800465a:	4293      	cmp	r3, r2
 800465c:	d044      	beq.n	80046e8 <HAL_UART_Init+0xec>
 800465e:	4ab1      	ldr	r2, [pc, #708]	; (8004924 <HAL_UART_Init+0x328>)
 8004660:	4293      	cmp	r3, r2
 8004662:	f000 80d3 	beq.w	800480c <HAL_UART_Init+0x210>
 8004666:	4ab0      	ldr	r2, [pc, #704]	; (8004928 <HAL_UART_Init+0x32c>)
 8004668:	4293      	cmp	r3, r2
 800466a:	d045      	beq.n	80046f8 <HAL_UART_Init+0xfc>
 800466c:	4aaf      	ldr	r2, [pc, #700]	; (800492c <HAL_UART_Init+0x330>)
 800466e:	4293      	cmp	r3, r2
 8004670:	f000 80e1 	beq.w	8004836 <HAL_UART_Init+0x23a>
 8004674:	4aae      	ldr	r2, [pc, #696]	; (8004930 <HAL_UART_Init+0x334>)
 8004676:	4293      	cmp	r3, r2
 8004678:	f000 816a 	beq.w	8004950 <HAL_UART_Init+0x354>
 800467c:	4aad      	ldr	r2, [pc, #692]	; (8004934 <HAL_UART_Init+0x338>)
 800467e:	4293      	cmp	r3, r2
 8004680:	f000 8179 	beq.w	8004976 <HAL_UART_Init+0x37a>
 8004684:	4aac      	ldr	r2, [pc, #688]	; (8004938 <HAL_UART_Init+0x33c>)
 8004686:	4293      	cmp	r3, r2
 8004688:	f000 8135 	beq.w	80048f6 <HAL_UART_Init+0x2fa>
  huart->RxISR = NULL;
 800468c:	2300      	movs	r3, #0
    return HAL_ERROR;
 800468e:	2001      	movs	r0, #1
  huart->TxISR = NULL;
 8004690:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 8004694:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8004696:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 800469a:	f001 ffaf 	bl	80065fc <HAL_UART_MspInit>
 800469e:	e7b4      	b.n	800460a <HAL_UART_Init+0xe>
    return HAL_ERROR;
 80046a0:	2001      	movs	r0, #1
}
 80046a2:	4770      	bx	lr
  UART_GETCLOCKSOURCE(huart, clocksource);
 80046a4:	4ba5      	ldr	r3, [pc, #660]	; (800493c <HAL_UART_Init+0x340>)
 80046a6:	4aa6      	ldr	r2, [pc, #664]	; (8004940 <HAL_UART_Init+0x344>)
 80046a8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80046ac:	f003 0303 	and.w	r3, r3, #3
 80046b0:	5cd3      	ldrb	r3, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80046b2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80046b6:	d02f      	beq.n	8004718 <HAL_UART_Init+0x11c>
    switch (clocksource)
 80046b8:	2b08      	cmp	r3, #8
 80046ba:	d8e7      	bhi.n	800468c <HAL_UART_Init+0x90>
 80046bc:	a201      	add	r2, pc, #4	; (adr r2, 80046c4 <HAL_UART_Init+0xc8>)
 80046be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80046c2:	bf00      	nop
 80046c4:	080047fb 	.word	0x080047fb
 80046c8:	08004755 	.word	0x08004755
 80046cc:	08004827 	.word	0x08004827
 80046d0:	0800468d 	.word	0x0800468d
 80046d4:	0800484d 	.word	0x0800484d
 80046d8:	0800468d 	.word	0x0800468d
 80046dc:	0800468d 	.word	0x0800468d
 80046e0:	0800468d 	.word	0x0800468d
 80046e4:	0800485f 	.word	0x0800485f
  UART_GETCLOCKSOURCE(huart, clocksource);
 80046e8:	4b94      	ldr	r3, [pc, #592]	; (800493c <HAL_UART_Init+0x340>)
 80046ea:	4a96      	ldr	r2, [pc, #600]	; (8004944 <HAL_UART_Init+0x348>)
 80046ec:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80046f0:	f003 030c 	and.w	r3, r3, #12
 80046f4:	5cd3      	ldrb	r3, [r2, r3]
 80046f6:	e7dc      	b.n	80046b2 <HAL_UART_Init+0xb6>
 80046f8:	4b90      	ldr	r3, [pc, #576]	; (800493c <HAL_UART_Init+0x340>)
 80046fa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80046fe:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8004702:	2b40      	cmp	r3, #64	; 0x40
 8004704:	f000 809f 	beq.w	8004846 <HAL_UART_Init+0x24a>
 8004708:	d971      	bls.n	80047ee <HAL_UART_Init+0x1f2>
 800470a:	2b80      	cmp	r3, #128	; 0x80
 800470c:	f000 8088 	beq.w	8004820 <HAL_UART_Init+0x224>
 8004710:	2bc0      	cmp	r3, #192	; 0xc0
 8004712:	f000 80b9 	beq.w	8004888 <HAL_UART_Init+0x28c>
 8004716:	e7b9      	b.n	800468c <HAL_UART_Init+0x90>
    switch (clocksource)
 8004718:	2b08      	cmp	r3, #8
 800471a:	d8b7      	bhi.n	800468c <HAL_UART_Init+0x90>
 800471c:	a201      	add	r2, pc, #4	; (adr r2, 8004724 <HAL_UART_Init+0x128>)
 800471e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004722:	bf00      	nop
 8004724:	080048f1 	.word	0x080048f1
 8004728:	080048c7 	.word	0x080048c7
 800472c:	080048e1 	.word	0x080048e1
 8004730:	0800468d 	.word	0x0800468d
 8004734:	080048db 	.word	0x080048db
 8004738:	0800468d 	.word	0x0800468d
 800473c:	0800468d 	.word	0x0800468d
 8004740:	0800468d 	.word	0x0800468d
 8004744:	0800488f 	.word	0x0800488f
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004748:	2b00      	cmp	r3, #0
 800474a:	d19f      	bne.n	800468c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800474c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8004750:	f000 80b9 	beq.w	80048c6 <HAL_UART_Init+0x2ca>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8004754:	f7fe f82e 	bl	80027b4 <HAL_RCC_GetPCLK2Freq>
 8004758:	6863      	ldr	r3, [r4, #4]
 800475a:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 800475e:	fbb2 f2f3 	udiv	r2, r2, r3
 8004762:	b292      	uxth	r2, r2
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004764:	f1a2 0110 	sub.w	r1, r2, #16
 8004768:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800476c:	4299      	cmp	r1, r3
 800476e:	d88d      	bhi.n	800468c <HAL_UART_Init+0x90>
      huart->Instance->BRR = usartdiv;
 8004770:	6823      	ldr	r3, [r4, #0]
  huart->RxISR = NULL;
 8004772:	2100      	movs	r1, #0
      huart->Instance->BRR = usartdiv;
 8004774:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 8004776:	e9c4 1118 	strd	r1, r1, [r4, #96]	; 0x60
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800477a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800477c:	2a00      	cmp	r2, #0
 800477e:	d176      	bne.n	800486e <HAL_UART_Init+0x272>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004780:	685a      	ldr	r2, [r3, #4]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004782:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004784:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8004788:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800478a:	689a      	ldr	r2, [r3, #8]
 800478c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8004790:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8004792:	681a      	ldr	r2, [r3, #0]
 8004794:	f042 0201 	orr.w	r2, r2, #1
 8004798:	601a      	str	r2, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800479a:	67e1      	str	r1, [r4, #124]	; 0x7c
  tickstart = HAL_GetTick();
 800479c:	f7fb ff08 	bl	80005b0 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80047a0:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 80047a2:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80047a4:	681a      	ldr	r2, [r3, #0]
 80047a6:	0712      	lsls	r2, r2, #28
 80047a8:	d407      	bmi.n	80047ba <HAL_UART_Init+0x1be>
  huart->gState = HAL_UART_STATE_READY;
 80047aa:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
 80047ac:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 80047ae:	6762      	str	r2, [r4, #116]	; 0x74
  return HAL_OK;
 80047b0:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 80047b2:	67a2      	str	r2, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 80047b4:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80047b8:	bd70      	pop	{r4, r5, r6, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80047ba:	69dd      	ldr	r5, [r3, #28]
 80047bc:	f415 1500 	ands.w	r5, r5, #2097152	; 0x200000
 80047c0:	d1f3      	bne.n	80047aa <HAL_UART_Init+0x1ae>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80047c2:	f7fb fef5 	bl	80005b0 <HAL_GetTick>
 80047c6:	1b80      	subs	r0, r0, r6
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80047c8:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80047ca:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 80047ce:	d3f4      	bcc.n	80047ba <HAL_UART_Init+0x1be>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80047d0:	681a      	ldr	r2, [r3, #0]
        huart->gState = HAL_UART_STATE_READY;
 80047d2:	2120      	movs	r1, #32
      return HAL_TIMEOUT;
 80047d4:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80047d6:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 80047da:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80047dc:	689a      	ldr	r2, [r3, #8]
 80047de:	f022 0201 	bic.w	r2, r2, #1
 80047e2:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 80047e4:	6761      	str	r1, [r4, #116]	; 0x74
        __HAL_UNLOCK(huart);
 80047e6:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 80047ea:	67a1      	str	r1, [r4, #120]	; 0x78
}
 80047ec:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 80047ee:	2b00      	cmp	r3, #0
 80047f0:	f47f af4c 	bne.w	800468c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80047f4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80047f8:	d07a      	beq.n	80048f0 <HAL_UART_Init+0x2f4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80047fa:	f7fd ffcb 	bl	8002794 <HAL_RCC_GetPCLK1Freq>
 80047fe:	6863      	ldr	r3, [r4, #4]
 8004800:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 8004804:	fbb2 f2f3 	udiv	r2, r2, r3
 8004808:	b292      	uxth	r2, r2
 800480a:	e7ab      	b.n	8004764 <HAL_UART_Init+0x168>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800480c:	4b4b      	ldr	r3, [pc, #300]	; (800493c <HAL_UART_Init+0x340>)
 800480e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004812:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8004816:	2b10      	cmp	r3, #16
 8004818:	d015      	beq.n	8004846 <HAL_UART_Init+0x24a>
 800481a:	d9e8      	bls.n	80047ee <HAL_UART_Init+0x1f2>
 800481c:	2b20      	cmp	r3, #32
 800481e:	d14f      	bne.n	80048c0 <HAL_UART_Init+0x2c4>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004820:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8004824:	d05c      	beq.n	80048e0 <HAL_UART_Init+0x2e4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8004826:	6863      	ldr	r3, [r4, #4]
 8004828:	4a47      	ldr	r2, [pc, #284]	; (8004948 <HAL_UART_Init+0x34c>)
 800482a:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 800482e:	fbb2 f2f3 	udiv	r2, r2, r3
 8004832:	b292      	uxth	r2, r2
 8004834:	e796      	b.n	8004764 <HAL_UART_Init+0x168>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004836:	4b41      	ldr	r3, [pc, #260]	; (800493c <HAL_UART_Init+0x340>)
 8004838:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800483c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004840:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004844:	d118      	bne.n	8004878 <HAL_UART_Init+0x27c>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004846:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800484a:	d046      	beq.n	80048da <HAL_UART_Init+0x2de>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800484c:	f7fd ff6e 	bl	800272c <HAL_RCC_GetSysClockFreq>
 8004850:	6863      	ldr	r3, [r4, #4]
 8004852:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 8004856:	fbb2 f2f3 	udiv	r2, r2, r3
 800485a:	b292      	uxth	r2, r2
 800485c:	e782      	b.n	8004764 <HAL_UART_Init+0x168>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800485e:	6863      	ldr	r3, [r4, #4]
 8004860:	085a      	lsrs	r2, r3, #1
 8004862:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 8004866:	fbb2 f2f3 	udiv	r2, r2, r3
 800486a:	b292      	uxth	r2, r2
 800486c:	e77a      	b.n	8004764 <HAL_UART_Init+0x168>
    UART_AdvFeatureConfig(huart);
 800486e:	4620      	mov	r0, r4
 8004870:	f7ff fe6c 	bl	800454c <UART_AdvFeatureConfig>
 8004874:	6823      	ldr	r3, [r4, #0]
 8004876:	e783      	b.n	8004780 <HAL_UART_Init+0x184>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004878:	d9b9      	bls.n	80047ee <HAL_UART_Init+0x1f2>
 800487a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800487e:	d0cf      	beq.n	8004820 <HAL_UART_Init+0x224>
 8004880:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004884:	f47f af02 	bne.w	800468c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004888:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800488c:	d1e7      	bne.n	800485e <HAL_UART_Init+0x262>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800488e:	6862      	ldr	r2, [r4, #4]
 8004890:	0853      	lsrs	r3, r2, #1
 8004892:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8004896:	fbb3 f3f2 	udiv	r3, r3, r2
 800489a:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800489c:	f1a3 0110 	sub.w	r1, r3, #16
 80048a0:	f64f 72ef 	movw	r2, #65519	; 0xffef
 80048a4:	4291      	cmp	r1, r2
 80048a6:	f63f aef1 	bhi.w	800468c <HAL_UART_Init+0x90>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80048aa:	f023 010f 	bic.w	r1, r3, #15
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80048ae:	f3c3 0242 	ubfx	r2, r3, #1, #3
  huart->RxISR = NULL;
 80048b2:	2000      	movs	r0, #0
      huart->Instance->BRR = brrtemp;
 80048b4:	6823      	ldr	r3, [r4, #0]
 80048b6:	430a      	orrs	r2, r1
 80048b8:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 80048ba:	e9c4 0018 	strd	r0, r0, [r4, #96]	; 0x60
 80048be:	e75c      	b.n	800477a <HAL_UART_Init+0x17e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80048c0:	2b30      	cmp	r3, #48	; 0x30
 80048c2:	d0e1      	beq.n	8004888 <HAL_UART_Init+0x28c>
 80048c4:	e6e2      	b.n	800468c <HAL_UART_Init+0x90>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 80048c6:	f7fd ff75 	bl	80027b4 <HAL_RCC_GetPCLK2Freq>
 80048ca:	6862      	ldr	r2, [r4, #4]
 80048cc:	0853      	lsrs	r3, r2, #1
 80048ce:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80048d2:	fbb3 f3f2 	udiv	r3, r3, r2
 80048d6:	b29b      	uxth	r3, r3
 80048d8:	e7e0      	b.n	800489c <HAL_UART_Init+0x2a0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80048da:	f7fd ff27 	bl	800272c <HAL_RCC_GetSysClockFreq>
 80048de:	e7f4      	b.n	80048ca <HAL_UART_Init+0x2ce>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 80048e0:	6862      	ldr	r2, [r4, #4]
 80048e2:	4b1a      	ldr	r3, [pc, #104]	; (800494c <HAL_UART_Init+0x350>)
 80048e4:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80048e8:	fbb3 f3f2 	udiv	r3, r3, r2
 80048ec:	b29b      	uxth	r3, r3
 80048ee:	e7d5      	b.n	800489c <HAL_UART_Init+0x2a0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80048f0:	f7fd ff50 	bl	8002794 <HAL_RCC_GetPCLK1Freq>
 80048f4:	e7e9      	b.n	80048ca <HAL_UART_Init+0x2ce>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80048f6:	4b11      	ldr	r3, [pc, #68]	; (800493c <HAL_UART_Init+0x340>)
 80048f8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80048fc:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8004900:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8004904:	d09f      	beq.n	8004846 <HAL_UART_Init+0x24a>
 8004906:	f67f af72 	bls.w	80047ee <HAL_UART_Init+0x1f2>
 800490a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800490e:	d087      	beq.n	8004820 <HAL_UART_Init+0x224>
 8004910:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8004914:	d0b8      	beq.n	8004888 <HAL_UART_Init+0x28c>
 8004916:	e6b9      	b.n	800468c <HAL_UART_Init+0x90>
 8004918:	efff69f3 	.word	0xefff69f3
 800491c:	40011000 	.word	0x40011000
 8004920:	40004400 	.word	0x40004400
 8004924:	40004800 	.word	0x40004800
 8004928:	40004c00 	.word	0x40004c00
 800492c:	40005000 	.word	0x40005000
 8004930:	40011400 	.word	0x40011400
 8004934:	40007800 	.word	0x40007800
 8004938:	40007c00 	.word	0x40007c00
 800493c:	40023800 	.word	0x40023800
 8004940:	08009948 	.word	0x08009948
 8004944:	0800994c 	.word	0x0800994c
 8004948:	00f42400 	.word	0x00f42400
 800494c:	01e84800 	.word	0x01e84800
 8004950:	4b13      	ldr	r3, [pc, #76]	; (80049a0 <HAL_UART_Init+0x3a4>)
 8004952:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004956:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800495a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800495e:	f43f af72 	beq.w	8004846 <HAL_UART_Init+0x24a>
 8004962:	f67f aef1 	bls.w	8004748 <HAL_UART_Init+0x14c>
 8004966:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800496a:	f43f af59 	beq.w	8004820 <HAL_UART_Init+0x224>
 800496e:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8004972:	d089      	beq.n	8004888 <HAL_UART_Init+0x28c>
 8004974:	e68a      	b.n	800468c <HAL_UART_Init+0x90>
 8004976:	4b0a      	ldr	r3, [pc, #40]	; (80049a0 <HAL_UART_Init+0x3a4>)
 8004978:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800497c:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8004980:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8004984:	f43f af5f 	beq.w	8004846 <HAL_UART_Init+0x24a>
 8004988:	f67f af31 	bls.w	80047ee <HAL_UART_Init+0x1f2>
 800498c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004990:	f43f af46 	beq.w	8004820 <HAL_UART_Init+0x224>
 8004994:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8004998:	f43f af76 	beq.w	8004888 <HAL_UART_Init+0x28c>
 800499c:	e676      	b.n	800468c <HAL_UART_Init+0x90>
 800499e:	bf00      	nop
 80049a0:	40023800 	.word	0x40023800

080049a4 <PWM_initialize>:

/*
 * Initialize PWM module
 */
void PWM_initialize(void)
{
 80049a4:	b510      	push	{r4, lr}
  	// Start PWM outputs
	HAL_TIM_Base_Start(&htim1);
 80049a6:	4c13      	ldr	r4, [pc, #76]	; (80049f4 <PWM_initialize+0x50>)
 80049a8:	4620      	mov	r0, r4
 80049aa:	f7fe fe17 	bl	80035dc <HAL_TIM_Base_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 80049ae:	2100      	movs	r1, #0
 80049b0:	4620      	mov	r0, r4
 80049b2:	f7fe fef5 	bl	80037a0 <HAL_TIM_PWM_Start>
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1);
 80049b6:	2100      	movs	r1, #0
 80049b8:	4620      	mov	r0, r4
 80049ba:	f7ff fa53 	bl	8003e64 <HAL_TIMEx_PWMN_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
 80049be:	2104      	movs	r1, #4
 80049c0:	4620      	mov	r0, r4
 80049c2:	f7fe feed 	bl	80037a0 <HAL_TIM_PWM_Start>
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);
 80049c6:	2104      	movs	r1, #4
 80049c8:	4620      	mov	r0, r4
 80049ca:	f7ff fa4b 	bl	8003e64 <HAL_TIMEx_PWMN_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
 80049ce:	2108      	movs	r1, #8
 80049d0:	4620      	mov	r0, r4
 80049d2:	f7fe fee5 	bl	80037a0 <HAL_TIM_PWM_Start>
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);
 80049d6:	2108      	movs	r1, #8
 80049d8:	4620      	mov	r0, r4
 80049da:	f7ff fa43 	bl	8003e64 <HAL_TIMEx_PWMN_Start>

	// Set duty cycle to 50%
	mc_vars.duty_cycles[0] = 3375;
 80049de:	f640 532f 	movw	r3, #3375	; 0xd2f
	mc_vars.duty_cycles[1] = 3375;
	mc_vars.duty_cycles[2] = 3375;

	// Update compare registers
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, mc_vars.duty_cycles[0]);
 80049e2:	6822      	ldr	r2, [r4, #0]
	mc_vars.duty_cycles[0] = 3375;
 80049e4:	4904      	ldr	r1, [pc, #16]	; (80049f8 <PWM_initialize+0x54>)
	mc_vars.duty_cycles[1] = 3375;
 80049e6:	e9c1 3313 	strd	r3, r3, [r1, #76]	; 0x4c
	mc_vars.duty_cycles[2] = 3375;
 80049ea:	654b      	str	r3, [r1, #84]	; 0x54
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, mc_vars.duty_cycles[0]);
 80049ec:	6353      	str	r3, [r2, #52]	; 0x34
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, mc_vars.duty_cycles[1]);
 80049ee:	6393      	str	r3, [r2, #56]	; 0x38
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_3, mc_vars.duty_cycles[2]);
 80049f0:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 80049f2:	bd10      	pop	{r4, pc}
 80049f4:	200022a0 	.word	0x200022a0
 80049f8:	200021cc 	.word	0x200021cc
 80049fc:	00000000 	.word	0x00000000

08004a00 <inverse_park_transform>:

/*
 * Inverse Park Transform
 */
void inverse_park_transform(void) {
 8004a00:	b510      	push	{r4, lr}
	float theta_plus_2PIdiv3,theta_minus_2PIdiv3;
	float sinArray[3];
	float cosArray[3];
	float Vdc;

	theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 8004a02:	4c41      	ldr	r4, [pc, #260]	; (8004b08 <inverse_park_transform+0x108>)
 8004a04:	ed94 0a06 	vldr	s0, [r4, #24]
 8004a08:	ed9f 6b3b 	vldr	d6, [pc, #236]	; 8004af8 <inverse_park_transform+0xf8>
 8004a0c:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
void inverse_park_transform(void) {
 8004a10:	ed2d 8b06 	vpush	{d8-d10}
	theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 8004a14:	ee37 6b06 	vadd.f64	d6, d7, d6
	if (theta_plus_2PIdiv3 > TWOPI) {
 8004a18:	ed9f 5b39 	vldr	d5, [pc, #228]	; 8004b00 <inverse_park_transform+0x100>
	theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 8004a1c:	eef7 8bc6 	vcvt.f32.f64	s17, d6
	if (theta_plus_2PIdiv3 > TWOPI) {
 8004a20:	eeb7 6ae8 	vcvt.f64.f32	d6, s17
 8004a24:	eeb4 6bc5 	vcmpe.f64	d6, d5
 8004a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a2c:	dd03      	ble.n	8004a36 <inverse_park_transform+0x36>
		theta_plus_2PIdiv3 -= TWOPI;
 8004a2e:	ee36 6b45 	vsub.f64	d6, d6, d5
 8004a32:	eef7 8bc6 	vcvt.f32.f64	s17, d6
	}
	theta_minus_2PIdiv3 = mc_vars.theta_e - TWOPIDIV3;
 8004a36:	ed9f 6b30 	vldr	d6, [pc, #192]	; 8004af8 <inverse_park_transform+0xf8>
 8004a3a:	ee37 7b46 	vsub.f64	d7, d7, d6
 8004a3e:	eeb7 8bc7 	vcvt.f32.f64	s16, d7
	if (theta_minus_2PIdiv3 <0) {
 8004a42:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8004a46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a4a:	d507      	bpl.n	8004a5c <inverse_park_transform+0x5c>
		theta_minus_2PIdiv3 += TWOPI;
 8004a4c:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
 8004a50:	ed9f 6b2b 	vldr	d6, [pc, #172]	; 8004b00 <inverse_park_transform+0x100>
 8004a54:	ee37 7b06 	vadd.f64	d7, d7, d6
 8004a58:	eeb7 8bc7 	vcvt.f32.f64	s16, d7
	}

	sinArray[0] = sin_interpolation(mc_vars.theta_e);
 8004a5c:	f000 fbf8 	bl	8005250 <sin_interpolation>
 8004a60:	eef0 aa40 	vmov.f32	s21, s0
	sinArray[1] = sin_interpolation(theta_minus_2PIdiv3);
 8004a64:	eeb0 0a48 	vmov.f32	s0, s16
 8004a68:	f000 fbf2 	bl	8005250 <sin_interpolation>
 8004a6c:	eef0 9a40 	vmov.f32	s19, s0
	sinArray[2] = sin_interpolation(theta_plus_2PIdiv3);
 8004a70:	eeb0 0a68 	vmov.f32	s0, s17
 8004a74:	f000 fbec 	bl	8005250 <sin_interpolation>
 8004a78:	eeb0 aa40 	vmov.f32	s20, s0

	cosArray[0] = cos_interpolation(mc_vars.theta_e);
 8004a7c:	ed94 0a06 	vldr	s0, [r4, #24]
 8004a80:	f000 fc1a 	bl	80052b8 <cos_interpolation>
 8004a84:	eeb0 9a40 	vmov.f32	s18, s0
	cosArray[1] = cos_interpolation(theta_minus_2PIdiv3);
 8004a88:	eeb0 0a48 	vmov.f32	s0, s16
 8004a8c:	f000 fc14 	bl	80052b8 <cos_interpolation>
 8004a90:	eeb0 8a40 	vmov.f32	s16, s0
	cosArray[2] = cos_interpolation(theta_plus_2PIdiv3);
 8004a94:	eeb0 0a68 	vmov.f32	s0, s17
 8004a98:	f000 fc0e 	bl	80052b8 <cos_interpolation>
 8004a9c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004aa0:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 8004b0c <inverse_park_transform+0x10c>
 8004aa4:	edd4 7a07 	vldr	s15, [r4, #28]

	// Avoid dividing future calculations by 0 by making Vdc really small if Vdc = 0
	Vdc = check_zero_Vdc();

	// Va, Vb, Vc are divided by Vdc here to keep the floating point calculation together
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004aa8:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
 8004aac:	fec7 7a87 	vmaxnm.f32	s15, s15, s14
 8004ab0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004ab4:	edd4 6a08 	vldr	s13, [r4, #32]
	Vb = (sinArray[1] * mc_vars.vdq_ref[0] + cosArray[1] * mc_vars.vdq_ref[1])/Vdc;
 8004ab8:	4b15      	ldr	r3, [pc, #84]	; (8004b10 <inverse_park_transform+0x110>)
	Vc = (sinArray[2] * mc_vars.vdq_ref[0] + cosArray[2] * mc_vars.vdq_ref[1])/Vdc;
 8004aba:	4916      	ldr	r1, [pc, #88]	; (8004b14 <inverse_park_transform+0x114>)
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004abc:	4a16      	ldr	r2, [pc, #88]	; (8004b18 <inverse_park_transform+0x118>)
	Vb = (sinArray[1] * mc_vars.vdq_ref[0] + cosArray[1] * mc_vars.vdq_ref[1])/Vdc;
 8004abe:	ee28 8a06 	vmul.f32	s16, s16, s12
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004ac2:	ee69 7a06 	vmul.f32	s15, s18, s12
	Vc = (sinArray[2] * mc_vars.vdq_ref[0] + cosArray[2] * mc_vars.vdq_ref[1])/Vdc;
 8004ac6:	ee20 0a06 	vmul.f32	s0, s0, s12
	Vb = (sinArray[1] * mc_vars.vdq_ref[0] + cosArray[1] * mc_vars.vdq_ref[1])/Vdc;
 8004aca:	eea9 8aa6 	vfma.f32	s16, s19, s13
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004ace:	eeea 7aa6 	vfma.f32	s15, s21, s13
	Vc = (sinArray[2] * mc_vars.vdq_ref[0] + cosArray[2] * mc_vars.vdq_ref[1])/Vdc;
 8004ad2:	eeaa 0a26 	vfma.f32	s0, s20, s13
	Vb = (sinArray[1] * mc_vars.vdq_ref[0] + cosArray[1] * mc_vars.vdq_ref[1])/Vdc;
 8004ad6:	ee28 8a07 	vmul.f32	s16, s16, s14
	Vc = (sinArray[2] * mc_vars.vdq_ref[0] + cosArray[2] * mc_vars.vdq_ref[1])/Vdc;
 8004ada:	ee20 0a07 	vmul.f32	s0, s0, s14
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004ade:	ee67 7a87 	vmul.f32	s15, s15, s14
	Vb = (sinArray[1] * mc_vars.vdq_ref[0] + cosArray[1] * mc_vars.vdq_ref[1])/Vdc;
 8004ae2:	ed83 8a00 	vstr	s16, [r3]
	Vc = (sinArray[2] * mc_vars.vdq_ref[0] + cosArray[2] * mc_vars.vdq_ref[1])/Vdc;
 8004ae6:	ed81 0a00 	vstr	s0, [r1]
	Va = (sinArray[0] * mc_vars.vdq_ref[0] + cosArray[0] * mc_vars.vdq_ref[1])/Vdc;
 8004aea:	edc2 7a00 	vstr	s15, [r2]
}
 8004aee:	ecbd 8b06 	vpop	{d8-d10}
 8004af2:	bd10      	pop	{r4, pc}
 8004af4:	f3af 8000 	nop.w
 8004af8:	382d574a 	.word	0x382d574a
 8004afc:	4000c152 	.word	0x4000c152
 8004b00:	54442eea 	.word	0x54442eea
 8004b04:	401921fb 	.word	0x401921fb
 8004b08:	200021cc 	.word	0x200021cc
 8004b0c:	25800000 	.word	0x25800000
 8004b10:	200021c8 	.word	0x200021c8
 8004b14:	2000212c 	.word	0x2000212c
 8004b18:	20002128 	.word	0x20002128

08004b1c <PWM_TswCalculations>:
{
 8004b1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Tas = mc_params.Tswh_int*Va;
 8004b20:	4d4c      	ldr	r5, [pc, #304]	; (8004c54 <PWM_TswCalculations+0x138>)
{
 8004b22:	b083      	sub	sp, #12
  inverse_park_transform();
 8004b24:	f7ff ff6c 	bl	8004a00 <inverse_park_transform>
  Tcs = mc_params.Tswh_int*Vc;
 8004b28:	4b4b      	ldr	r3, [pc, #300]	; (8004c58 <PWM_TswCalculations+0x13c>)
  Tas = mc_params.Tswh_int*Va;
 8004b2a:	edd5 7a1b 	vldr	s15, [r5, #108]	; 0x6c
 8004b2e:	494b      	ldr	r1, [pc, #300]	; (8004c5c <PWM_TswCalculations+0x140>)
  Tbs = mc_params.Tswh_int*Vb;
 8004b30:	4a4b      	ldr	r2, [pc, #300]	; (8004c60 <PWM_TswCalculations+0x144>)
  Tas = mc_params.Tswh_int*Va;
 8004b32:	eef8 7a67 	vcvt.f32.u32	s15, s15
  Tcs = mc_params.Tswh_int*Vc;
 8004b36:	ed93 6a00 	vldr	s12, [r3]
  Tas = mc_params.Tswh_int*Va;
 8004b3a:	edd1 6a00 	vldr	s13, [r1]
  Tbs = mc_params.Tswh_int*Vb;
 8004b3e:	ed92 7a00 	vldr	s14, [r2]
  Tas = mc_params.Tswh_int*Va;
 8004b42:	ee67 6aa6 	vmul.f32	s13, s15, s13
  Tbs = mc_params.Tswh_int*Vb;
 8004b46:	ee27 7a87 	vmul.f32	s14, s15, s14
  Tcs = mc_params.Tswh_int*Vc;
 8004b4a:	ee67 7a86 	vmul.f32	s15, s15, s12
  Tas = mc_params.Tswh_int*Va;
 8004b4e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  Tbs = mc_params.Tswh_int*Vb;
 8004b52:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  Tcs = mc_params.Tswh_int*Vc;
 8004b56:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  Tas = mc_params.Tswh_int*Va;
 8004b5a:	ee16 6a90 	vmov	r6, s13
  Tqmax = max(Tas, Tbs, Tcs);
 8004b5e:	ee16 0a90 	vmov	r0, s13
  Tbs = mc_params.Tswh_int*Vb;
 8004b62:	ee17 7a10 	vmov	r7, s14
  Tqmax = max(Tas, Tbs, Tcs);
 8004b66:	ee17 1a10 	vmov	r1, s14
  Tcs = mc_params.Tswh_int*Vc;
 8004b6a:	ee17 4a90 	vmov	r4, s15
  Tqmax = max(Tas, Tbs, Tcs);
 8004b6e:	ee17 2a90 	vmov	r2, s15
 8004b72:	f000 fbed 	bl	8005350 <max>
 8004b76:	4680      	mov	r8, r0
  Tqmin = min(Tas, Tbs, Tcs);
 8004b78:	4622      	mov	r2, r4
 8004b7a:	4639      	mov	r1, r7
 8004b7c:	4630      	mov	r0, r6
 8004b7e:	f000 fbf3 	bl	8005368 <min>
  Tqoffset = (mc_params.Tswh_int - (Tqmax - Tqmin)) / 2 - Tqmin;
 8004b82:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8004b84:	eba8 0800 	sub.w	r8, r8, r0
  Tga_on = iSaturate(Tga_on, 0, mc_params.Tsw_int);
 8004b88:	6eaa      	ldr	r2, [r5, #104]	; 0x68
 8004b8a:	2100      	movs	r1, #0
  Tqoffset = (mc_params.Tswh_int - (Tqmax - Tqmin)) / 2 - Tqmin;
 8004b8c:	eba3 0808 	sub.w	r8, r3, r8
 8004b90:	ebc0 0058 	rsb	r0, r0, r8, lsr #1
  Tgb_off_h = Tbs + Tqoffset;
 8004b94:	4407      	add	r7, r0
  Tgc_off_h = Tcs + Tqoffset;
 8004b96:	4404      	add	r4, r0
  Tga_off_h = Tas + Tqoffset;
 8004b98:	4406      	add	r6, r0
  Tgb_on = mc_params.Tswh_int - Tgb_off_h;
 8004b9a:	eba3 0a07 	sub.w	sl, r3, r7
  Tgc_on = mc_params.Tswh_int - Tgc_off_h;
 8004b9e:	eba3 0b04 	sub.w	fp, r3, r4
  Tga_on = iSaturate(Tga_on, 0, mc_params.Tsw_int);
 8004ba2:	1b98      	subs	r0, r3, r6
  Tgb_off = Tgb_off_h + mc_params.Tswh_int;
 8004ba4:	eb03 0907 	add.w	r9, r3, r7
  Tgc_off = Tgc_off_h + mc_params.Tswh_int;
 8004ba8:	441c      	add	r4, r3
  Tga_off = Tga_off_h + mc_params.Tswh_int;
 8004baa:	441e      	add	r6, r3
  Tga_on = iSaturate(Tga_on, 0, mc_params.Tsw_int);
 8004bac:	f000 fbc8 	bl	8005340 <iSaturate>
  Tgb_on = iSaturate(Tgb_on, 0, mc_params.Tsw_int);
 8004bb0:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  Tga_on = iSaturate(Tga_on, 0, mc_params.Tsw_int);
 8004bb2:	9001      	str	r0, [sp, #4]
  Tgb_on = iSaturate(Tgb_on, 0, mc_params.Tsw_int);
 8004bb4:	2100      	movs	r1, #0
 8004bb6:	4650      	mov	r0, sl
 8004bb8:	f000 fbc2 	bl	8005340 <iSaturate>
  Tgc_on = iSaturate(Tgc_on, 0, mc_params.Tsw_int);
 8004bbc:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  Tgb_on = iSaturate(Tgb_on, 0, mc_params.Tsw_int);
 8004bbe:	4682      	mov	sl, r0
  Tgc_on = iSaturate(Tgc_on, 0, mc_params.Tsw_int);
 8004bc0:	2100      	movs	r1, #0
 8004bc2:	4658      	mov	r0, fp
 8004bc4:	f000 fbbc 	bl	8005340 <iSaturate>
  Tga_off = iSaturate(Tga_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bc8:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  Tgc_on = iSaturate(Tgc_on, 0, mc_params.Tsw_int);
 8004bca:	4683      	mov	fp, r0
  Tga_off = iSaturate(Tga_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bcc:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
 8004bce:	4630      	mov	r0, r6
 8004bd0:	f000 fbb6 	bl	8005340 <iSaturate>
  Tgb_off = iSaturate(Tgb_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bd4:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  Tga_off = iSaturate(Tga_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bd6:	4607      	mov	r7, r0
  Tgb_off = iSaturate(Tgb_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bd8:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
 8004bda:	4648      	mov	r0, r9
 8004bdc:	f000 fbb0 	bl	8005340 <iSaturate>
  Tgc_off = iSaturate(Tgc_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004be0:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  Tgb_off = iSaturate(Tgb_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004be2:	4606      	mov	r6, r0
  Tgc_off = iSaturate(Tgc_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004be4:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
 8004be6:	4620      	mov	r0, r4
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004be8:	4c1e      	ldr	r4, [pc, #120]	; (8004c64 <PWM_TswCalculations+0x148>)
  Tgc_off = iSaturate(Tgc_off,mc_params.Tswh_int,mc_params.Tsw_int);
 8004bea:	f000 fba9 	bl	8005340 <iSaturate>
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004bee:	9b01      	ldr	r3, [sp, #4]
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004bf0:	eba0 000b 	sub.w	r0, r0, fp
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004bf4:	ed95 6a24 	vldr	s12, [r5, #144]	; 0x90
 8004bf8:	1afb      	subs	r3, r7, r3
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004bfa:	ee07 0a90 	vmov	s15, r0
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004bfe:	ee06 3a90 	vmov	s13, r3
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c02:	eba6 030a 	sub.w	r3, r6, sl
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004c06:	eef8 7a67 	vcvt.f32.u32	s15, s15
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c0a:	ee07 3a10 	vmov	s14, r3
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004c0e:	eef8 6a66 	vcvt.f32.u32	s13, s13
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, mc_vars.duty_cycles[0]);
 8004c12:	4b15      	ldr	r3, [pc, #84]	; (8004c68 <PWM_TswCalculations+0x14c>)
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004c14:	ee67 7a86 	vmul.f32	s15, s15, s12
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c18:	eeb8 7a47 	vcvt.f32.u32	s14, s14
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, mc_vars.duty_cycles[0]);
 8004c1c:	6818      	ldr	r0, [r3, #0]
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004c1e:	ee66 6a86 	vmul.f32	s13, s13, s12
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004c22:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c26:	ee27 7a06 	vmul.f32	s14, s14, s12
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004c2a:	eefc 6ae6 	vcvt.u32.f32	s13, s13
  mc_vars.duty_cycles[2] = (uint32_t) (Tgc_off - Tgc_on) * mc_params.PWM_Multiplier;
 8004c2e:	ee17 3a90 	vmov	r3, s15
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c32:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  mc_vars.duty_cycles[0] = (uint32_t) (Tga_off - Tga_on) * mc_params.PWM_Multiplier;
 8004c36:	edc4 6a13 	vstr	s13, [r4, #76]	; 0x4c
  mc_vars.duty_cycles[1] = (uint32_t) (Tgb_off - Tgb_on) * mc_params.PWM_Multiplier;
 8004c3a:	ee17 2a90 	vmov	r2, s15
 8004c3e:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, mc_vars.duty_cycles[0]);
 8004c42:	edc0 6a0d 	vstr	s13, [r0, #52]	; 0x34
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, mc_vars.duty_cycles[1]);
 8004c46:	edc0 7a0e 	vstr	s15, [r0, #56]	; 0x38
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_3, mc_vars.duty_cycles[2]);
 8004c4a:	63c3      	str	r3, [r0, #60]	; 0x3c
}
 8004c4c:	b003      	add	sp, #12
 8004c4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004c52:	bf00      	nop
 8004c54:	20002130 	.word	0x20002130
 8004c58:	2000212c 	.word	0x2000212c
 8004c5c:	20002128 	.word	0x20002128
 8004c60:	200021c8 	.word	0x200021c8
 8004c64:	200021cc 	.word	0x200021cc
 8004c68:	200022a0 	.word	0x200022a0

08004c6c <HAL_TIM_PeriodElapsedCallback>:
 * 		Settings. Click on the Tool Settings tab. Choose Optimization under the MCU GCC Complier.
 * 		Change the optimization level to Optimize for speed (-Ofast).
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {

	if (htim == &htim3) {
 8004c6c:	4b16      	ldr	r3, [pc, #88]	; (8004cc8 <HAL_TIM_PeriodElapsedCallback+0x5c>)
 8004c6e:	4283      	cmp	r3, r0
 8004c70:	d000      	beq.n	8004c74 <HAL_TIM_PeriodElapsedCallback+0x8>
 8004c72:	4770      	bx	lr
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 8004c74:	b510      	push	{r4, lr}
		Outer_step();
		Inner_step();
		PWM_TswCalculations();

		// log data
		log_push(&mc_vars);
 8004c76:	4c15      	ldr	r4, [pc, #84]	; (8004ccc <HAL_TIM_PeriodElapsedCallback+0x60>)
		start_iabc_conversions(); 	// start phase current conversion on external ADC
 8004c78:	f002 f8c0 	bl	8006dfc <start_iabc_conversions>
		update_rdc_values(); 		// update wElectrical and motor angle
 8004c7c:	f004 fb70 	bl	8009360 <update_rdc_values>
		update_iabc();		  		// update phase currents
 8004c80:	f002 f8f2 	bl	8006e68 <update_iabc>
		check_for_iabc_zeros();		// if Iabc < 0.5A, make them zero (remove noise when not switching)
 8004c84:	f002 f8c2 	bl	8006e0c <check_for_iabc_zeros>
		Torque_step();
 8004c88:	f000 fbe4 	bl	8005454 <Torque_step>
		Outer_step();
 8004c8c:	f000 fb78 	bl	8005380 <Outer_step>
		Inner_step();
 8004c90:	f000 fa36 	bl	8005100 <Inner_step>
		PWM_TswCalculations();
 8004c94:	f7ff ff42 	bl	8004b1c <PWM_TswCalculations>
		log_push(&mc_vars);
 8004c98:	4620      	mov	r0, r4
 8004c9a:	f001 fe2f 	bl	80068fc <log_push>
/*
 * Checks fault pin on the gate driver
 */
static void check_gate_driver_for_fault(void) {
	// gate driver pin is high with no faults
	if(!HAL_GPIO_ReadPin(GATE_DRIVER_FAULT_GPIO_Port, GATE_DRIVER_FAULT_Pin)) {
 8004c9e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004ca2:	480b      	ldr	r0, [pc, #44]	; (8004cd0 <HAL_TIM_PeriodElapsedCallback+0x64>)
 8004ca4:	f7fd fa34 	bl	8002110 <HAL_GPIO_ReadPin>
 8004ca8:	b928      	cbnz	r0, 8004cb6 <HAL_TIM_PeriodElapsedCallback+0x4a>
		mc_vars.fault_reg1 |= 1 << GATE_DRIVER_FAULT_BIT;
 8004caa:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 8004cae:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004cb2:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
		if (!mc_vars.fault) {
 8004cb6:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
 8004cba:	b103      	cbz	r3, 8004cbe <HAL_TIM_PeriodElapsedCallback+0x52>
}
 8004cbc:	bd10      	pop	{r4, pc}
			HAL_TIM_Base_Start_IT(&htim3);
 8004cbe:	4802      	ldr	r0, [pc, #8]	; (8004cc8 <HAL_TIM_PeriodElapsedCallback+0x5c>)
}
 8004cc0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			HAL_TIM_Base_Start_IT(&htim3);
 8004cc4:	f7fe bcba 	b.w	800363c <HAL_TIM_Base_Start_IT>
 8004cc8:	20002260 	.word	0x20002260
 8004ccc:	200021cc 	.word	0x200021cc
 8004cd0:	40020c00 	.word	0x40020c00
 8004cd4:	00000000 	.word	0x00000000

08004cd8 <control_init>:
void control_init(void) {
 8004cd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ho250S_init();
 8004cdc:	f002 faea 	bl	80072b4 <ho250S_init>
	mc_params.bw_idq_hz = 1600; //*((__IO uint32_t *)BW_IDQ_HZ_ADDRESS);
 8004ce0:	f44f 67c8 	mov.w	r7, #1600	; 0x640
	amc1106_init();
 8004ce4:	f004 fbd8 	bl	8009498 <amc1106_init>
	mc_params.n_tq = 5.5; //*((__IO uint32_t *)N_TQ_ADDRESS);
 8004ce8:	2605      	movs	r6, #5
	pga411_Init();
 8004cea:	f003 fac3 	bl	8008274 <pga411_Init>
	mc_params.Pmax = 100; // *((__IO uint32_t *)PMAX_ADDRESS);
 8004cee:	4b44      	ldr	r3, [pc, #272]	; (8004e00 <control_init+0x128>)
	mc_params.Tmax = 75; //225;// *((__IO uint32_t *)TMAX_ADDRESS);
 8004cf0:	204b      	movs	r0, #75	; 0x4b
	mc_params.motorTemp_max = 120; //*((__IO uint32_t *)MOTORTEMP_MAX_ADDRESS);
 8004cf2:	2278      	movs	r2, #120	; 0x78
	mc_params.p = 10.0;//*((__IO uint32_t *)P_ADDRESS);
 8004cf4:	4d43      	ldr	r5, [pc, #268]	; (8004e04 <control_init+0x12c>)
	mc_params.Tmax = 75; //225;// *((__IO uint32_t *)TMAX_ADDRESS);
 8004cf6:	6098      	str	r0, [r3, #8]
	mc_params.Lq = 79e-6; // *((__IO float *)LQ_ADDRESS);
 8004cf8:	4843      	ldr	r0, [pc, #268]	; (8004e08 <control_init+0x130>)
	mc_params.motorTemp_max = 120; //*((__IO uint32_t *)MOTORTEMP_MAX_ADDRESS);
 8004cfa:	625a      	str	r2, [r3, #36]	; 0x24
	mc_params.igbtTemp_corner = 80; //100; //*((__IO uint32_t *)IGBTTEMP_CORNER_ADDRESS);
 8004cfc:	2250      	movs	r2, #80	; 0x50
	mc_params.Lq = 79e-6; // *((__IO float *)LQ_ADDRESS);
 8004cfe:	6118      	str	r0, [r3, #16]
	mc_params.Rs = 8e-3; //*((__IO float *)RS_ADDRESS);
 8004d00:	4842      	ldr	r0, [pc, #264]	; (8004e0c <control_init+0x134>)
	mc_params.bw_idq_hz = 1600; //*((__IO uint32_t *)BW_IDQ_HZ_ADDRESS);
 8004d02:	635f      	str	r7, [r3, #52]	; 0x34
	mc_params.rpm_trigger = 1000; // *((__IO uint32_t *)RPM_TRIGGER_ADDRESS);
 8004d04:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
	mc_params.Rs = 8e-3; //*((__IO float *)RS_ADDRESS);
 8004d08:	6198      	str	r0, [r3, #24]
	mc_params.psim = 0.0355; //*((__IO float *)PSIM_ADDRESS);
 8004d0a:	4841      	ldr	r0, [pc, #260]	; (8004e10 <control_init+0x138>)
	mc_params.n_tq = 5.5; //*((__IO uint32_t *)N_TQ_ADDRESS);
 8004d0c:	63de      	str	r6, [r3, #60]	; 0x3c
	mc_params.Tswh_int = (uint32_t) (mc_params.Tswh * 1.0e9);
 8004d0e:	f647 2612 	movw	r6, #31250	; 0x7a12
	mc_params.psim = 0.0355; //*((__IO float *)PSIM_ADDRESS);
 8004d12:	61d8      	str	r0, [r3, #28]
	mc_params.ke_ll_rpm = 0.0478; //*((__IO float *)KE_LL_RPM_ADDRESS);
 8004d14:	483f      	ldr	r0, [pc, #252]	; (8004e14 <control_init+0x13c>)
	mc_params.Ld = 76e-6; //*((__IO float *)LD_ADDRESS);
 8004d16:	4940      	ldr	r1, [pc, #256]	; (8004e18 <control_init+0x140>)
	mc_params.ke_ll_rpm = 0.0478; //*((__IO float *)KE_LL_RPM_ADDRESS);
 8004d18:	6318      	str	r0, [r3, #48]	; 0x30
	mc_params.fsw = 16.0e3; //*((__IO uint32_t *)FSW_ADDRESS);
 8004d1a:	4840      	ldr	r0, [pc, #256]	; (8004e1c <control_init+0x144>)
	mc_params.p = 10.0;//*((__IO uint32_t *)P_ADDRESS);
 8004d1c:	621d      	str	r5, [r3, #32]
	mc_params.rpm_max = 6500; //*((__IO uint32_t *)RPM_MAX_ADDRESS);
 8004d1e:	f641 1564 	movw	r5, #6500	; 0x1964
	mc_params.fsw = 16.0e3; //*((__IO uint32_t *)FSW_ADDRESS);
 8004d22:	6018      	str	r0, [r3, #0]
	mc_params.t_ramp = 0.05; //*((__IO float *)T_RAMP_ADDRESS);
 8004d24:	483e      	ldr	r0, [pc, #248]	; (8004e20 <control_init+0x148>)
	mc_params.Ld = 76e-6; //*((__IO float *)LD_ADDRESS);
 8004d26:	60d9      	str	r1, [r3, #12]
	mc_params.n_rpm = 14; //*((__IO uint32_t *)N_RPM_ADDRESS);
 8004d28:	210e      	movs	r1, #14
	mc_params.t_ramp = 0.05; //*((__IO float *)T_RAMP_ADDRESS);
 8004d2a:	6418      	str	r0, [r3, #64]	; 0x40
	mc_params.wi = 628.32; // *((__IO float *)WI_ADDRESS);
 8004d2c:	483d      	ldr	r0, [pc, #244]	; (8004e24 <control_init+0x14c>)
	mc_params.igbtTemp_corner = 80; //100; //*((__IO uint32_t *)IGBTTEMP_CORNER_ADDRESS);
 8004d2e:	649a      	str	r2, [r3, #72]	; 0x48
	mc_params.Pmax = 100; // *((__IO uint32_t *)PMAX_ADDRESS);
 8004d30:	2264      	movs	r2, #100	; 0x64
	mc_params.wi = 628.32; // *((__IO float *)WI_ADDRESS);
 8004d32:	64d8      	str	r0, [r3, #76]	; 0x4c
	mc_params.wt = 6.2832; //*((__IO float *)WT_ADDRESS);
 8004d34:	483c      	ldr	r0, [pc, #240]	; (8004e28 <control_init+0x150>)
	mc_params.rpm_trigger = 1000; // *((__IO uint32_t *)RPM_TRIGGER_ADDRESS);
 8004d36:	675f      	str	r7, [r3, #116]	; 0x74
	mc_params.wt = 6.2832; //*((__IO float *)WT_ADDRESS);
 8004d38:	6518      	str	r0, [r3, #80]	; 0x50
	mc_params.Tsw = (float) 1/mc_params.fsw;
 8004d3a:	483c      	ldr	r0, [pc, #240]	; (8004e2c <control_init+0x154>)
	mc_params.Tswh_int = (uint32_t) (mc_params.Tswh * 1.0e9);
 8004d3c:	66de      	str	r6, [r3, #108]	; 0x6c
	mc_params.Tsw = (float) 1/mc_params.fsw;
 8004d3e:	6618      	str	r0, [r3, #96]	; 0x60
	mc_params.Tswh = (float) mc_params.Tsw * 0.5;
 8004d40:	483b      	ldr	r0, [pc, #236]	; (8004e30 <control_init+0x158>)
	mc_params.rpm_max = 6500; //*((__IO uint32_t *)RPM_MAX_ADDRESS);
 8004d42:	62dd      	str	r5, [r3, #44]	; 0x2c
	mc_params.Vhf_mag = 20; // *((__IO uint32_t *)VHF_MAG_ADDRESS);
 8004d44:	2514      	movs	r5, #20
	mc_params.n_rpm = 14; //*((__IO uint32_t *)N_RPM_ADDRESS);
 8004d46:	6399      	str	r1, [r3, #56]	; 0x38
	mc_params.Tsw_int = (uint32_t) (mc_params.Tsw * 1.0e9);
 8004d48:	f24f 4124 	movw	r1, #62500	; 0xf424
	mc_params.Tswh = (float) mc_params.Tsw * 0.5;
 8004d4c:	6658      	str	r0, [r3, #100]	; 0x64
	mc_params.Pmax = 100; // *((__IO uint32_t *)PMAX_ADDRESS);
 8004d4e:	605a      	str	r2, [r3, #4]
	mc_params.motorTemp_corner = 100; //*((__IO uint32_t *)MOTORTEMP_CORNER_ADDRESS);
 8004d50:	629a      	str	r2, [r3, #40]	; 0x28
	mc_params.igbtTemp_max = 100; //150; //*((__IO uint32_t *)IGBTTEMP_MAX_ADDRESS);
 8004d52:	645a      	str	r2, [r3, #68]	; 0x44
	mc_params.Tq_trigger = 100; //*((__IO uint32_t *)TQ_TRIGGER_ADDRESS);
 8004d54:	671a      	str	r2, [r3, #112]	; 0x70
	mc_params.L0 = 0; //*((__IO float *)L0_ADDRESS);
 8004d56:	2200      	movs	r2, #0
	mc_params.PWM_Multiplier = mc_params.fsw / 1e9 * 6749;
 8004d58:	4836      	ldr	r0, [pc, #216]	; (8004e34 <control_init+0x15c>)
	mc_vars.idq[0] = 0;
 8004d5a:	4c37      	ldr	r4, [pc, #220]	; (8004e38 <control_init+0x160>)
	mc_params.Vhf_mag = 20; // *((__IO uint32_t *)VHF_MAG_ADDRESS);
 8004d5c:	655d      	str	r5, [r3, #84]	; 0x54
	mc_params.resolver_offset = 0.06815331309; // rads
 8004d5e:	2500      	movs	r5, #0
	mc_params.L0 = 0; //*((__IO float *)L0_ADDRESS);
 8004d60:	615a      	str	r2, [r3, #20]
	mc_params.Tsw_int = (uint32_t) (mc_params.Tsw * 1.0e9);
 8004d62:	6699      	str	r1, [r3, #104]	; 0x68
	mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_9);
 8004d64:	f44f 7100 	mov.w	r1, #512	; 0x200
	mc_params.Ls = (double) (mc_params.Ld + mc_params.Lq) / 2;
 8004d68:	f20f 0974 	addw	r9, pc, #116	; 0x74
 8004d6c:	e9d9 8900 	ldrd	r8, r9, [r9]
	mc_params.Tsi = (float) mc_params.Tsw/10;
 8004d70:	a71d      	add	r7, pc, #116	; (adr r7, 8004de8 <control_init+0x110>)
 8004d72:	e9d7 6700 	ldrd	r6, r7, [r7]
	mc_params.Ls = (double) (mc_params.Ld + mc_params.Lq) / 2;
 8004d76:	e9c3 8916 	strd	r8, r9, [r3, #88]	; 0x58
	mc_params.Tsi = (float) mc_params.Tsw/10;
 8004d7a:	e9c3 671e 	strd	r6, r7, [r3, #120]	; 0x78
	mc_params.bw_idq = (float) mc_params.bw_idq_hz * 2 * PI;
 8004d7e:	f20f 0970 	addw	r9, pc, #112	; 0x70
 8004d82:	e9d9 8900 	ldrd	r8, r9, [r9]
	mc_params.wMechanical_Sat = mc_params.Pmax * 1000 / mc_params.Tmax;
 8004d86:	a71c      	add	r7, pc, #112	; (adr r7, 8004df8 <control_init+0x120>)
 8004d88:	e9d7 6700 	ldrd	r6, r7, [r7]
	mc_params.bw_idq = (float) mc_params.bw_idq_hz * 2 * PI;
 8004d8c:	e9c3 8920 	strd	r8, r9, [r3, #128]	; 0x80
	mc_params.wMechanical_Sat = mc_params.Pmax * 1000 / mc_params.Tmax;
 8004d90:	e9c3 6722 	strd	r6, r7, [r3, #136]	; 0x88
	mc_params.PWM_Multiplier = mc_params.fsw / 1e9 * 6749;
 8004d94:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_9);
 8004d98:	4828      	ldr	r0, [pc, #160]	; (8004e3c <control_init+0x164>)
	mc_vars.idq[0] = 0;
 8004d9a:	62a2      	str	r2, [r4, #40]	; 0x28
	mc_vars.idq[1] = 0;
 8004d9c:	62e2      	str	r2, [r4, #44]	; 0x2c
	mc_vars.idq_ref[0] = 0;
 8004d9e:	6022      	str	r2, [r4, #0]
	mc_vars.idq_ref[1] = 0;
 8004da0:	6062      	str	r2, [r4, #4]
	mc_vars.vdq_ref[0] = 0;
 8004da2:	6222      	str	r2, [r4, #32]
	mc_vars.vdq_ref[1] = 0;
 8004da4:	6262      	str	r2, [r4, #36]	; 0x24
	mc_params.resolver_offset = 0.06815331309; // rads
 8004da6:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	mc_vars.mc_enable = FALSE;
 8004daa:	6625      	str	r5, [r4, #96]	; 0x60
	mc_vars.fault = FALSE;
 8004dac:	f884 506c 	strb.w	r5, [r4, #108]	; 0x6c
	mc_vars.fault_reg1 = 0;
 8004db0:	f8a4 5070 	strh.w	r5, [r4, #112]	; 0x70
	mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_9);
 8004db4:	f7fd f9ac 	bl	8002110 <HAL_GPIO_ReadPin>
 8004db8:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
	Inner_initialize();
 8004dbc:	f000 f8f0 	bl	8004fa0 <Inner_initialize>

/*
 * Checks for faults on the things that don't check themselves when read (PGA411 fault registers & gate drivers)
 */
static void check_for_faults(void) {
	pga411_checkFaults();
 8004dc0:	f003 fd72 	bl	80088a8 <pga411_checkFaults>
	if(!HAL_GPIO_ReadPin(GATE_DRIVER_FAULT_GPIO_Port, GATE_DRIVER_FAULT_Pin)) {
 8004dc4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004dc8:	481d      	ldr	r0, [pc, #116]	; (8004e40 <control_init+0x168>)
 8004dca:	f7fd f9a1 	bl	8002110 <HAL_GPIO_ReadPin>
 8004dce:	b928      	cbnz	r0, 8004ddc <control_init+0x104>
		mc_vars.fault_reg1 |= 1 << GATE_DRIVER_FAULT_BIT;
 8004dd0:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 8004dd4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004dd8:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
}
 8004ddc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004de0:	c0000000 	.word	0xc0000000
 8004de4:	3f1450ef 	.word	0x3f1450ef
 8004de8:	00000000 	.word	0x00000000
 8004dec:	3eda36e3 	.word	0x3eda36e3
 8004df0:	59d544a7 	.word	0x59d544a7
 8004df4:	40c3a28c 	.word	0x40c3a28c
 8004df8:	00000000 	.word	0x00000000
 8004dfc:	4094d400 	.word	0x4094d400
 8004e00:	20002130 	.word	0x20002130
 8004e04:	41200000 	.word	0x41200000
 8004e08:	38a5accd 	.word	0x38a5accd
 8004e0c:	3c03126f 	.word	0x3c03126f
 8004e10:	3d116873 	.word	0x3d116873
 8004e14:	3d43c9ef 	.word	0x3d43c9ef
 8004e18:	389f6230 	.word	0x389f6230
 8004e1c:	467a0000 	.word	0x467a0000
 8004e20:	3d4ccccd 	.word	0x3d4ccccd
 8004e24:	441d147b 	.word	0x441d147b
 8004e28:	40c90ff9 	.word	0x40c90ff9
 8004e2c:	3883126f 	.word	0x3883126f
 8004e30:	3803126f 	.word	0x3803126f
 8004e34:	3ddd26b7 	.word	0x3ddd26b7
 8004e38:	200021cc 	.word	0x200021cc
 8004e3c:	40021400 	.word	0x40021400
 8004e40:	40020c00 	.word	0x40020c00

08004e44 <check_enable_switch>:
void check_enable_switch(void) {
 8004e44:	b538      	push	{r3, r4, r5, lr}
	if (mc_vars.mc_enable == FALSE) {
 8004e46:	4c3d      	ldr	r4, [pc, #244]	; (8004f3c <check_enable_switch+0xf8>)
 8004e48:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8004e4a:	b98b      	cbnz	r3, 8004e70 <check_enable_switch+0x2c>
		mc_vars.enable_switch_states[PREV_STATE] = mc_vars.enable_switch_states[PRESENT_STATE];
 8004e4c:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
		mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(MC_ENBL_IN_GPIO_Port, MC_ENBL_IN_Pin);
 8004e50:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004e54:	483a      	ldr	r0, [pc, #232]	; (8004f40 <check_enable_switch+0xfc>)
		mc_vars.enable_switch_states[PREV_STATE] = mc_vars.enable_switch_states[PRESENT_STATE];
 8004e56:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
		mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(MC_ENBL_IN_GPIO_Port, MC_ENBL_IN_Pin);
 8004e5a:	f7fd f959 	bl	8002110 <HAL_GPIO_ReadPin>
		if (mc_vars.enable_switch_states[PREV_STATE] == LOW && mc_vars.enable_switch_states[PRESENT_STATE] == HIGH) {
 8004e5e:	4b39      	ldr	r3, [pc, #228]	; (8004f44 <check_enable_switch+0x100>)
		mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(MC_ENBL_IN_GPIO_Port, MC_ENBL_IN_Pin);
 8004e60:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
		if (mc_vars.enable_switch_states[PREV_STATE] == LOW && mc_vars.enable_switch_states[PRESENT_STATE] == HIGH) {
 8004e64:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8004e66:	4013      	ands	r3, r2
 8004e68:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004e6c:	d038      	beq.n	8004ee0 <check_enable_switch+0x9c>
}
 8004e6e:	bd38      	pop	{r3, r4, r5, pc}
		mc_vars.enable_switch_states[PRESENT_STATE] = HAL_GPIO_ReadPin(MC_ENBL_IN_GPIO_Port, MC_ENBL_IN_Pin);
 8004e70:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004e74:	4832      	ldr	r0, [pc, #200]	; (8004f40 <check_enable_switch+0xfc>)
 8004e76:	f7fd f94b 	bl	8002110 <HAL_GPIO_ReadPin>
 8004e7a:	4605      	mov	r5, r0
 8004e7c:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
		if (mc_vars.enable_switch_states[1] == LOW) {
 8004e80:	2800      	cmp	r0, #0
 8004e82:	d1f4      	bne.n	8004e6e <check_enable_switch+0x2a>
	HAL_TIM_Base_Stop(&htim1);
 8004e84:	4830      	ldr	r0, [pc, #192]	; (8004f48 <check_enable_switch+0x104>)
			mc_vars.mc_enable = FALSE;
 8004e86:	6625      	str	r5, [r4, #96]	; 0x60
	HAL_TIM_Base_Stop(&htim1);
 8004e88:	f7fe fbc0 	bl	800360c <HAL_TIM_Base_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
 8004e8c:	4629      	mov	r1, r5
 8004e8e:	482e      	ldr	r0, [pc, #184]	; (8004f48 <check_enable_switch+0x104>)
 8004e90:	f7fe fcb6 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_1);
 8004e94:	4629      	mov	r1, r5
 8004e96:	482c      	ldr	r0, [pc, #176]	; (8004f48 <check_enable_switch+0x104>)
 8004e98:	f7ff f808 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
 8004e9c:	2104      	movs	r1, #4
 8004e9e:	482a      	ldr	r0, [pc, #168]	; (8004f48 <check_enable_switch+0x104>)
 8004ea0:	f7fe fcae 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);
 8004ea4:	2104      	movs	r1, #4
 8004ea6:	4828      	ldr	r0, [pc, #160]	; (8004f48 <check_enable_switch+0x104>)
 8004ea8:	f7ff f800 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
 8004eac:	2108      	movs	r1, #8
 8004eae:	4826      	ldr	r0, [pc, #152]	; (8004f48 <check_enable_switch+0x104>)
 8004eb0:	f7fe fca6 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);
 8004eb4:	2108      	movs	r1, #8
 8004eb6:	4824      	ldr	r0, [pc, #144]	; (8004f48 <check_enable_switch+0x104>)
 8004eb8:	f7fe fff8 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_Base_Stop_IT(&htim3);
 8004ebc:	4823      	ldr	r0, [pc, #140]	; (8004f4c <check_enable_switch+0x108>)
 8004ebe:	f7fe fbd3 	bl	8003668 <HAL_TIM_Base_Stop_IT>
		    if (!mc_vars.fault) {
 8004ec2:	f894 206c 	ldrb.w	r2, [r4, #108]	; 0x6c
 8004ec6:	2a00      	cmp	r2, #0
 8004ec8:	d1d1      	bne.n	8004e6e <check_enable_switch+0x2a>
		    	HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, LOW);
 8004eca:	2102      	movs	r1, #2
 8004ecc:	481c      	ldr	r0, [pc, #112]	; (8004f40 <check_enable_switch+0xfc>)
 8004ece:	f7fd f925 	bl	800211c <HAL_GPIO_WritePin>
		    	HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, HIGH);
 8004ed2:	2201      	movs	r2, #1
 8004ed4:	481a      	ldr	r0, [pc, #104]	; (8004f40 <check_enable_switch+0xfc>)
 8004ed6:	4611      	mov	r1, r2
}
 8004ed8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		    	HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, HIGH);
 8004edc:	f7fd b91e 	b.w	800211c <HAL_GPIO_WritePin>
	pga411_checkFaults();
 8004ee0:	f003 fce2 	bl	80088a8 <pga411_checkFaults>
	if(!HAL_GPIO_ReadPin(GATE_DRIVER_FAULT_GPIO_Port, GATE_DRIVER_FAULT_Pin)) {
 8004ee4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004ee8:	4819      	ldr	r0, [pc, #100]	; (8004f50 <check_enable_switch+0x10c>)
 8004eea:	f7fd f911 	bl	8002110 <HAL_GPIO_ReadPin>
 8004eee:	b928      	cbnz	r0, 8004efc <check_enable_switch+0xb8>
		mc_vars.fault_reg1 |= 1 << GATE_DRIVER_FAULT_BIT;
 8004ef0:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 8004ef4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004ef8:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
		  Inner_initialize();
 8004efc:	f000 f850 	bl	8004fa0 <Inner_initialize>
	if (!mc_vars.fault) {
 8004f00:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
 8004f04:	b173      	cbz	r3, 8004f24 <check_enable_switch+0xe0>
		  if (mc_vars.mc_enable==TRUE) {
 8004f06:	6e24      	ldr	r4, [r4, #96]	; 0x60
 8004f08:	2c01      	cmp	r4, #1
 8004f0a:	d1b0      	bne.n	8004e6e <check_enable_switch+0x2a>
			  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, HIGH);
 8004f0c:	4622      	mov	r2, r4
 8004f0e:	2102      	movs	r1, #2
 8004f10:	480b      	ldr	r0, [pc, #44]	; (8004f40 <check_enable_switch+0xfc>)
 8004f12:	f7fd f903 	bl	800211c <HAL_GPIO_WritePin>
			  HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, LOW);
 8004f16:	4621      	mov	r1, r4
 8004f18:	2200      	movs	r2, #0
 8004f1a:	4809      	ldr	r0, [pc, #36]	; (8004f40 <check_enable_switch+0xfc>)
}
 8004f1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			  HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, LOW);
 8004f20:	f7fd b8fc 	b.w	800211c <HAL_GPIO_WritePin>
		mc_vars.mc_enable = TRUE;
 8004f24:	2501      	movs	r5, #1
 8004f26:	6625      	str	r5, [r4, #96]	; 0x60
		PWM_initialize(); // initializes gate outputs
 8004f28:	f7ff fd3c 	bl	80049a4 <PWM_initialize>
		HAL_Delay(1);
 8004f2c:	4628      	mov	r0, r5
 8004f2e:	f7fb fb45 	bl	80005bc <HAL_Delay>
		HAL_TIM_Base_Start_IT(&htim3); // starts control system interrupts
 8004f32:	4806      	ldr	r0, [pc, #24]	; (8004f4c <check_enable_switch+0x108>)
 8004f34:	f7fe fb82 	bl	800363c <HAL_TIM_Base_Start_IT>
 8004f38:	e7e5      	b.n	8004f06 <check_enable_switch+0xc2>
 8004f3a:	bf00      	nop
 8004f3c:	200021cc 	.word	0x200021cc
 8004f40:	40021400 	.word	0x40021400
 8004f44:	00ffff00 	.word	0x00ffff00
 8004f48:	200022a0 	.word	0x200022a0
 8004f4c:	20002260 	.word	0x20002260
 8004f50:	40020c00 	.word	0x40020c00

08004f54 <control_disable>:
void control_disable(void) {
 8004f54:	b510      	push	{r4, lr}
	HAL_TIM_Base_Stop(&htim1);
 8004f56:	4c10      	ldr	r4, [pc, #64]	; (8004f98 <control_disable+0x44>)
 8004f58:	4620      	mov	r0, r4
 8004f5a:	f7fe fb57 	bl	800360c <HAL_TIM_Base_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
 8004f5e:	4620      	mov	r0, r4
 8004f60:	2100      	movs	r1, #0
 8004f62:	f7fe fc4d 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_1);
 8004f66:	4620      	mov	r0, r4
 8004f68:	2100      	movs	r1, #0
 8004f6a:	f7fe ff9f 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
 8004f6e:	4620      	mov	r0, r4
 8004f70:	2104      	movs	r1, #4
 8004f72:	f7fe fc45 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);
 8004f76:	4620      	mov	r0, r4
 8004f78:	2104      	movs	r1, #4
 8004f7a:	f7fe ff97 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
 8004f7e:	4620      	mov	r0, r4
 8004f80:	2108      	movs	r1, #8
 8004f82:	f7fe fc3d 	bl	8003800 <HAL_TIM_PWM_Stop>
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);
 8004f86:	4620      	mov	r0, r4
 8004f88:	2108      	movs	r1, #8
 8004f8a:	f7fe ff8f 	bl	8003eac <HAL_TIMEx_PWMN_Stop>
	HAL_TIM_Base_Stop_IT(&htim3);
 8004f8e:	4803      	ldr	r0, [pc, #12]	; (8004f9c <control_disable+0x48>)
}
 8004f90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_TIM_Base_Stop_IT(&htim3);
 8004f94:	f7fe bb68 	b.w	8003668 <HAL_TIM_Base_Stop_IT>
 8004f98:	200022a0 	.word	0x200022a0
 8004f9c:	20002260 	.word	0x20002260

08004fa0 <Inner_initialize>:
 * Initialize PI constants using parameters written by the GUI. Called upon initializing the
 * control system.
 */
void init_PI_constants(void) {
	//  PI controller values
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fa0:	4918      	ldr	r1, [pc, #96]	; (8005004 <Inner_initialize+0x64>)
	pi_iq.Ki = Kb_iq * Ka_iq; 	// Integrator gain iq controller

	pi_id.Kaw = pi_id.Ki;
	pi_iq.Kaw = pi_iq.Ki;

	pi_id.integral = 0.0;
 8004fa2:	2000      	movs	r0, #0
	pi_id.Kp = Ka_id;     		// Proportional gain id controller
 8004fa4:	4a18      	ldr	r2, [pc, #96]	; (8005008 <Inner_initialize+0x68>)
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fa6:	edd1 5a03 	vldr	s11, [r1, #12]
	float Ka_iq = mc_params.Lq * mc_params.bw_idq;
 8004faa:	edd1 4a04 	vldr	s9, [r1, #16]
	float Kb_id = mc_params.Rs / mc_params.Ld;
 8004fae:	ed91 4a06 	vldr	s8, [r1, #24]
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fb2:	eeb7 6ae5 	vcvt.f64.f32	d6, s11
	float Ka_iq = mc_params.Lq * mc_params.bw_idq;
 8004fb6:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
	pi_iq.Kp = Ka_iq;     		// Proportional gain iq controller
 8004fba:	4b14      	ldr	r3, [pc, #80]	; (800500c <Inner_initialize+0x6c>)
	float Kb_id = mc_params.Rs / mc_params.Ld;
 8004fbc:	ee84 5a25 	vdiv.f32	s10, s8, s11
	pi_id.integral = 0.0;
 8004fc0:	6050      	str	r0, [r2, #4]
	pi_iq.integral = 0.0;
 8004fc2:	6058      	str	r0, [r3, #4]
	pi_id.du = 0.0;
 8004fc4:	60d0      	str	r0, [r2, #12]
	pi_iq.du = 0.0;
 8004fc6:	60d8      	str	r0, [r3, #12]
	float Kb_iq = mc_params.Rs / mc_params.Lq;
 8004fc8:	eec4 5a24 	vdiv.f32	s11, s8, s9
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fcc:	ed91 4b20 	vldr	d4, [r1, #128]	; 0x80
	float Ka_iq = mc_params.Lq * mc_params.bw_idq;
 8004fd0:	ee27 7b04 	vmul.f64	d7, d7, d4
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fd4:	ee26 6b04 	vmul.f64	d6, d6, d4
	float Ka_iq = mc_params.Lq * mc_params.bw_idq;
 8004fd8:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	float Ka_id = mc_params.Ld * mc_params.bw_idq;
 8004fdc:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
	pi_iq.Kp = Ka_iq;     		// Proportional gain iq controller
 8004fe0:	ed83 7a04 	vstr	s14, [r3, #16]
	pi_iq.Ki = Kb_iq * Ka_iq; 	// Integrator gain iq controller
 8004fe4:	ee65 7a87 	vmul.f32	s15, s11, s14
	pi_id.Kp = Ka_id;     		// Proportional gain id controller
 8004fe8:	ed82 6a04 	vstr	s12, [r2, #16]
	pi_id.Ki = Kb_id * Ka_id; 	// Integrator gain id controller
 8004fec:	ee25 6a06 	vmul.f32	s12, s10, s12
	pi_iq.Ki = Kb_iq * Ka_iq; 	// Integrator gain iq controller
 8004ff0:	edc3 7a05 	vstr	s15, [r3, #20]
	pi_iq.Kaw = pi_iq.Ki;
 8004ff4:	edc3 7a06 	vstr	s15, [r3, #24]
	pi_id.Ki = Kb_id * Ka_id; 	// Integrator gain id controller
 8004ff8:	ed82 6a05 	vstr	s12, [r2, #20]
	pi_id.Kaw = pi_id.Ki;
 8004ffc:	ed82 6a06 	vstr	s12, [r2, #24]
}
 8005000:	4770      	bx	lr
 8005002:	bf00      	nop
 8005004:	20002130 	.word	0x20002130
 8005008:	200022e0 	.word	0x200022e0
 800500c:	200022fc 	.word	0x200022fc

08005010 <vdq_saturation>:
void vdq_saturation(void) {
 8005010:	b570      	push	{r4, r5, r6, lr}
	vdFF =  mc_vars.idq[1] * mc_params.Lq * mc_vars.wElectrical;
 8005012:	4b35      	ldr	r3, [pc, #212]	; (80050e8 <vdq_saturation+0xd8>)
 8005014:	4c35      	ldr	r4, [pc, #212]	; (80050ec <vdq_saturation+0xdc>)
 8005016:	ed93 7a04 	vldr	s14, [r3, #16]
 800501a:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
	vqFF =  mc_vars.idq[0] * mc_params.Ld * mc_vars.wElectrical +  mc_params.psim * mc_vars.wElectrical ;
 800501e:	edd3 6a03 	vldr	s13, [r3, #12]
 8005022:	ed94 6a0a 	vldr	s12, [r4, #40]	; 0x28
	vdRefUnsat = pi_id.output - vdFF;
 8005026:	ee27 7a67 	vnmul.f32	s14, s14, s15
	vqFF =  mc_vars.idq[0] * mc_params.Ld * mc_vars.wElectrical +  mc_params.psim * mc_vars.wElectrical ;
 800502a:	edd3 7a07 	vldr	s15, [r3, #28]
	vdRefUnsat = pi_id.output - vdFF;
 800502e:	4d30      	ldr	r5, [pc, #192]	; (80050f0 <vdq_saturation+0xe0>)
	vqFF =  mc_vars.idq[0] * mc_params.Ld * mc_vars.wElectrical +  mc_params.psim * mc_vars.wElectrical ;
 8005030:	eee6 7a26 	vfma.f32	s15, s12, s13
	vdFF =  mc_vars.idq[1] * mc_params.Lq * mc_vars.wElectrical;
 8005034:	edd4 6a02 	vldr	s13, [r4, #8]
	vqRefUnsat = pi_iq.output + vqFF;
 8005038:	4e2e      	ldr	r6, [pc, #184]	; (80050f4 <vdq_saturation+0xe4>)
void vdq_saturation(void) {
 800503a:	ed2d 8b04 	vpush	{d8-d9}
	vdRefUnsat = pi_id.output - vdFF;
 800503e:	ed95 9a02 	vldr	s18, [r5, #8]
	vqRefUnsat = pi_iq.output + vqFF;
 8005042:	edd6 8a02 	vldr	s17, [r6, #8]
	vdRefUnsat = pi_id.output - vdFF;
 8005046:	eea7 9a26 	vfma.f32	s18, s14, s13
	vqRefUnsat = pi_iq.output + vqFF;
 800504a:	eee6 8aa7 	vfma.f32	s17, s13, s15
	magnitude= sqrt(vqRefUnsat*vqRefUnsat+vdRefUnsat*vdRefUnsat);
 800504e:	ee29 6a09 	vmul.f32	s12, s18, s18
	vdRefMax= absVal(vdRefUnsat)*VphMax/magnitude;
 8005052:	eeb0 0a49 	vmov.f32	s0, s18
	magnitude= sqrt(vqRefUnsat*vqRefUnsat+vdRefUnsat*vdRefUnsat);
 8005056:	eea8 6aa8 	vfma.f32	s12, s17, s17
 800505a:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
 800505e:	eeb1 7bc6 	vsqrt.f64	d7, d6
	VphMax = ONEDIVSQRT3 * mc_vars.Vdc;
 8005062:	ed9f 6b1f 	vldr	d6, [pc, #124]	; 80050e0 <vdq_saturation+0xd0>
	magnitude= sqrt(vqRefUnsat*vqRefUnsat+vdRefUnsat*vdRefUnsat);
 8005066:	eef7 9bc7 	vcvt.f32.f64	s19, d7
	VphMax = ONEDIVSQRT3 * mc_vars.Vdc;
 800506a:	ed94 7a07 	vldr	s14, [r4, #28]
 800506e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
	if (magnitude == 0) { // avoid division by 0
 8005072:	eef5 9a40 	vcmp.f32	s19, #0.0
	VphMax = ONEDIVSQRT3 * mc_vars.Vdc;
 8005076:	ee27 7b06 	vmul.f64	d7, d7, d6
	if (magnitude == 0) { // avoid division by 0
 800507a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	VphMax = ONEDIVSQRT3 * mc_vars.Vdc;
 800507e:	eeb7 8bc7 	vcvt.f32.f64	s16, d7
		magnitude = 0.001;
 8005082:	bf08      	it	eq
 8005084:	eddf 9a1c 	vldreq	s19, [pc, #112]	; 80050f8 <vdq_saturation+0xe8>
	vdRefMax= absVal(vdRefUnsat)*VphMax/magnitude;
 8005088:	f000 f94a 	bl	8005320 <absVal>
 800508c:	ee60 7a08 	vmul.f32	s15, s0, s16
	mc_vars.vdq_ref[0] = fSaturate(vdRefUnsat, -vdRefMax, vdRefMax);
 8005090:	eeb0 0a49 	vmov.f32	s0, s18
	vdRefMax= absVal(vdRefUnsat)*VphMax/magnitude;
 8005094:	ee87 1aa9 	vdiv.f32	s2, s15, s19
	mc_vars.vdq_ref[0] = fSaturate(vdRefUnsat, -vdRefMax, vdRefMax);
 8005098:	eef1 0a41 	vneg.f32	s1, s2
 800509c:	f000 f944 	bl	8005328 <fSaturate>
 80050a0:	ed84 0a08 	vstr	s0, [r4, #32]
	vqRefMax= absVal(vqRefUnsat)*VphMax/magnitude;
 80050a4:	eeb0 0a68 	vmov.f32	s0, s17
 80050a8:	f000 f93a 	bl	8005320 <absVal>
 80050ac:	ee20 8a08 	vmul.f32	s16, s0, s16
	mc_vars.vdq_ref[1] = fSaturate(vqRefUnsat, -vqRefMax, vqRefMax);
 80050b0:	eeb0 0a68 	vmov.f32	s0, s17
	vqRefMax= absVal(vqRefUnsat)*VphMax/magnitude;
 80050b4:	ee88 1a29 	vdiv.f32	s2, s16, s19
	mc_vars.vdq_ref[1] = fSaturate(vqRefUnsat, -vqRefMax, vqRefMax);
 80050b8:	eef1 0a41 	vneg.f32	s1, s2
 80050bc:	f000 f934 	bl	8005328 <fSaturate>
	pi_id.du = mc_vars.vdq_ref[0] - vdRefUnsat;
 80050c0:	edd4 7a08 	vldr	s15, [r4, #32]
	pi_iq.du = mc_vars.vdq_ref[1] - vqRefUnsat;
 80050c4:	ee70 8a68 	vsub.f32	s17, s0, s17
	mc_vars.vdq_ref[1] = fSaturate(vqRefUnsat, -vqRefMax, vqRefMax);
 80050c8:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
	pi_id.du = mc_vars.vdq_ref[0] - vdRefUnsat;
 80050cc:	ee37 9ac9 	vsub.f32	s18, s15, s18
	pi_iq.du = mc_vars.vdq_ref[1] - vqRefUnsat;
 80050d0:	edc6 8a03 	vstr	s17, [r6, #12]
	pi_id.du = mc_vars.vdq_ref[0] - vdRefUnsat;
 80050d4:	ed85 9a03 	vstr	s18, [r5, #12]
}
 80050d8:	ecbd 8b04 	vpop	{d8-d9}
 80050dc:	bd70      	pop	{r4, r5, r6, pc}
 80050de:	bf00      	nop
 80050e0:	45904047 	.word	0x45904047
 80050e4:	3fe279a7 	.word	0x3fe279a7
 80050e8:	20002130 	.word	0x20002130
 80050ec:	200021cc 	.word	0x200021cc
 80050f0:	200022e0 	.word	0x200022e0
 80050f4:	200022fc 	.word	0x200022fc
 80050f8:	3a83126f 	.word	0x3a83126f
 80050fc:	00000000 	.word	0x00000000

08005100 <Inner_step>:
void Inner_step(void) {
 8005100:	b510      	push	{r4, lr}
/*
 * Get the sin values given the current theta value. Used by the park transform and the inverse
 * park transform. Interpolates between sin values given in a sin look up table of 1000 points.
 */
void getSinValues(float* sinArray) {
	sinArray[0] = sin_interpolation(mc_vars.theta_e);
 8005102:	4c4f      	ldr	r4, [pc, #316]	; (8005240 <Inner_step+0x140>)
void Inner_step(void) {
 8005104:	ed2d 8b06 	vpush	{d8-d10}
	sinArray[0] = sin_interpolation(mc_vars.theta_e);
 8005108:	ed94 0a06 	vldr	s0, [r4, #24]
 800510c:	f000 f8a0 	bl	8005250 <sin_interpolation>
 8005110:	eef0 9a40 	vmov.f32	s19, s0
	sinArray[1] = sin_interpolation(mc_vars.theta_minus_2PIdiv3);
 8005114:	ed94 0a24 	vldr	s0, [r4, #144]	; 0x90
 8005118:	f000 f89a 	bl	8005250 <sin_interpolation>
 800511c:	eeb0 8a40 	vmov.f32	s16, s0
	sinArray[2] = sin_interpolation(mc_vars.theta_plus_2PIdiv3);
 8005120:	ed94 0a23 	vldr	s0, [r4, #140]	; 0x8c
 8005124:	f000 f894 	bl	8005250 <sin_interpolation>
 8005128:	eef0 8a40 	vmov.f32	s17, s0
/*
 * Get the cos values given the current theta value. Used by the park transform and the inverse
 * park transform. Interpolates between cos values given in a cos look up table of 1000 points.
 */
void getCosValues(float* cosArray) {
	cosArray[0] = cos_interpolation(mc_vars.theta_e);
 800512c:	ed94 0a06 	vldr	s0, [r4, #24]
 8005130:	f000 f8c2 	bl	80052b8 <cos_interpolation>
 8005134:	eeb0 9a40 	vmov.f32	s18, s0
	cosArray[1] = cos_interpolation(mc_vars.theta_minus_2PIdiv3);
 8005138:	ed94 0a24 	vldr	s0, [r4, #144]	; 0x90
 800513c:	f000 f8bc 	bl	80052b8 <cos_interpolation>
 8005140:	eeb0 aa40 	vmov.f32	s20, s0
	cosArray[2] = cos_interpolation(mc_vars.theta_plus_2PIdiv3);
 8005144:	ed94 0a23 	vldr	s0, [r4, #140]	; 0x8c
 8005148:	f000 f8b6 	bl	80052b8 <cos_interpolation>
	mc_vars.idq[0] = (sinArray[0]*mc_vars.iabc[0] + sinArray[1]*mc_vars.iabc[1] +
 800514c:	edd4 7a04 	vldr	s15, [r4, #16]
 8005150:	ed94 6a03 	vldr	s12, [r4, #12]
 8005154:	ee27 7a88 	vmul.f32	s14, s15, s16
						sinArray[2]*mc_vars.iabc[2]) * 0.66666666;
 8005158:	edd4 6a05 	vldr	s13, [r4, #20]
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 800515c:	ee67 7a8a 	vmul.f32	s15, s15, s20
	pi_id.error = mc_vars.idq_ref[0] - mc_vars.idq[0]; // error of Id
 8005160:	4a38      	ldr	r2, [pc, #224]	; (8005244 <Inner_step+0x144>)
	pi_iq.error = mc_vars.idq_ref[1] - mc_vars.idq[1]; // error of Iq
 8005162:	4b39      	ldr	r3, [pc, #228]	; (8005248 <Inner_step+0x148>)
	mc_vars.idq[0] = (sinArray[0]*mc_vars.iabc[0] + sinArray[1]*mc_vars.iabc[1] +
 8005164:	eea6 7a29 	vfma.f32	s14, s12, s19
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 8005168:	edd2 4a03 	vldr	s9, [r2, #12]
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 800516c:	eee6 7a09 	vfma.f32	s15, s12, s18
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 8005170:	ed92 4a06 	vldr	s8, [r2, #24]
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 8005174:	ed93 6a06 	vldr	s12, [r3, #24]
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 8005178:	ee24 4a24 	vmul.f32	s8, s8, s9
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 800517c:	edd3 4a03 	vldr	s9, [r3, #12]
	pi_id.error = mc_vars.idq_ref[0] - mc_vars.idq[0]; // error of Id
 8005180:	ed94 5a00 	vldr	s10, [r4]
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 8005184:	ee66 4a24 	vmul.f32	s9, s12, s9
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 8005188:	ed92 8a05 	vldr	s16, [r2, #20]
	mc_vars.idq[0] = (sinArray[0]*mc_vars.iabc[0] + sinArray[1]*mc_vars.iabc[1] +
 800518c:	eea6 7aa8 	vfma.f32	s14, s13, s17
	pi_iq.error = mc_vars.idq_ref[1] - mc_vars.idq[1]; // error of Iq
 8005190:	edd4 5a01 	vldr	s11, [r4, #4]
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 8005194:	eee6 7a80 	vfma.f32	s15, s13, s0
						mc_params.Tsw + pi_id.integral; // Discrete Time Integrator
 8005198:	ed92 3a01 	vldr	s6, [r2, #4]
 800519c:	492b      	ldr	r1, [pc, #172]	; (800524c <Inner_step+0x14c>)
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 800519e:	ed93 0a05 	vldr	s0, [r3, #20]
						mc_params.Tsw + pi_id.integral; // Discrete Time Integrator
 80051a2:	edd1 2a18 	vldr	s5, [r1, #96]	; 0x60
						mc_params.Tsw + pi_iq.integral; // Discrete Time Integrator
 80051a6:	edd3 3a01 	vldr	s7, [r3, #4]
	pi_id.output = pi_id.Kp * pi_id.error + pi_id.integral;
 80051aa:	edd2 0a04 	vldr	s1, [r2, #16]
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 80051ae:	eef0 6a67 	vmov.f32	s13, s15
	pi_iq.output = pi_iq.Kp * pi_iq.error + pi_iq.integral;
 80051b2:	ed93 2a04 	vldr	s4, [r3, #16]
	mc_vars.idq[0] = (sinArray[0]*mc_vars.iabc[0] + sinArray[1]*mc_vars.iabc[1] +
 80051b6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
						sinArray[2]*mc_vars.iabc[2]) * 0.66666666;
 80051ba:	ed9f 1b1f 	vldr	d1, [pc, #124]	; 8005238 <Inner_step+0x138>
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 80051be:	eeb7 6ae6 	vcvt.f64.f32	d6, s13
						sinArray[2]*mc_vars.iabc[2]) * 0.66666666;
 80051c2:	ee27 7b01 	vmul.f64	d7, d7, d1
						cosArray[2]*mc_vars.iabc[2]) * 0.66666666;
 80051c6:	ee26 6b01 	vmul.f64	d6, d6, d1
						sinArray[2]*mc_vars.iabc[2]) * 0.66666666;
 80051ca:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	mc_vars.idq[0] = (sinArray[0]*mc_vars.iabc[0] + sinArray[1]*mc_vars.iabc[1] +
 80051ce:	ed84 7a0a 	vstr	s14, [r4, #40]	; 0x28
	pi_id.error = mc_vars.idq_ref[0] - mc_vars.idq[0]; // error of Id
 80051d2:	ee35 7a47 	vsub.f32	s14, s10, s14
						cosArray[2]*mc_vars.iabc[2]) * 0.66666666;
 80051d6:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
						mc_params.Tsw + pi_iq.integral; // Discrete Time Integrator
 80051da:	eef0 6a63 	vmov.f32	s13, s7
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 80051de:	eea7 4a08 	vfma.f32	s8, s14, s16
	pi_id.error = mc_vars.idq_ref[0] - mc_vars.idq[0]; // error of Id
 80051e2:	ed82 7a00 	vstr	s14, [r2]
	pi_iq.error = mc_vars.idq_ref[1] - mc_vars.idq[1]; // error of Iq
 80051e6:	ee75 7ac6 	vsub.f32	s15, s11, s12
	mc_vars.idq[1] = (cosArray[0]*mc_vars.iabc[0] + cosArray[1]*mc_vars.iabc[1] +
 80051ea:	ed84 6a0b 	vstr	s12, [r4, #44]	; 0x2c
						mc_params.Tsw + pi_id.integral; // Discrete Time Integrator
 80051ee:	eef0 5a43 	vmov.f32	s11, s6
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 80051f2:	eeb0 6a64 	vmov.f32	s12, s9
	pi_iq.error = mc_vars.idq_ref[1] - mc_vars.idq[1]; // error of Iq
 80051f6:	edc3 7a00 	vstr	s15, [r3]
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 80051fa:	eea7 6a80 	vfma.f32	s12, s15, s0
						mc_params.Tsw + pi_id.integral; // Discrete Time Integrator
 80051fe:	eee4 5a22 	vfma.f32	s11, s8, s5
}
 8005202:	ecbd 8b06 	vpop	{d8-d10}
 8005206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
						mc_params.Tsw + pi_iq.integral; // Discrete Time Integrator
 800520a:	eee2 6a86 	vfma.f32	s13, s5, s12
	pi_id.integral = (pi_id.Ki * pi_id.error + pi_id.Kaw * pi_id.du) *
 800520e:	edc2 5a01 	vstr	s11, [r2, #4]
	pi_id.output = pi_id.Kp * pi_id.error + pi_id.integral;
 8005212:	eeb0 6a65 	vmov.f32	s12, s11
 8005216:	eea7 6a20 	vfma.f32	s12, s14, s1
	pi_iq.integral = (pi_iq.Ki * pi_iq.error + pi_iq.Kaw * pi_iq.du) *
 800521a:	edc3 6a01 	vstr	s13, [r3, #4]
	pi_id.output = pi_id.Kp * pi_id.error + pi_id.integral;
 800521e:	eeb0 7a46 	vmov.f32	s14, s12
	pi_iq.output = pi_iq.Kp * pi_iq.error + pi_iq.integral;
 8005222:	eeb0 6a66 	vmov.f32	s12, s13
	pi_id.output = pi_id.Kp * pi_id.error + pi_id.integral;
 8005226:	ed82 7a02 	vstr	s14, [r2, #8]
	pi_iq.output = pi_iq.Kp * pi_iq.error + pi_iq.integral;
 800522a:	eea7 6a82 	vfma.f32	s12, s15, s4
 800522e:	ed83 6a02 	vstr	s12, [r3, #8]
	vdq_saturation();
 8005232:	f7ff beed 	b.w	8005010 <vdq_saturation>
 8005236:	bf00      	nop
 8005238:	51c112da 	.word	0x51c112da
 800523c:	3fe55555 	.word	0x3fe55555
 8005240:	200021cc 	.word	0x200021cc
 8005244:	200022e0 	.word	0x200022e0
 8005248:	200022fc 	.word	0x200022fc
 800524c:	20002130 	.word	0x20002130

08005250 <sin_interpolation>:
 */
float sin_interpolation(float theta) {
	float sinVal, x;
	uint16_t xa, xb;

	x = (float) (theta * 999.0 / TWOPI);
 8005250:	ed9f 7b15 	vldr	d7, [pc, #84]	; 80052a8 <sin_interpolation+0x58>
 8005254:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
 8005258:	ee20 0b07 	vmul.f64	d0, d0, d7
 800525c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
	xa = (uint16_t) x;
 8005260:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8005264:	ee17 3a90 	vmov	r3, s15
 8005268:	b29a      	uxth	r2, r3
	xb = xa+1;
 800526a:	1c53      	adds	r3, r2, #1
 800526c:	b29b      	uxth	r3, r3
	if(xb > 999) {
 800526e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005272:	d213      	bcs.n	800529c <sin_interpolation+0x4c>
		return sinTable[999];
	}
	sinVal = (float) sinTable[xa] + ((sinTable[xb]-sinTable[xa])*(x-xa)) ;
 8005274:	ee07 2a90 	vmov	s15, r2
 8005278:	490d      	ldr	r1, [pc, #52]	; (80052b0 <sin_interpolation+0x60>)
 800527a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800527e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8005282:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8005286:	ed93 7a00 	vldr	s14, [r3]
 800528a:	ee70 7a67 	vsub.f32	s15, s0, s15
 800528e:	ed92 0a00 	vldr	s0, [r2]
 8005292:	ee37 7a40 	vsub.f32	s14, s14, s0
 8005296:	eea7 0a27 	vfma.f32	s0, s14, s15

	return sinVal;
}
 800529a:	4770      	bx	lr
		return sinTable[999];
 800529c:	4b05      	ldr	r3, [pc, #20]	; (80052b4 <sin_interpolation+0x64>)
 800529e:	ed93 0a00 	vldr	s0, [r3]
 80052a2:	4770      	bx	lr
 80052a4:	f3af 8000 	nop.w
 80052a8:	7f1b99ed 	.word	0x7f1b99ed
 80052ac:	4063dfdd 	.word	0x4063dfdd
 80052b0:	20000fa8 	.word	0x20000fa8
 80052b4:	20001f44 	.word	0x20001f44

080052b8 <cos_interpolation>:
 */
float cos_interpolation(float theta) {
	float cosVal, x;
	uint16_t xa, xb;

	x = (float) (theta * 999.0 / TWOPI);
 80052b8:	ed9f 7b15 	vldr	d7, [pc, #84]	; 8005310 <cos_interpolation+0x58>
 80052bc:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
 80052c0:	ee20 0b07 	vmul.f64	d0, d0, d7
 80052c4:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
	xa = (uint16_t) x;
 80052c8:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80052cc:	ee17 3a90 	vmov	r3, s15
 80052d0:	b29a      	uxth	r2, r3
	xb = xa+1;
 80052d2:	1c53      	adds	r3, r2, #1
 80052d4:	b29b      	uxth	r3, r3
	if(xb > 999) {
 80052d6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80052da:	d213      	bcs.n	8005304 <cos_interpolation+0x4c>
		return cosTable[999];
	}
	cosVal = (float) cosTable[xa] + ((cosTable[xb]-cosTable[xa])*(x-xa)) ;
 80052dc:	ee07 2a90 	vmov	s15, r2
 80052e0:	490d      	ldr	r1, [pc, #52]	; (8005318 <cos_interpolation+0x60>)
 80052e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80052e6:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80052ea:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 80052ee:	ed93 7a00 	vldr	s14, [r3]
 80052f2:	ee70 7a67 	vsub.f32	s15, s0, s15
 80052f6:	ed92 0a00 	vldr	s0, [r2]
 80052fa:	ee37 7a40 	vsub.f32	s14, s14, s0
 80052fe:	eea7 0a27 	vfma.f32	s0, s14, s15

	return cosVal;
}
 8005302:	4770      	bx	lr
		return cosTable[999];
 8005304:	4b05      	ldr	r3, [pc, #20]	; (800531c <cos_interpolation+0x64>)
 8005306:	ed93 0a00 	vldr	s0, [r3]
 800530a:	4770      	bx	lr
 800530c:	f3af 8000 	nop.w
 8005310:	7f1b99ed 	.word	0x7f1b99ed
 8005314:	4063dfdd 	.word	0x4063dfdd
 8005318:	20000008 	.word	0x20000008
 800531c:	20000fa4 	.word	0x20000fa4

08005320 <absVal>:
	if (num < 0.0) {
		return -num;
	} else {
		return num;
	}
}
 8005320:	eeb0 0ac0 	vabs.f32	s0, s0
 8005324:	4770      	bx	lr
 8005326:	bf00      	nop

08005328 <fSaturate>:

/*
 * Saturate a float value x between a lower limit and upper limit.
 */
float fSaturate(float x, float xLowerLimit, float xUpperLimit) {
	if (x <= xLowerLimit) {
 8005328:	eeb4 0ae0 	vcmpe.f32	s0, s1
 800532c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005330:	d902      	bls.n	8005338 <fSaturate+0x10>
 8005332:	fe80 0a41 	vminnm.f32	s0, s0, s2
 8005336:	4770      	bx	lr
		return xLowerLimit;
 8005338:	eeb0 0a60 	vmov.f32	s0, s1
	} else if (x >= xUpperLimit) {
		return xUpperLimit;
	}
	return x;
}
 800533c:	4770      	bx	lr
 800533e:	bf00      	nop

08005340 <iSaturate>:

/*
 * Saturate a signed integer value x between a lower limit and upper limit.
 */
int iSaturate(int x, int xLowerLimit, int xUpperLimit) {
	if (x <= xLowerLimit) {
 8005340:	4288      	cmp	r0, r1
 8005342:	dd03      	ble.n	800534c <iSaturate+0xc>
 8005344:	4290      	cmp	r0, r2
 8005346:	bfa8      	it	ge
 8005348:	4610      	movge	r0, r2
 800534a:	4770      	bx	lr
 800534c:	4608      	mov	r0, r1
		return xLowerLimit;
	} else if (x >= xUpperLimit) {
		return xUpperLimit;
	}
	return x;
}
 800534e:	4770      	bx	lr

08005350 <max>:
/*
 * Find the max of three integers. Used in the PWM calculations.
 */
int max(int x, int y, int z) {
	int max;
	if (x > y) {
 8005350:	4288      	cmp	r0, r1
 8005352:	dd03      	ble.n	800535c <max+0xc>
 8005354:	4290      	cmp	r0, r2
 8005356:	bfb8      	it	lt
 8005358:	4610      	movlt	r0, r2
 800535a:	4770      	bx	lr
 800535c:	4291      	cmp	r1, r2
 800535e:	bfb8      	it	lt
 8005360:	4611      	movlt	r1, r2
 8005362:	4608      	mov	r0, r1
		 } else {
			 max = z;
		 }
	}
	return max;
}
 8005364:	4770      	bx	lr
 8005366:	bf00      	nop

08005368 <min>:
/*
 * Find the min of three integers. Used in the PWM calculations.
 */
int min(int x, int y, int z) {
	int min;
	if (x < y) {
 8005368:	4288      	cmp	r0, r1
 800536a:	da03      	bge.n	8005374 <min+0xc>
 800536c:	4290      	cmp	r0, r2
 800536e:	bfa8      	it	ge
 8005370:	4610      	movge	r0, r2
 8005372:	4770      	bx	lr
 8005374:	4291      	cmp	r1, r2
 8005376:	bfa8      	it	ge
 8005378:	4611      	movge	r1, r2
 800537a:	4608      	mov	r0, r1
		 } else {
			 min = z;
		 }
	}
	return min;
}
 800537c:	4770      	bx	lr
 800537e:	bf00      	nop

08005380 <Outer_step>:

/*
 * Outer step module. Takes the torque requests and outputs current references.
 */
void Outer_step(void)
{
 8005380:	b538      	push	{r3, r4, r5, lr}
	// get motor values
	mc_vars.wMechanical = absVal(mc_vars.wElectrical / mc_params.p);
 8005382:	4c31      	ldr	r4, [pc, #196]	; (8005448 <Outer_step+0xc8>)
 8005384:	4d31      	ldr	r5, [pc, #196]	; (800544c <Outer_step+0xcc>)
 8005386:	ed94 0a02 	vldr	s0, [r4, #8]
 800538a:	edd5 7a08 	vldr	s15, [r5, #32]
 800538e:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8005392:	f7ff ffc5 	bl	8005320 <absVal>
 8005396:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c
	mc_vars.rpm = mc_vars.wMechanical * THIRTYDIVPI;
 800539a:	eeb7 5ac0 	vcvt.f64.f32	d5, s0
 800539e:	ed9f 7b26 	vldr	d7, [pc, #152]	; 8005438 <Outer_step+0xb8>
 */
void torque_limiter(void) {
	float motor_torque;

	// Mechanical frequency saturation
	if (mc_vars.wMechanical < mc_params.wMechanical_Sat) {
 80053a2:	ed95 4b22 	vldr	d4, [r5, #136]	; 0x88
	mc_vars.rpm = mc_vars.wMechanical * THIRTYDIVPI;
 80053a6:	ee25 7b07 	vmul.f64	d7, d5, d7
	if (mc_vars.wMechanical < mc_params.wMechanical_Sat) {
 80053aa:	eeb4 5bc4 	vcmpe.f64	d5, d4
	mc_vars.rpm = mc_vars.wMechanical * THIRTYDIVPI;
 80053ae:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	if (mc_vars.wMechanical < mc_params.wMechanical_Sat) {
 80053b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	mc_vars.rpm = mc_vars.wMechanical * THIRTYDIVPI;
 80053b6:	ed84 7a10 	vstr	s14, [r4, #64]	; 0x40
	if (mc_vars.wMechanical < mc_params.wMechanical_Sat) {
 80053ba:	d538      	bpl.n	800542e <Outer_step+0xae>
		mc_vars.wMechanical = mc_params.wMechanical_Sat;
 80053bc:	eef7 6bc4 	vcvt.f32.f64	s13, d4
 80053c0:	edc4 6a0f 	vstr	s13, [r4, #60]	; 0x3c
	}

	// Get Motor Torque
	motor_torque = (float) mc_params.Pmax * 1000 / mc_vars.wMechanical ;
 80053c4:	edd5 7a01 	vldr	s15, [r5, #4]
 80053c8:	ed9f 6a21 	vldr	s12, [pc, #132]	; 8005450 <Outer_step+0xd0>
 80053cc:	eeb8 7a67 	vcvt.f32.u32	s14, s15

	// Get Minimum of Tmax or TqRef
	if (motor_torque > mc_params.Tmax) {
 80053d0:	edd5 7a02 	vldr	s15, [r5, #8]

	// Calculated torque limit
	mc_vars.TqLim = motor_torque ;

	// Saturate torque request if required
	mc_vars.TqRef = fSaturate(mc_vars.TqRequest,-mc_vars.TqLim,mc_vars.TqLim);
 80053d4:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
	if (motor_torque > mc_params.Tmax) {
 80053d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
	motor_torque = (float) mc_params.Pmax * 1000 / mc_vars.wMechanical ;
 80053dc:	ee27 7a06 	vmul.f32	s14, s14, s12
 80053e0:	ee87 6a26 	vdiv.f32	s12, s14, s13
 80053e4:	fec7 7ac6 	vminnm.f32	s15, s15, s12
	mc_vars.TqRef = fSaturate(mc_vars.TqRequest,-mc_vars.TqLim,mc_vars.TqLim);
 80053e8:	eeb0 1a67 	vmov.f32	s2, s15
 80053ec:	eef1 0a67 	vneg.f32	s1, s15
	mc_vars.TqLim = motor_torque ;
 80053f0:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
	mc_vars.TqRef = fSaturate(mc_vars.TqRequest,-mc_vars.TqLim,mc_vars.TqLim);
 80053f4:	f7ff ff98 	bl	8005328 <fSaturate>
	mc_vars.idq_ref[1] = mc_vars.TqRef * 0.66666667 / mc_params.p / mc_params.psim;
 80053f8:	ed95 7a08 	vldr	s14, [r5, #32]
 80053fc:	ed95 6a07 	vldr	s12, [r5, #28]
 8005400:	eeb7 5ac0 	vcvt.f64.f32	d5, s0
 8005404:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
	mc_vars.idq_ref[0] = 0.0;
 8005408:	2300      	movs	r3, #0
	mc_vars.idq_ref[1] = mc_vars.TqRef * 0.66666667 / mc_params.p / mc_params.psim;
 800540a:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
	mc_vars.TqRef = fSaturate(mc_vars.TqRequest,-mc_vars.TqLim,mc_vars.TqLim);
 800540e:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
	mc_vars.idq_ref[0] = 0.0;
 8005412:	6023      	str	r3, [r4, #0]
	mc_vars.idq_ref[1] = mc_vars.TqRef * 0.66666667 / mc_params.p / mc_params.psim;
 8005414:	ed9f 4b0a 	vldr	d4, [pc, #40]	; 8005440 <Outer_step+0xc0>
 8005418:	ee27 7b06 	vmul.f64	d7, d7, d6
 800541c:	ee25 5b04 	vmul.f64	d5, d5, d4
 8005420:	ee85 6b07 	vdiv.f64	d6, d5, d7
 8005424:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
 8005428:	ed84 6a01 	vstr	s12, [r4, #4]
}
 800542c:	bd38      	pop	{r3, r4, r5, pc}
 800542e:	eef0 6a40 	vmov.f32	s13, s0
 8005432:	e7c7      	b.n	80053c4 <Outer_step+0x44>
 8005434:	f3af 8000 	nop.w
 8005438:	66ed23cc 	.word	0x66ed23cc
 800543c:	4023193d 	.word	0x4023193d
 8005440:	571f7693 	.word	0x571f7693
 8005444:	3fe55555 	.word	0x3fe55555
 8005448:	200021cc 	.word	0x200021cc
 800544c:	20002130 	.word	0x20002130
 8005450:	447a0000 	.word	0x447a0000

08005454 <Torque_step>:
 * Control system torque step. Takes in torque requests and limits them in two way. First torque requests
 * are limited if the IGBT or motor temperatures are beyond their corner temperatures. Secondly it limits
 * how fast the torque can increase by t_ramp, a parameter set in the GUI.
 */
void Torque_step(void)
{
 8005454:	b538      	push	{r3, r4, r5, lr}
 * Limit how fast the torque can increase
 */
float rate_limiter(void) {
	float TqRate;

	TqRate = mc_vars.TqRequest - mc_vars.TqRequest_prev;
 8005456:	4c32      	ldr	r4, [pc, #200]	; (8005520 <Torque_step+0xcc>)
	TqRate = fSaturate(TqRate, -mc_params.t_ramp,mc_params.t_ramp);
 8005458:	4d32      	ldr	r5, [pc, #200]	; (8005524 <Torque_step+0xd0>)
	TqRate = mc_vars.TqRequest - mc_vars.TqRequest_prev;
 800545a:	edd4 7a16 	vldr	s15, [r4, #88]	; 0x58
	TqRate = fSaturate(TqRate, -mc_params.t_ramp,mc_params.t_ramp);
 800545e:	ed95 1a10 	vldr	s2, [r5, #64]	; 0x40
	TqRate = mc_vars.TqRequest - mc_vars.TqRequest_prev;
 8005462:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
	TqRate = fSaturate(TqRate, -mc_params.t_ramp,mc_params.t_ramp);
 8005466:	eef1 0a41 	vneg.f32	s1, s2
 800546a:	ee30 0a67 	vsub.f32	s0, s0, s15
{
 800546e:	ed2d 8b04 	vpush	{d8-d9}
	TqRate = fSaturate(TqRate, -mc_params.t_ramp,mc_params.t_ramp);
 8005472:	f7ff ff59 	bl	8005328 <fSaturate>
	float motorTemp_diff, motorTemp_diff_max;
	float igbtTemp_diff, igbtTemp_diff_max;
	float T1, T2;

	motorTemp_diff = mc_vars.motorTemp - mc_params.motorTemp_corner;
	motorTemp_diff_max = mc_params.motorTemp_max-mc_params.motorTemp_corner;
 8005476:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8005478:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	motorTemp_diff = mc_vars.motorTemp - mc_params.motorTemp_corner;
 800547a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
	motorTemp_diff_max = mc_params.motorTemp_max-mc_params.motorTemp_corner;
 800547e:	1a9b      	subs	r3, r3, r2
	motorTemp_diff = fSaturate(motorTemp_diff, 0, motorTemp_diff_max);
 8005480:	ed9f 8a29 	vldr	s16, [pc, #164]	; 8005528 <Torque_step+0xd4>
	motorTemp_diff = mc_vars.motorTemp - mc_params.motorTemp_corner;
 8005484:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005488:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
	motorTemp_diff_max = mc_params.motorTemp_max-mc_params.motorTemp_corner;
 800548c:	ee06 3a90 	vmov	s13, r3
	return mc_vars.TqRequest_prev + TqRate;
 8005490:	ed94 9a16 	vldr	s18, [r4, #88]	; 0x58
	motorTemp_diff = fSaturate(motorTemp_diff, 0, motorTemp_diff_max);
 8005494:	eef0 0a48 	vmov.f32	s1, s16
	motorTemp_diff_max = mc_params.motorTemp_max-mc_params.motorTemp_corner;
 8005498:	eef8 8a66 	vcvt.f32.u32	s17, s13
	return mc_vars.TqRequest_prev + TqRate;
 800549c:	ee30 9a09 	vadd.f32	s18, s0, s18
	motorTemp_diff = fSaturate(motorTemp_diff, 0, motorTemp_diff_max);
 80054a0:	ee37 0a67 	vsub.f32	s0, s14, s15
 80054a4:	eeb0 1a68 	vmov.f32	s2, s17
 80054a8:	f7ff ff3e 	bl	8005328 <fSaturate>
	T1 = 1 - motorTemp_diff / motorTemp_diff_max;

	igbtTemp_diff = mc_vars.igbtTemp - mc_params.igbtTemp_corner;
	igbtTemp_diff_max = mc_params.igbtTemp_max-mc_params.igbtTemp_corner;
 80054ac:	6caa      	ldr	r2, [r5, #72]	; 0x48
 80054ae:	6c6b      	ldr	r3, [r5, #68]	; 0x44
	igbtTemp_diff = fSaturate(igbtTemp_diff, 0, igbtTemp_diff_max);
 80054b0:	eef0 0a48 	vmov.f32	s1, s16
	igbtTemp_diff = mc_vars.igbtTemp - mc_params.igbtTemp_corner;
 80054b4:	edd5 7a12 	vldr	s15, [r5, #72]	; 0x48
	motorTemp_diff = fSaturate(motorTemp_diff, 0, motorTemp_diff_max);
 80054b8:	eef0 9a40 	vmov.f32	s19, s0
	igbtTemp_diff_max = mc_params.igbtTemp_max-mc_params.igbtTemp_corner;
 80054bc:	1a9b      	subs	r3, r3, r2
	igbtTemp_diff = mc_vars.igbtTemp - mc_params.igbtTemp_corner;
 80054be:	ed94 0a12 	vldr	s0, [r4, #72]	; 0x48
 80054c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
	igbtTemp_diff_max = mc_params.igbtTemp_max-mc_params.igbtTemp_corner;
 80054c6:	ee07 3a10 	vmov	s14, r3
 80054ca:	eeb8 8a47 	vcvt.f32.u32	s16, s14
	igbtTemp_diff = fSaturate(igbtTemp_diff, 0, igbtTemp_diff_max);
 80054ce:	ee30 0a67 	vsub.f32	s0, s0, s15
 80054d2:	eeb0 1a48 	vmov.f32	s2, s16
 80054d6:	f7ff ff27 	bl	8005328 <fSaturate>
	T1 = 1 - motorTemp_diff / motorTemp_diff_max;
 80054da:	ee89 7aa8 	vdiv.f32	s14, s19, s17
	T2 = 1 - igbtTemp_diff / igbtTemp_diff_max;

	mc_vars.TqMax = T1*T2*mc_params.Tmax;
 80054de:	ed95 6a02 	vldr	s12, [r5, #8]
	T2 = 1 - igbtTemp_diff / igbtTemp_diff_max;
 80054e2:	eec0 5a08 	vdiv.f32	s11, s0, s16
	T1 = 1 - motorTemp_diff / motorTemp_diff_max;
 80054e6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	mc_vars.TqMax = T1*T2*mc_params.Tmax;
 80054ea:	eeb8 6a46 	vcvt.f32.u32	s12, s12

	return fSaturate(Tq,-mc_vars.TqMax,mc_vars.TqMax);
 80054ee:	eeb0 0a49 	vmov.f32	s0, s18
	T1 = 1 - motorTemp_diff / motorTemp_diff_max;
 80054f2:	ee76 7ac7 	vsub.f32	s15, s13, s14
	T2 = 1 - igbtTemp_diff / igbtTemp_diff_max;
 80054f6:	ee76 6ae5 	vsub.f32	s13, s13, s11
	mc_vars.TqMax = T1*T2*mc_params.Tmax;
 80054fa:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80054fe:	ee67 7a86 	vmul.f32	s15, s15, s12
	return fSaturate(Tq,-mc_vars.TqMax,mc_vars.TqMax);
 8005502:	eeb0 1a67 	vmov.f32	s2, s15
	mc_vars.TqMax = T1*T2*mc_params.Tmax;
 8005506:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
	return fSaturate(Tq,-mc_vars.TqMax,mc_vars.TqMax);
 800550a:	eef1 0a67 	vneg.f32	s1, s15
 800550e:	f7ff ff0b 	bl	8005328 <fSaturate>
  mc_vars.TqRef = tq_saturation(Tq_limited);
 8005512:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
  mc_vars.TqRequest_prev = mc_vars.TqRef;
 8005516:	ed84 0a16 	vstr	s0, [r4, #88]	; 0x58
}
 800551a:	ecbd 8b04 	vpop	{d8-d9}
 800551e:	bd38      	pop	{r3, r4, r5, pc}
 8005520:	200021cc 	.word	0x200021cc
 8005524:	20002130 	.word	0x20002130
 8005528:	00000000 	.word	0x00000000

0800552c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800552c:	b5f0      	push	{r4, r5, r6, r7, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800552e:	2400      	movs	r4, #0
{
 8005530:	b0b9      	sub	sp, #228	; 0xe4
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005532:	222c      	movs	r2, #44	; 0x2c
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005534:	2502      	movs	r5, #2
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005536:	4621      	mov	r1, r4
 8005538:	a809      	add	r0, sp, #36	; 0x24
 800553a:	f004 f9ec 	bl	8009916 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800553e:	4621      	mov	r1, r4
 8005540:	2290      	movs	r2, #144	; 0x90
 8005542:	a814      	add	r0, sp, #80	; 0x50
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005544:	9402      	str	r4, [sp, #8]
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8005546:	2601      	movs	r6, #1
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005548:	9403      	str	r4, [sp, #12]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
 800554a:	2704      	movs	r7, #4
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800554c:	9406      	str	r4, [sp, #24]
 800554e:	e9cd 4404 	strd	r4, r4, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8005552:	f004 f9e0 	bl	8009916 <memset>
  __HAL_RCC_PWR_CLK_ENABLE();
 8005556:	4b52      	ldr	r3, [pc, #328]	; (80056a0 <SystemClock_Config+0x174>)
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8005558:	2009      	movs	r0, #9
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800555a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  __HAL_RCC_PWR_CLK_ENABLE();
 800555e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005560:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005564:	641a      	str	r2, [r3, #64]	; 0x40
 8005566:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005568:	f5a3 33e4 	sub.w	r3, r3, #116736	; 0x1c800
  __HAL_RCC_PWR_CLK_ENABLE();
 800556c:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8005570:	9200      	str	r2, [sp, #0]
 8005572:	9a00      	ldr	r2, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005574:	681a      	ldr	r2, [r3, #0]
 8005576:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800557a:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800557c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005580:	681b      	ldr	r3, [r3, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8005582:	9007      	str	r0, [sp, #28]
  RCC_OscInitStruct.PLL.PLLN = 216;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005584:	a807      	add	r0, sp, #28
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005586:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800558a:	9108      	str	r1, [sp, #32]
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800558c:	960c      	str	r6, [sp, #48]	; 0x30
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800558e:	9301      	str	r3, [sp, #4]
  RCC_OscInitStruct.PLL.PLLN = 216;
 8005590:	23d8      	movs	r3, #216	; 0xd8
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005592:	9901      	ldr	r1, [sp, #4]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005594:	950d      	str	r5, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLN = 216;
 8005596:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLQ = 2;
 8005598:	e9cd 5511 	strd	r5, r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 4;
 800559c:	e9cd 270e 	strd	r2, r7, [sp, #56]	; 0x38
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80055a0:	f7fc fe2c 	bl	80021fc <HAL_RCC_OscConfig>
 80055a4:	2800      	cmp	r0, #0
 80055a6:	d164      	bne.n	8005672 <SystemClock_Config+0x146>
  {
    Error_Handler();
  }
  /** Activate the Over-Drive mode 
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 80055a8:	f7fc fdec 	bl	8002184 <HAL_PWREx_EnableOverDrive>
 80055ac:	2800      	cmp	r0, #0
 80055ae:	d148      	bne.n	8005642 <SystemClock_Config+0x116>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80055b0:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80055b2:	2502      	movs	r5, #2
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80055b4:	2400      	movs	r4, #0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80055b6:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80055ba:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80055bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80055c0:	a802      	add	r0, sp, #8
 80055c2:	2107      	movs	r1, #7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80055c4:	e9cd 5403 	strd	r5, r4, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80055c8:	e9cd 2305 	strd	r2, r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80055cc:	f7fc ffe4 	bl	8002598 <HAL_RCC_ClockConfig>
 80055d0:	bb00      	cbnz	r0, 8005614 <SystemClock_Config+0xe8>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DFSDM1|RCC_PERIPHCLK_USART2;
  PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80055d2:	2400      	movs	r4, #0
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DFSDM1|RCC_PERIPHCLK_USART2;
 80055d4:	4b33      	ldr	r3, [pc, #204]	; (80056a4 <SystemClock_Config+0x178>)
  PeriphClkInitStruct.Dfsdm1ClockSelection = RCC_DFSDM1CLKSOURCE_PCLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80055d6:	a814      	add	r0, sp, #80	; 0x50
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DFSDM1|RCC_PERIPHCLK_USART2;
 80055d8:	9314      	str	r3, [sp, #80]	; 0x50
  PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80055da:	9426      	str	r4, [sp, #152]	; 0x98
  PeriphClkInitStruct.Dfsdm1ClockSelection = RCC_DFSDM1CLKSOURCE_PCLK;
 80055dc:	9436      	str	r4, [sp, #216]	; 0xd8
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80055de:	f7fd f8f9 	bl	80027d4 <HAL_RCCEx_PeriphCLKConfig>
 80055e2:	b1a8      	cbz	r0, 8005610 <SystemClock_Config+0xe4>
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
	control_disable();
 80055e4:	f7ff fcb6 	bl	8004f54 <control_disable>
	mc_vars.fault = TRUE;
 80055e8:	2501      	movs	r5, #1
 80055ea:	4b2f      	ldr	r3, [pc, #188]	; (80056a8 <SystemClock_Config+0x17c>)
	mc_vars.mc_enable = FALSE;

	// Change LED to fault (red)
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 80055ec:	4622      	mov	r2, r4
 80055ee:	2102      	movs	r1, #2
 80055f0:	482e      	ldr	r0, [pc, #184]	; (80056ac <SystemClock_Config+0x180>)
	mc_vars.mc_enable = FALSE;
 80055f2:	661c      	str	r4, [r3, #96]	; 0x60
	mc_vars.fault = TRUE;
 80055f4:	f883 506c 	strb.w	r5, [r3, #108]	; 0x6c
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 80055f8:	f7fc fd90 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, LOW);
 80055fc:	4622      	mov	r2, r4
 80055fe:	4629      	mov	r1, r5
 8005600:	482a      	ldr	r0, [pc, #168]	; (80056ac <SystemClock_Config+0x180>)
 8005602:	f7fc fd8b 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 8005606:	462a      	mov	r2, r5
 8005608:	2104      	movs	r1, #4
 800560a:	4828      	ldr	r0, [pc, #160]	; (80056ac <SystemClock_Config+0x180>)
 800560c:	f7fc fd86 	bl	800211c <HAL_GPIO_WritePin>
}
 8005610:	b039      	add	sp, #228	; 0xe4
 8005612:	bdf0      	pop	{r4, r5, r6, r7, pc}
	control_disable();
 8005614:	f7ff fc9e 	bl	8004f54 <control_disable>
	mc_vars.fault = TRUE;
 8005618:	2601      	movs	r6, #1
 800561a:	4b23      	ldr	r3, [pc, #140]	; (80056a8 <SystemClock_Config+0x17c>)
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 800561c:	4629      	mov	r1, r5
 800561e:	4622      	mov	r2, r4
 8005620:	4822      	ldr	r0, [pc, #136]	; (80056ac <SystemClock_Config+0x180>)
	mc_vars.mc_enable = FALSE;
 8005622:	661c      	str	r4, [r3, #96]	; 0x60
	mc_vars.fault = TRUE;
 8005624:	f883 606c 	strb.w	r6, [r3, #108]	; 0x6c
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 8005628:	f7fc fd78 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, LOW);
 800562c:	4622      	mov	r2, r4
 800562e:	4631      	mov	r1, r6
 8005630:	481e      	ldr	r0, [pc, #120]	; (80056ac <SystemClock_Config+0x180>)
 8005632:	f7fc fd73 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 8005636:	4632      	mov	r2, r6
 8005638:	2104      	movs	r1, #4
 800563a:	481c      	ldr	r0, [pc, #112]	; (80056ac <SystemClock_Config+0x180>)
 800563c:	f7fc fd6e 	bl	800211c <HAL_GPIO_WritePin>
 8005640:	e7c7      	b.n	80055d2 <SystemClock_Config+0xa6>
	mc_vars.mc_enable = FALSE;
 8005642:	2500      	movs	r5, #0
	control_disable();
 8005644:	f7ff fc86 	bl	8004f54 <control_disable>
	mc_vars.fault = TRUE;
 8005648:	2401      	movs	r4, #1
 800564a:	4b17      	ldr	r3, [pc, #92]	; (80056a8 <SystemClock_Config+0x17c>)
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 800564c:	462a      	mov	r2, r5
 800564e:	2102      	movs	r1, #2
 8005650:	4816      	ldr	r0, [pc, #88]	; (80056ac <SystemClock_Config+0x180>)
	mc_vars.mc_enable = FALSE;
 8005652:	661d      	str	r5, [r3, #96]	; 0x60
	mc_vars.fault = TRUE;
 8005654:	f883 406c 	strb.w	r4, [r3, #108]	; 0x6c
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 8005658:	f7fc fd60 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, LOW);
 800565c:	462a      	mov	r2, r5
 800565e:	4621      	mov	r1, r4
 8005660:	4812      	ldr	r0, [pc, #72]	; (80056ac <SystemClock_Config+0x180>)
 8005662:	f7fc fd5b 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 8005666:	4622      	mov	r2, r4
 8005668:	2104      	movs	r1, #4
 800566a:	4810      	ldr	r0, [pc, #64]	; (80056ac <SystemClock_Config+0x180>)
 800566c:	f7fc fd56 	bl	800211c <HAL_GPIO_WritePin>
 8005670:	e79e      	b.n	80055b0 <SystemClock_Config+0x84>
	control_disable();
 8005672:	f7ff fc6f 	bl	8004f54 <control_disable>
	mc_vars.fault = TRUE;
 8005676:	4b0c      	ldr	r3, [pc, #48]	; (80056a8 <SystemClock_Config+0x17c>)
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 8005678:	4629      	mov	r1, r5
 800567a:	4622      	mov	r2, r4
 800567c:	480b      	ldr	r0, [pc, #44]	; (80056ac <SystemClock_Config+0x180>)
	mc_vars.fault = TRUE;
 800567e:	f883 606c 	strb.w	r6, [r3, #108]	; 0x6c
	mc_vars.mc_enable = FALSE;
 8005682:	661c      	str	r4, [r3, #96]	; 0x60
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 8005684:	f7fc fd4a 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, LOW);
 8005688:	4622      	mov	r2, r4
 800568a:	4631      	mov	r1, r6
 800568c:	4807      	ldr	r0, [pc, #28]	; (80056ac <SystemClock_Config+0x180>)
 800568e:	f7fc fd45 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 8005692:	4632      	mov	r2, r6
 8005694:	4639      	mov	r1, r7
 8005696:	4805      	ldr	r0, [pc, #20]	; (80056ac <SystemClock_Config+0x180>)
 8005698:	f7fc fd40 	bl	800211c <HAL_GPIO_WritePin>
 800569c:	e784      	b.n	80055a8 <SystemClock_Config+0x7c>
 800569e:	bf00      	nop
 80056a0:	40023800 	.word	0x40023800
 80056a4:	08000080 	.word	0x08000080
 80056a8:	200021cc 	.word	0x200021cc
 80056ac:	40021400 	.word	0x40021400

080056b0 <Error_Handler>:
{
 80056b0:	b570      	push	{r4, r5, r6, lr}
	mc_vars.mc_enable = FALSE;
 80056b2:	2600      	movs	r6, #0
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 80056b4:	4c0c      	ldr	r4, [pc, #48]	; (80056e8 <Error_Handler+0x38>)
	control_disable();
 80056b6:	f7ff fc4d 	bl	8004f54 <control_disable>
	mc_vars.fault = TRUE;
 80056ba:	2501      	movs	r5, #1
 80056bc:	4b0b      	ldr	r3, [pc, #44]	; (80056ec <Error_Handler+0x3c>)
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 80056be:	4632      	mov	r2, r6
 80056c0:	4620      	mov	r0, r4
 80056c2:	2102      	movs	r1, #2
	mc_vars.mc_enable = FALSE;
 80056c4:	661e      	str	r6, [r3, #96]	; 0x60
	mc_vars.fault = TRUE;
 80056c6:	f883 506c 	strb.w	r5, [r3, #108]	; 0x6c
	HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 80056ca:	f7fc fd27 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, LOW);
 80056ce:	4632      	mov	r2, r6
 80056d0:	4629      	mov	r1, r5
 80056d2:	4620      	mov	r0, r4
 80056d4:	f7fc fd22 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 80056d8:	462a      	mov	r2, r5
 80056da:	4620      	mov	r0, r4
 80056dc:	2104      	movs	r1, #4

  /* USER CODE END Error_Handler_Debug */
}
 80056de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, HIGH);
 80056e2:	f7fc bd1b 	b.w	800211c <HAL_GPIO_WritePin>
 80056e6:	bf00      	nop
 80056e8:	40021400 	.word	0x40021400
 80056ec:	200021cc 	.word	0x200021cc

080056f0 <main>:
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80056f0:	2400      	movs	r4, #0
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80056f2:	4dbd      	ldr	r5, [pc, #756]	; (80059e8 <main+0x2f8>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80056f4:	2601      	movs	r6, #1
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80056f6:	f04f 0902 	mov.w	r9, #2
  GPIO_InitStruct.Pin = MC_ENBL_IN_Pin;
 80056fa:	f44f 7800 	mov.w	r8, #512	; 0x200
  GPIO_InitStruct.Pin = RDC_FAULT_Pin;
 80056fe:	f44f 6a00 	mov.w	sl, #2048	; 0x800
{
 8005702:	b580      	push	{r7, lr}
 8005704:	b0a4      	sub	sp, #144	; 0x90
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 8005706:	2711      	movs	r7, #17
  HAL_Init();
 8005708:	f7fa ff3a 	bl	8000580 <HAL_Init>
  SystemClock_Config();
 800570c:	f7ff ff0e 	bl	800552c <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005710:	941a      	str	r4, [sp, #104]	; 0x68
 8005712:	941b      	str	r4, [sp, #108]	; 0x6c
  HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin|LED_GREEN_Pin|LED_RED_Pin|MC_ENBL_OUT_Pin, GPIO_PIN_RESET);
 8005714:	4622      	mov	r2, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005716:	941c      	str	r4, [sp, #112]	; 0x70
  HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin|LED_GREEN_Pin|LED_RED_Pin|MC_ENBL_OUT_Pin, GPIO_PIN_RESET);
 8005718:	f240 1107 	movw	r1, #263	; 0x107
 800571c:	48b3      	ldr	r0, [pc, #716]	; (80059ec <main+0x2fc>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800571e:	e9cd 4418 	strd	r4, r4, [sp, #96]	; 0x60
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8005722:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005724:	f043 0310 	orr.w	r3, r3, #16
 8005728:	632b      	str	r3, [r5, #48]	; 0x30
 800572a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800572c:	f003 0310 	and.w	r3, r3, #16
 8005730:	9302      	str	r3, [sp, #8]
 8005732:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005734:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005736:	f043 0320 	orr.w	r3, r3, #32
 800573a:	632b      	str	r3, [r5, #48]	; 0x30
 800573c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800573e:	f003 0320 	and.w	r3, r3, #32
 8005742:	9303      	str	r3, [sp, #12]
 8005744:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005746:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005748:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800574c:	632b      	str	r3, [r5, #48]	; 0x30
 800574e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005750:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005754:	9304      	str	r3, [sp, #16]
 8005756:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005758:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800575a:	f043 0304 	orr.w	r3, r3, #4
 800575e:	632b      	str	r3, [r5, #48]	; 0x30
 8005760:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005762:	f003 0304 	and.w	r3, r3, #4
 8005766:	9305      	str	r3, [sp, #20]
 8005768:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800576a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800576c:	4333      	orrs	r3, r6
 800576e:	632b      	str	r3, [r5, #48]	; 0x30
 8005770:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005772:	4033      	ands	r3, r6
 8005774:	9306      	str	r3, [sp, #24]
 8005776:	9b06      	ldr	r3, [sp, #24]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005778:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800577a:	ea43 0309 	orr.w	r3, r3, r9
 800577e:	632b      	str	r3, [r5, #48]	; 0x30
 8005780:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005782:	ea03 0309 	and.w	r3, r3, r9
 8005786:	9307      	str	r3, [sp, #28]
 8005788:	9b07      	ldr	r3, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800578a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800578c:	f043 0308 	orr.w	r3, r3, #8
 8005790:	632b      	str	r3, [r5, #48]	; 0x30
 8005792:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005794:	f003 0308 	and.w	r3, r3, #8
 8005798:	9308      	str	r3, [sp, #32]
 800579a:	9b08      	ldr	r3, [sp, #32]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800579c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800579e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80057a2:	632b      	str	r3, [r5, #48]	; 0x30
 80057a4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80057a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80057aa:	9309      	str	r3, [sp, #36]	; 0x24
 80057ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin|LED_GREEN_Pin|LED_RED_Pin|MC_ENBL_OUT_Pin, GPIO_PIN_RESET);
 80057ae:	f7fc fcb5 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
 80057b2:	4622      	mov	r2, r4
 80057b4:	2120      	movs	r1, #32
 80057b6:	488e      	ldr	r0, [pc, #568]	; (80059f0 <main+0x300>)
 80057b8:	f7fc fcb0 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, RDC_FAULTRES_Pin|RDC_CS_Pin|IABC_CS_C_Pin|IABC_CS_B_Pin 
 80057bc:	4622      	mov	r2, r4
 80057be:	f241 41d0 	movw	r1, #5328	; 0x14d0
 80057c2:	488c      	ldr	r0, [pc, #560]	; (80059f4 <main+0x304>)
 80057c4:	f7fc fcaa 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RDC_NRST_GPIO_Port, RDC_NRST_Pin, GPIO_PIN_RESET);
 80057c8:	4622      	mov	r2, r4
 80057ca:	f44f 7180 	mov.w	r1, #256	; 0x100
 80057ce:	488a      	ldr	r0, [pc, #552]	; (80059f8 <main+0x308>)
 80057d0:	f7fc fca4 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, IABC_CNVST_Pin|IABC_OCD_Pin, GPIO_PIN_RESET);
 80057d4:	4622      	mov	r2, r4
 80057d6:	f44f 4184 	mov.w	r1, #16896	; 0x4200
 80057da:	4888      	ldr	r0, [pc, #544]	; (80059fc <main+0x30c>)
 80057dc:	f7fc fc9e 	bl	800211c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = LED_BLUE_Pin|LED_GREEN_Pin|LED_RED_Pin|MC_ENBL_OUT_Pin;
 80057e0:	f240 1307 	movw	r3, #263	; 0x107
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80057e4:	a918      	add	r1, sp, #96	; 0x60
 80057e6:	4881      	ldr	r0, [pc, #516]	; (80059ec <main+0x2fc>)
  GPIO_InitStruct.Pin = LED_BLUE_Pin|LED_GREEN_Pin|LED_RED_Pin|MC_ENBL_OUT_Pin;
 80057e8:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80057ea:	9619      	str	r6, [sp, #100]	; 0x64
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80057ec:	e9cd 441a 	strd	r4, r4, [sp, #104]	; 0x68
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80057f0:	f7fc fb70 	bl	8001ed4 <HAL_GPIO_Init>
  HAL_GPIO_Init(MC_ENBL_IN_GPIO_Port, &GPIO_InitStruct);
 80057f4:	a918      	add	r1, sp, #96	; 0x60
 80057f6:	487d      	ldr	r0, [pc, #500]	; (80059ec <main+0x2fc>)
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80057f8:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
  GPIO_InitStruct.Pin = MC_ENBL_IN_Pin;
 80057fc:	e9cd 8418 	strd	r8, r4, [sp, #96]	; 0x60
  HAL_GPIO_Init(MC_ENBL_IN_GPIO_Port, &GPIO_InitStruct);
 8005800:	f7fc fb68 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 8005804:	2320      	movs	r3, #32
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005806:	a918      	add	r1, sp, #96	; 0x60
 8005808:	4879      	ldr	r0, [pc, #484]	; (80059f0 <main+0x300>)
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 800580a:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800580c:	941b      	str	r4, [sp, #108]	; 0x6c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800580e:	e9cd 6419 	strd	r6, r4, [sp, #100]	; 0x64
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005812:	f7fc fb5f 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = RDC_FAULTRES_Pin|IABC_CS_C_Pin;
 8005816:	f44f 6382 	mov.w	r3, #1040	; 0x410
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800581a:	a918      	add	r1, sp, #96	; 0x60
 800581c:	4875      	ldr	r0, [pc, #468]	; (80059f4 <main+0x304>)
  GPIO_InitStruct.Pin = RDC_FAULTRES_Pin|IABC_CS_C_Pin;
 800581e:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005820:	941b      	str	r4, [sp, #108]	; 0x6c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005822:	e9cd 6419 	strd	r6, r4, [sp, #100]	; 0x64
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005826:	f7fc fb55 	bl	8001ed4 <HAL_GPIO_Init>
  HAL_GPIO_Init(RDC_FAULT_GPIO_Port, &GPIO_InitStruct);
 800582a:	a918      	add	r1, sp, #96	; 0x60
 800582c:	4871      	ldr	r0, [pc, #452]	; (80059f4 <main+0x304>)
  GPIO_InitStruct.Pin = RDC_FAULT_Pin;
 800582e:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005832:	e9cd 4619 	strd	r4, r6, [sp, #100]	; 0x64
  HAL_GPIO_Init(RDC_FAULT_GPIO_Port, &GPIO_InitStruct);
 8005836:	f7fc fb4d 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = RDC_CS_Pin;
 800583a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_GPIO_Init(RDC_CS_GPIO_Port, &GPIO_InitStruct);
 800583e:	a918      	add	r1, sp, #96	; 0x60
 8005840:	486c      	ldr	r0, [pc, #432]	; (80059f4 <main+0x304>)
  GPIO_InitStruct.Pin = RDC_CS_Pin;
 8005842:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005844:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005848:	e9cd 6419 	strd	r6, r4, [sp, #100]	; 0x64
  HAL_GPIO_Init(RDC_CS_GPIO_Port, &GPIO_InitStruct);
 800584c:	f7fc fb42 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = RDC_NRST_Pin;
 8005850:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_GPIO_Init(RDC_NRST_GPIO_Port, &GPIO_InitStruct);
 8005854:	a918      	add	r1, sp, #96	; 0x60
 8005856:	4868      	ldr	r0, [pc, #416]	; (80059f8 <main+0x308>)
  GPIO_InitStruct.Pin = RDC_NRST_Pin;
 8005858:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800585a:	941b      	str	r4, [sp, #108]	; 0x6c
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800585c:	e9cd 6619 	strd	r6, r6, [sp, #100]	; 0x64
  HAL_GPIO_Init(RDC_NRST_GPIO_Port, &GPIO_InitStruct);
 8005860:	f7fc fb38 	bl	8001ed4 <HAL_GPIO_Init>
  HAL_GPIO_Init(GATE_DRIVER_FAULT_GPIO_Port, &GPIO_InitStruct);
 8005864:	a918      	add	r1, sp, #96	; 0x60
 8005866:	4864      	ldr	r0, [pc, #400]	; (80059f8 <main+0x308>)
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8005868:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800586c:	e9cd a418 	strd	sl, r4, [sp, #96]	; 0x60
  HAL_GPIO_Init(GATE_DRIVER_FAULT_GPIO_Port, &GPIO_InitStruct);
 8005870:	f7fc fb30 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = IABC_CNVST_Pin|IABC_OCD_Pin;
 8005874:	f44f 4384 	mov.w	r3, #16896	; 0x4200
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8005878:	a918      	add	r1, sp, #96	; 0x60
 800587a:	4860      	ldr	r0, [pc, #384]	; (80059fc <main+0x30c>)
  GPIO_InitStruct.Pin = IABC_CNVST_Pin|IABC_OCD_Pin;
 800587c:	9318      	str	r3, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800587e:	941b      	str	r4, [sp, #108]	; 0x6c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005880:	e9cd 6419 	strd	r6, r4, [sp, #100]	; 0x64
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8005884:	f7fc fb26 	bl	8001ed4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = IABC_CS_B_Pin|IABC_CS_A_Pin;
 8005888:	23c0      	movs	r3, #192	; 0xc0
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800588a:	a918      	add	r1, sp, #96	; 0x60
 800588c:	4859      	ldr	r0, [pc, #356]	; (80059f4 <main+0x304>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 800588e:	e9cd 3718 	strd	r3, r7, [sp, #96]	; 0x60
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005892:	e9cd 441a 	strd	r4, r4, [sp, #104]	; 0x68
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005896:	f7fc fb1d 	bl	8001ed4 <HAL_GPIO_Init>
  __HAL_RCC_DMA1_CLK_ENABLE();
 800589a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 800589c:	4622      	mov	r2, r4
 800589e:	4621      	mov	r1, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 80058a0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 80058a4:	200c      	movs	r0, #12
  __HAL_RCC_DMA1_CLK_ENABLE();
 80058a6:	632b      	str	r3, [r5, #48]	; 0x30
 80058a8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80058aa:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80058ae:	9300      	str	r3, [sp, #0]
 80058b0:	9b00      	ldr	r3, [sp, #0]
  __HAL_RCC_DMA2_CLK_ENABLE();
 80058b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80058b4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80058b8:	632b      	str	r3, [r5, #48]	; 0x30
 80058ba:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 80058bc:	f44f 65e0 	mov.w	r5, #1792	; 0x700
  __HAL_RCC_DMA2_CLK_ENABLE();
 80058c0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80058c4:	9301      	str	r3, [sp, #4]
 80058c6:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 80058c8:	f7fb fce2 	bl	8001290 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 80058cc:	200c      	movs	r0, #12
 80058ce:	f7fb fd15 	bl	80012fc <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 0, 0);
 80058d2:	4622      	mov	r2, r4
 80058d4:	4621      	mov	r1, r4
 80058d6:	4638      	mov	r0, r7
 80058d8:	f7fb fcda 	bl	8001290 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
 80058dc:	4638      	mov	r0, r7
 80058de:	f7fb fd0d 	bl	80012fc <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
 80058e2:	4622      	mov	r2, r4
 80058e4:	4621      	mov	r1, r4
 80058e6:	2038      	movs	r0, #56	; 0x38
 80058e8:	f7fb fcd2 	bl	8001290 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 80058ec:	2038      	movs	r0, #56	; 0x38
 80058ee:	f7fb fd05 	bl	80012fc <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
 80058f2:	4622      	mov	r2, r4
 80058f4:	4621      	mov	r1, r4
 80058f6:	203a      	movs	r0, #58	; 0x3a
 80058f8:	f7fb fcca 	bl	8001290 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 80058fc:	203a      	movs	r0, #58	; 0x3a
 80058fe:	f7fb fcfd 	bl	80012fc <HAL_NVIC_EnableIRQ>
  hspi2.Instance = SPI2;
 8005902:	4b3f      	ldr	r3, [pc, #252]	; (8005a00 <main+0x310>)
 8005904:	f8df c12c 	ldr.w	ip, [pc, #300]	; 8005a34 <main+0x344>
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8005908:	f44f 7782 	mov.w	r7, #260	; 0x104
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800590c:	2108      	movs	r1, #8
  hspi2.Init.CRCPolynomial = 7;
 800590e:	2207      	movs	r2, #7
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8005910:	4618      	mov	r0, r3
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
 8005912:	615e      	str	r6, [r3, #20]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 8005914:	609c      	str	r4, [r3, #8]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8005916:	611c      	str	r4, [r3, #16]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8005918:	f8c3 8018 	str.w	r8, [r3, #24]
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800591c:	629c      	str	r4, [r3, #40]	; 0x28
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 800591e:	60dd      	str	r5, [r3, #12]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8005920:	61d9      	str	r1, [r3, #28]
  hspi2.Init.CRCPolynomial = 7;
 8005922:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8005924:	e9c3 4408 	strd	r4, r4, [r3, #32]
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8005928:	e9c3 440c 	strd	r4, r4, [r3, #48]	; 0x30
  hspi2.Init.Mode = SPI_MODE_MASTER;
 800592c:	e9c3 c700 	strd	ip, r7, [r3]
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8005930:	f7fd fa78 	bl	8002e24 <HAL_SPI_Init>
 8005934:	2800      	cmp	r0, #0
 8005936:	f040 8332 	bne.w	8005f9e <main+0x8ae>
  hdfsdm1_filter0.Instance = DFSDM1_Filter0;
 800593a:	4b32      	ldr	r3, [pc, #200]	; (8005a04 <main+0x314>)
  hdfsdm1_filter0.Init.RegularParam.Trigger = DFSDM_FILTER_SW_TRIGGER;
 800593c:	2400      	movs	r4, #0
  hdfsdm1_filter0.Init.FilterParam.IntOversampling = 1;
 800593e:	2501      	movs	r5, #1
  hdfsdm1_filter0.Init.FilterParam.Oversampling = 100;
 8005940:	2664      	movs	r6, #100	; 0x64
  hdfsdm1_filter0.Init.FilterParam.SincOrder = DFSDM_FILTER_SINC3_ORDER;
 8005942:	f04f 47c0 	mov.w	r7, #1610612736	; 0x60000000
  hdfsdm1_filter0.Instance = DFSDM1_Filter0;
 8005946:	4a30      	ldr	r2, [pc, #192]	; (8005a08 <main+0x318>)
  HAL_DFSDM_FilterInit(&hdfsdm1_filter0);
 8005948:	4618      	mov	r0, r3
  hdfsdm1_filter0.Init.RegularParam.FastMode = DISABLE;
 800594a:	721c      	strb	r4, [r3, #8]
  hdfsdm1_filter0.Init.RegularParam.DmaMode = DISABLE;
 800594c:	725c      	strb	r4, [r3, #9]
  hdfsdm1_filter0.Init.FilterParam.IntOversampling = 1;
 800594e:	625d      	str	r5, [r3, #36]	; 0x24
  hdfsdm1_filter0.Init.RegularParam.Trigger = DFSDM_FILTER_SW_TRIGGER;
 8005950:	e9c3 2400 	strd	r2, r4, [r3]
  hdfsdm1_filter0.Init.FilterParam.Oversampling = 100;
 8005954:	e9c3 7607 	strd	r7, r6, [r3, #28]
  HAL_DFSDM_FilterInit(&hdfsdm1_filter0);
 8005958:	f7fb fdc8 	bl	80014ec <HAL_DFSDM_FilterInit>
  hdfsdm1_filter1.Instance = DFSDM1_Filter1;
 800595c:	4b2b      	ldr	r3, [pc, #172]	; (8005a0c <main+0x31c>)
 800595e:	4a2c      	ldr	r2, [pc, #176]	; (8005a10 <main+0x320>)
  HAL_DFSDM_FilterInit(&hdfsdm1_filter1);
 8005960:	4618      	mov	r0, r3
  hdfsdm1_filter1.Init.RegularParam.Trigger = DFSDM_FILTER_SW_TRIGGER;
 8005962:	605c      	str	r4, [r3, #4]
  hdfsdm1_filter1.Instance = DFSDM1_Filter1;
 8005964:	601a      	str	r2, [r3, #0]
  hdfsdm1_filter1.Init.RegularParam.FastMode = DISABLE;
 8005966:	721c      	strb	r4, [r3, #8]
  hdfsdm1_filter1.Init.RegularParam.DmaMode = DISABLE;
 8005968:	725c      	strb	r4, [r3, #9]
  hdfsdm1_filter1.Init.FilterParam.IntOversampling = 1;
 800596a:	625d      	str	r5, [r3, #36]	; 0x24
  hdfsdm1_filter1.Init.FilterParam.Oversampling = 100;
 800596c:	e9c3 7607 	strd	r7, r6, [r3, #28]
  HAL_DFSDM_FilterInit(&hdfsdm1_filter1);
 8005970:	f7fb fdbc 	bl	80014ec <HAL_DFSDM_FilterInit>
  hdfsdm1_filter2.Instance = DFSDM1_Filter2;
 8005974:	4b27      	ldr	r3, [pc, #156]	; (8005a14 <main+0x324>)
 8005976:	4a28      	ldr	r2, [pc, #160]	; (8005a18 <main+0x328>)
  HAL_DFSDM_FilterInit(&hdfsdm1_filter2);
 8005978:	4618      	mov	r0, r3
  hdfsdm1_filter2.Init.RegularParam.Trigger = DFSDM_FILTER_SW_TRIGGER;
 800597a:	605c      	str	r4, [r3, #4]
  hdfsdm1_filter2.Instance = DFSDM1_Filter2;
 800597c:	601a      	str	r2, [r3, #0]
  hdfsdm1_filter2.Init.RegularParam.FastMode = DISABLE;
 800597e:	721c      	strb	r4, [r3, #8]
  hdfsdm1_filter2.Init.RegularParam.DmaMode = DISABLE;
 8005980:	725c      	strb	r4, [r3, #9]
  hdfsdm1_filter2.Init.FilterParam.IntOversampling = 1;
 8005982:	625d      	str	r5, [r3, #36]	; 0x24
  hdfsdm1_filter2.Init.FilterParam.Oversampling = 100;
 8005984:	e9c3 7607 	strd	r7, r6, [r3, #28]
  HAL_DFSDM_FilterInit(&hdfsdm1_filter2);
 8005988:	f7fb fdb0 	bl	80014ec <HAL_DFSDM_FilterInit>
  hdfsdm1_filter3.Instance = DFSDM1_Filter3;
 800598c:	4b23      	ldr	r3, [pc, #140]	; (8005a1c <main+0x32c>)
 800598e:	4a24      	ldr	r2, [pc, #144]	; (8005a20 <main+0x330>)
  HAL_DFSDM_FilterInit(&hdfsdm1_filter3);
 8005990:	4618      	mov	r0, r3
  hdfsdm1_filter3.Init.FilterParam.SincOrder = DFSDM_FILTER_SINC3_ORDER;
 8005992:	61df      	str	r7, [r3, #28]
  hdfsdm1_filter3.Instance = DFSDM1_Filter3;
 8005994:	601a      	str	r2, [r3, #0]
  hdfsdm1_filter3.Init.RegularParam.Trigger = DFSDM_FILTER_SW_TRIGGER;
 8005996:	605c      	str	r4, [r3, #4]
  hdfsdm1_filter3.Init.RegularParam.FastMode = DISABLE;
 8005998:	721c      	strb	r4, [r3, #8]
  hdfsdm1_filter3.Init.RegularParam.DmaMode = DISABLE;
 800599a:	725c      	strb	r4, [r3, #9]
  hdfsdm1_filter3.Init.FilterParam.IntOversampling = 1;
 800599c:	e9c3 6508 	strd	r6, r5, [r3, #32]
  HAL_DFSDM_FilterInit(&hdfsdm1_filter3);
 80059a0:	f7fb fda4 	bl	80014ec <HAL_DFSDM_FilterInit>
  hdfsdm1_channel0.Instance = DFSDM1_Channel0;
 80059a4:	4b1f      	ldr	r3, [pc, #124]	; (8005a24 <main+0x334>)
  hdfsdm1_channel0.Init.OutputClock.Divider = 10;
 80059a6:	210a      	movs	r1, #10
  hdfsdm1_channel0.Instance = DFSDM1_Channel0;
 80059a8:	4e1f      	ldr	r6, [pc, #124]	; (8005a28 <main+0x338>)
  hdfsdm1_channel0.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 80059aa:	2204      	movs	r2, #4
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel0) != HAL_OK)
 80059ac:	4618      	mov	r0, r3
  hdfsdm1_channel0.Init.OutputClock.Activation = ENABLE;
 80059ae:	711d      	strb	r5, [r3, #4]
  hdfsdm1_channel0.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 80059b0:	609c      	str	r4, [r3, #8]
  hdfsdm1_channel0.Instance = DFSDM1_Channel0;
 80059b2:	601e      	str	r6, [r3, #0]
  hdfsdm1_channel0.Init.OutputClock.Divider = 10;
 80059b4:	60d9      	str	r1, [r3, #12]
  hdfsdm1_channel0.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 80059b6:	621a      	str	r2, [r3, #32]
  hdfsdm1_channel0.Init.Input.DataPacking = DFSDM_CHANNEL_STANDARD_MODE;
 80059b8:	e9c3 4404 	strd	r4, r4, [r3, #16]
  hdfsdm1_channel0.Init.SerialInterface.Type = DFSDM_CHANNEL_SPI_RISING;
 80059bc:	e9c3 4406 	strd	r4, r4, [r3, #24]
  hdfsdm1_channel0.Init.Awd.Oversampling = 1;
 80059c0:	e9c3 4509 	strd	r4, r5, [r3, #36]	; 0x24
  hdfsdm1_channel0.Init.RightBitShift = 0;
 80059c4:	e9c3 440b 	strd	r4, r4, [r3, #44]	; 0x2c
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel0) != HAL_OK)
 80059c8:	f7fb fcbe 	bl	8001348 <HAL_DFSDM_ChannelInit>
 80059cc:	2800      	cmp	r0, #0
 80059ce:	f040 82e3 	bne.w	8005f98 <main+0x8a8>
  hdfsdm1_channel1.Instance = DFSDM1_Channel1;
 80059d2:	4b16      	ldr	r3, [pc, #88]	; (8005a2c <main+0x33c>)
  hdfsdm1_channel1.Init.OutputClock.Divider = 10;
 80059d4:	220a      	movs	r2, #10
  hdfsdm1_channel1.Instance = DFSDM1_Channel1;
 80059d6:	4816      	ldr	r0, [pc, #88]	; (8005a30 <main+0x340>)
  hdfsdm1_channel1.Init.OutputClock.Activation = ENABLE;
 80059d8:	2101      	movs	r1, #1
  hdfsdm1_channel1.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 80059da:	2404      	movs	r4, #4
  hdfsdm1_channel1.Init.OutputClock.Divider = 10;
 80059dc:	60da      	str	r2, [r3, #12]
  hdfsdm1_channel1.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 80059de:	2200      	movs	r2, #0
  hdfsdm1_channel1.Instance = DFSDM1_Channel1;
 80059e0:	6018      	str	r0, [r3, #0]
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel1) != HAL_OK)
 80059e2:	4618      	mov	r0, r3
  hdfsdm1_channel1.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 80059e4:	621c      	str	r4, [r3, #32]
 80059e6:	e027      	b.n	8005a38 <main+0x348>
 80059e8:	40023800 	.word	0x40023800
 80059ec:	40021400 	.word	0x40021400
 80059f0:	40020000 	.word	0x40020000
 80059f4:	40020400 	.word	0x40020400
 80059f8:	40020c00 	.word	0x40020c00
 80059fc:	40021800 	.word	0x40021800
 8005a00:	20002350 	.word	0x20002350
 8005a04:	20002444 	.word	0x20002444
 8005a08:	40017500 	.word	0x40017500
 8005a0c:	2000272c 	.word	0x2000272c
 8005a10:	40017580 	.word	0x40017580
 8005a14:	200025dc 	.word	0x200025dc
 8005a18:	40017600 	.word	0x40017600
 8005a1c:	200026d8 	.word	0x200026d8
 8005a20:	40017680 	.word	0x40017680
 8005a24:	200027e0 	.word	0x200027e0
 8005a28:	40017400 	.word	0x40017400
 8005a2c:	20002318 	.word	0x20002318
 8005a30:	40017420 	.word	0x40017420
 8005a34:	40003800 	.word	0x40003800
  hdfsdm1_channel1.Init.OutputClock.Activation = ENABLE;
 8005a38:	7119      	strb	r1, [r3, #4]
  hdfsdm1_channel1.Init.Awd.Oversampling = 1;
 8005a3a:	6299      	str	r1, [r3, #40]	; 0x28
  hdfsdm1_channel1.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 8005a3c:	609a      	str	r2, [r3, #8]
  hdfsdm1_channel1.Init.Awd.FilterOrder = DFSDM_CHANNEL_FASTSINC_ORDER;
 8005a3e:	625a      	str	r2, [r3, #36]	; 0x24
  hdfsdm1_channel1.Init.Input.DataPacking = DFSDM_CHANNEL_STANDARD_MODE;
 8005a40:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hdfsdm1_channel1.Init.SerialInterface.Type = DFSDM_CHANNEL_SPI_RISING;
 8005a44:	e9c3 2206 	strd	r2, r2, [r3, #24]
  hdfsdm1_channel1.Init.RightBitShift = 0;
 8005a48:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel1) != HAL_OK)
 8005a4c:	f7fb fc7c 	bl	8001348 <HAL_DFSDM_ChannelInit>
 8005a50:	2800      	cmp	r0, #0
 8005a52:	f040 829e 	bne.w	8005f92 <main+0x8a2>
  hdfsdm1_channel3.Instance = DFSDM1_Channel3;
 8005a56:	4bb9      	ldr	r3, [pc, #740]	; (8005d3c <main+0x64c>)
  hdfsdm1_channel3.Init.OutputClock.Divider = 10;
 8005a58:	220a      	movs	r2, #10
  hdfsdm1_channel3.Instance = DFSDM1_Channel3;
 8005a5a:	48b9      	ldr	r0, [pc, #740]	; (8005d40 <main+0x650>)
  hdfsdm1_channel3.Init.OutputClock.Activation = ENABLE;
 8005a5c:	2101      	movs	r1, #1
  hdfsdm1_channel3.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 8005a5e:	2404      	movs	r4, #4
  hdfsdm1_channel3.Init.OutputClock.Divider = 10;
 8005a60:	60da      	str	r2, [r3, #12]
  hdfsdm1_channel3.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 8005a62:	2200      	movs	r2, #0
  hdfsdm1_channel3.Instance = DFSDM1_Channel3;
 8005a64:	6018      	str	r0, [r3, #0]
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel3) != HAL_OK)
 8005a66:	4618      	mov	r0, r3
  hdfsdm1_channel3.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 8005a68:	621c      	str	r4, [r3, #32]
  hdfsdm1_channel3.Init.OutputClock.Activation = ENABLE;
 8005a6a:	7119      	strb	r1, [r3, #4]
  hdfsdm1_channel3.Init.Awd.Oversampling = 1;
 8005a6c:	6299      	str	r1, [r3, #40]	; 0x28
  hdfsdm1_channel3.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 8005a6e:	609a      	str	r2, [r3, #8]
  hdfsdm1_channel3.Init.Awd.FilterOrder = DFSDM_CHANNEL_FASTSINC_ORDER;
 8005a70:	625a      	str	r2, [r3, #36]	; 0x24
  hdfsdm1_channel3.Init.Input.DataPacking = DFSDM_CHANNEL_STANDARD_MODE;
 8005a72:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hdfsdm1_channel3.Init.SerialInterface.Type = DFSDM_CHANNEL_SPI_RISING;
 8005a76:	e9c3 2206 	strd	r2, r2, [r3, #24]
  hdfsdm1_channel3.Init.RightBitShift = 0;
 8005a7a:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel3) != HAL_OK)
 8005a7e:	f7fb fc63 	bl	8001348 <HAL_DFSDM_ChannelInit>
 8005a82:	2800      	cmp	r0, #0
 8005a84:	f040 8282 	bne.w	8005f8c <main+0x89c>
  hdfsdm1_channel4.Instance = DFSDM1_Channel4;
 8005a88:	4bae      	ldr	r3, [pc, #696]	; (8005d44 <main+0x654>)
  hdfsdm1_channel4.Init.OutputClock.Divider = 10;
 8005a8a:	220a      	movs	r2, #10
  hdfsdm1_channel4.Instance = DFSDM1_Channel4;
 8005a8c:	48ae      	ldr	r0, [pc, #696]	; (8005d48 <main+0x658>)
  hdfsdm1_channel4.Init.OutputClock.Activation = ENABLE;
 8005a8e:	2101      	movs	r1, #1
  hdfsdm1_channel4.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 8005a90:	2404      	movs	r4, #4
  hdfsdm1_channel4.Init.OutputClock.Divider = 10;
 8005a92:	60da      	str	r2, [r3, #12]
  hdfsdm1_channel4.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 8005a94:	2200      	movs	r2, #0
  hdfsdm1_channel4.Instance = DFSDM1_Channel4;
 8005a96:	6018      	str	r0, [r3, #0]
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel4) != HAL_OK)
 8005a98:	4618      	mov	r0, r3
  hdfsdm1_channel4.Init.SerialInterface.SpiClock = DFSDM_CHANNEL_SPI_CLOCK_INTERNAL;
 8005a9a:	621c      	str	r4, [r3, #32]
  hdfsdm1_channel4.Init.OutputClock.Activation = ENABLE;
 8005a9c:	7119      	strb	r1, [r3, #4]
  hdfsdm1_channel4.Init.Awd.Oversampling = 1;
 8005a9e:	6299      	str	r1, [r3, #40]	; 0x28
  hdfsdm1_channel4.Init.OutputClock.Selection = DFSDM_CHANNEL_OUTPUT_CLOCK_SYSTEM;
 8005aa0:	609a      	str	r2, [r3, #8]
  hdfsdm1_channel4.Init.Awd.FilterOrder = DFSDM_CHANNEL_FASTSINC_ORDER;
 8005aa2:	625a      	str	r2, [r3, #36]	; 0x24
  hdfsdm1_channel4.Init.Input.DataPacking = DFSDM_CHANNEL_STANDARD_MODE;
 8005aa4:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hdfsdm1_channel4.Init.SerialInterface.Type = DFSDM_CHANNEL_SPI_RISING;
 8005aa8:	e9c3 2206 	strd	r2, r2, [r3, #24]
  hdfsdm1_channel4.Init.RightBitShift = 0;
 8005aac:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  if (HAL_DFSDM_ChannelInit(&hdfsdm1_channel4) != HAL_OK)
 8005ab0:	f7fb fc4a 	bl	8001348 <HAL_DFSDM_ChannelInit>
 8005ab4:	2800      	cmp	r0, #0
 8005ab6:	f040 8266 	bne.w	8005f86 <main+0x896>
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter0, DFSDM_CHANNEL_4, DFSDM_CONTINUOUS_CONV_ON);
 8005aba:	2201      	movs	r2, #1
 8005abc:	49a3      	ldr	r1, [pc, #652]	; (8005d4c <main+0x65c>)
 8005abe:	48a4      	ldr	r0, [pc, #656]	; (8005d50 <main+0x660>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005ac0:	2400      	movs	r4, #0
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter0, DFSDM_CHANNEL_4, DFSDM_CONTINUOUS_CONV_ON);
 8005ac2:	f7fb fd89 	bl	80015d8 <HAL_DFSDM_FilterConfigRegChannel>
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter1, DFSDM_CHANNEL_0, DFSDM_CONTINUOUS_CONV_ON);
 8005ac6:	2201      	movs	r2, #1
 8005ac8:	48a2      	ldr	r0, [pc, #648]	; (8005d54 <main+0x664>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8005aca:	2520      	movs	r5, #32
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter1, DFSDM_CHANNEL_0, DFSDM_CONTINUOUS_CONV_ON);
 8005acc:	4611      	mov	r1, r2
  htim1.Instance = TIM1;
 8005ace:	4ea2      	ldr	r6, [pc, #648]	; (8005d58 <main+0x668>)
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter1, DFSDM_CHANNEL_0, DFSDM_CONTINUOUS_CONV_ON);
 8005ad0:	f7fb fd82 	bl	80015d8 <HAL_DFSDM_FilterConfigRegChannel>
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter2, DFSDM_CHANNEL_1, DFSDM_CONTINUOUS_CONV_ON);
 8005ad4:	2201      	movs	r2, #1
 8005ad6:	49a1      	ldr	r1, [pc, #644]	; (8005d5c <main+0x66c>)
 8005ad8:	48a1      	ldr	r0, [pc, #644]	; (8005d60 <main+0x670>)
 8005ada:	f7fb fd7d 	bl	80015d8 <HAL_DFSDM_FilterConfigRegChannel>
  HAL_DFSDM_FilterConfigRegChannel(&hdfsdm1_filter3, DFSDM_CHANNEL_3, DFSDM_CONTINUOUS_CONV_ON);
 8005ade:	2201      	movs	r2, #1
 8005ae0:	49a0      	ldr	r1, [pc, #640]	; (8005d64 <main+0x674>)
 8005ae2:	48a1      	ldr	r0, [pc, #644]	; (8005d68 <main+0x678>)
 8005ae4:	f7fb fd78 	bl	80015d8 <HAL_DFSDM_FilterConfigRegChannel>
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8005ae8:	4621      	mov	r1, r4
 8005aea:	222c      	movs	r2, #44	; 0x2c
 8005aec:	a818      	add	r0, sp, #96	; 0x60
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005aee:	940d      	str	r4, [sp, #52]	; 0x34
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005af0:	940a      	str	r4, [sp, #40]	; 0x28
  TIM_OC_InitTypeDef sConfigOC = {0};
 8005af2:	9411      	str	r4, [sp, #68]	; 0x44
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005af4:	9410      	str	r4, [sp, #64]	; 0x40
 8005af6:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005afa:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  TIM_OC_InitTypeDef sConfigOC = {0};
 8005afe:	e9cd 4412 	strd	r4, r4, [sp, #72]	; 0x48
 8005b02:	e9cd 4414 	strd	r4, r4, [sp, #80]	; 0x50
 8005b06:	e9cd 4416 	strd	r4, r4, [sp, #88]	; 0x58
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8005b0a:	f003 ff04 	bl	8009916 <memset>
  htim1.Instance = TIM1;
 8005b0e:	4b97      	ldr	r3, [pc, #604]	; (8005d6c <main+0x67c>)
  htim1.Init.Period = 6749;
 8005b10:	f641 215d 	movw	r1, #6749	; 0x1a5d
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005b14:	2280      	movs	r2, #128	; 0x80
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8005b16:	4618      	mov	r0, r3
  htim1.Init.Prescaler = 0;
 8005b18:	605c      	str	r4, [r3, #4]
  htim1.Instance = TIM1;
 8005b1a:	601e      	str	r6, [r3, #0]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005b1c:	619a      	str	r2, [r3, #24]
  htim1.Init.RepetitionCounter = 0;
 8005b1e:	e9c3 4404 	strd	r4, r4, [r3, #16]
  htim1.Init.Period = 6749;
 8005b22:	e9c3 5102 	strd	r5, r1, [r3, #8]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8005b26:	f7fd fcd5 	bl	80034d4 <HAL_TIM_Base_Init>
 8005b2a:	2800      	cmp	r0, #0
 8005b2c:	f040 8228 	bne.w	8005f80 <main+0x890>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005b30:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8005b34:	a90d      	add	r1, sp, #52	; 0x34
 8005b36:	488d      	ldr	r0, [pc, #564]	; (8005d6c <main+0x67c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005b38:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8005b3a:	f7fe f82b 	bl	8003b94 <HAL_TIM_ConfigClockSource>
 8005b3e:	2800      	cmp	r0, #0
 8005b40:	f040 821b 	bne.w	8005f7a <main+0x88a>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8005b44:	4889      	ldr	r0, [pc, #548]	; (8005d6c <main+0x67c>)
 8005b46:	f7fd fda7 	bl	8003698 <HAL_TIM_PWM_Init>
 8005b4a:	2800      	cmp	r0, #0
 8005b4c:	f040 8212 	bne.w	8005f74 <main+0x884>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8005b50:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8005b52:	a90a      	add	r1, sp, #40	; 0x28
 8005b54:	4885      	ldr	r0, [pc, #532]	; (8005d6c <main+0x67c>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005b56:	930c      	str	r3, [sp, #48]	; 0x30
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8005b58:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8005b5c:	f7fe f9d4 	bl	8003f08 <HAL_TIMEx_MasterConfigSynchronization>
 8005b60:	2800      	cmp	r0, #0
 8005b62:	f040 8204 	bne.w	8005f6e <main+0x87e>
  sConfigOC.Pulse = 0;
 8005b66:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8005b68:	2460      	movs	r4, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005b6a:	a911      	add	r1, sp, #68	; 0x44
 8005b6c:	487f      	ldr	r0, [pc, #508]	; (8005d6c <main+0x67c>)
 8005b6e:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8005b70:	9312      	str	r3, [sp, #72]	; 0x48
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8005b72:	9317      	str	r3, [sp, #92]	; 0x5c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8005b74:	9411      	str	r4, [sp, #68]	; 0x44
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8005b76:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8005b7a:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005b7e:	f7fd fe7b 	bl	8003878 <HAL_TIM_PWM_ConfigChannel>
 8005b82:	2800      	cmp	r0, #0
 8005b84:	f040 81f0 	bne.w	8005f68 <main+0x878>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005b88:	2204      	movs	r2, #4
 8005b8a:	a911      	add	r1, sp, #68	; 0x44
 8005b8c:	4877      	ldr	r0, [pc, #476]	; (8005d6c <main+0x67c>)
 8005b8e:	f7fd fe73 	bl	8003878 <HAL_TIM_PWM_ConfigChannel>
 8005b92:	2800      	cmp	r0, #0
 8005b94:	f040 81e5 	bne.w	8005f62 <main+0x872>
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 8005b98:	2304      	movs	r3, #4
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8005b9a:	2208      	movs	r2, #8
 8005b9c:	a911      	add	r1, sp, #68	; 0x44
 8005b9e:	4873      	ldr	r0, [pc, #460]	; (8005d6c <main+0x67c>)
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 8005ba0:	9315      	str	r3, [sp, #84]	; 0x54
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8005ba2:	f7fd fe69 	bl	8003878 <HAL_TIM_PWM_ConfigChannel>
 8005ba6:	2800      	cmp	r0, #0
 8005ba8:	f040 81d8 	bne.w	8005f5c <main+0x86c>
  sBreakDeadTimeConfig.DeadTime = 172;
 8005bac:	20ac      	movs	r0, #172	; 0xac
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8005bae:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8005bb0:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8005bb4:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  sBreakDeadTimeConfig.DeadTime = 172;
 8005bb8:	901b      	str	r0, [sp, #108]	; 0x6c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005bba:	a918      	add	r1, sp, #96	; 0x60
 8005bbc:	486b      	ldr	r0, [pc, #428]	; (8005d6c <main+0x67c>)
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8005bbe:	9318      	str	r3, [sp, #96]	; 0x60
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 8005bc0:	931c      	str	r3, [sp, #112]	; 0x70
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8005bc2:	941d      	str	r4, [sp, #116]	; 0x74
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8005bc4:	9220      	str	r2, [sp, #128]	; 0x80
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8005bc6:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 8005bca:	e9cd 331e 	strd	r3, r3, [sp, #120]	; 0x78
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8005bce:	e9cd 3321 	strd	r3, r3, [sp, #132]	; 0x84
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005bd2:	f7fe f9c9 	bl	8003f68 <HAL_TIMEx_ConfigBreakDeadTime>
 8005bd6:	2800      	cmp	r0, #0
 8005bd8:	f040 81bd 	bne.w	8005f56 <main+0x866>
  HAL_TIM_MspPostInit(&htim1);
 8005bdc:	4863      	ldr	r0, [pc, #396]	; (8005d6c <main+0x67c>)
  htim3.Init.Period = 6749;
 8005bde:	f641 245d 	movw	r4, #6749	; 0x1a5d
  HAL_TIM_MspPostInit(&htim1);
 8005be2:	f000 fcdf 	bl	80065a4 <HAL_TIM_MspPostInit>
  htim3.Instance = TIM3;
 8005be6:	4a62      	ldr	r2, [pc, #392]	; (8005d70 <main+0x680>)
 8005be8:	4862      	ldr	r0, [pc, #392]	; (8005d74 <main+0x684>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005bea:	2300      	movs	r3, #0
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005bec:	2180      	movs	r1, #128	; 0x80
  htim3.Init.Period = 6749;
 8005bee:	60d4      	str	r4, [r2, #12]
  htim3.Instance = TIM3;
 8005bf0:	6010      	str	r0, [r2, #0]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8005bf2:	4610      	mov	r0, r2
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005bf4:	6191      	str	r1, [r2, #24]
  htim3.Init.Prescaler = 0;
 8005bf6:	6053      	str	r3, [r2, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005bf8:	9313      	str	r3, [sp, #76]	; 0x4c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005bfa:	6093      	str	r3, [r2, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8005bfc:	6113      	str	r3, [r2, #16]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005bfe:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
 8005c02:	e9cd 331a 	strd	r3, r3, [sp, #104]	; 0x68
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005c06:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8005c0a:	f7fd fc63 	bl	80034d4 <HAL_TIM_Base_Init>
 8005c0e:	2800      	cmp	r0, #0
 8005c10:	f040 819e 	bne.w	8005f50 <main+0x860>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005c14:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8005c18:	a918      	add	r1, sp, #96	; 0x60
 8005c1a:	4855      	ldr	r0, [pc, #340]	; (8005d70 <main+0x680>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005c1c:	9318      	str	r3, [sp, #96]	; 0x60
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8005c1e:	f7fd ffb9 	bl	8003b94 <HAL_TIM_ConfigClockSource>
 8005c22:	2800      	cmp	r0, #0
 8005c24:	f040 8191 	bne.w	8005f4a <main+0x85a>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8005c28:	2220      	movs	r2, #32
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005c2a:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8005c2c:	a911      	add	r1, sp, #68	; 0x44
 8005c2e:	4850      	ldr	r0, [pc, #320]	; (8005d70 <main+0x680>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8005c30:	9211      	str	r2, [sp, #68]	; 0x44
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005c32:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8005c34:	f7fe f968 	bl	8003f08 <HAL_TIMEx_MasterConfigSynchronization>
 8005c38:	2800      	cmp	r0, #0
 8005c3a:	f040 8183 	bne.w	8005f44 <main+0x854>
  ADC_ChannelConfTypeDef sConfig = {0};
 8005c3e:	2400      	movs	r4, #0
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8005c40:	2220      	movs	r2, #32
 8005c42:	a818      	add	r0, sp, #96	; 0x60
  hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005c44:	f44f 3500 	mov.w	r5, #131072	; 0x20000
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8005c48:	4621      	mov	r1, r4
  ADC_ChannelConfTypeDef sConfig = {0};
 8005c4a:	e9cd 4411 	strd	r4, r4, [sp, #68]	; 0x44
 8005c4e:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8005c52:	f003 fe60 	bl	8009916 <memset>
  hadc2.Instance = ADC2;
 8005c56:	4b48      	ldr	r3, [pc, #288]	; (8005d78 <main+0x688>)
 8005c58:	4948      	ldr	r1, [pc, #288]	; (8005d7c <main+0x68c>)
  hadc2.Init.NbrOfConversion = 1;
 8005c5a:	2201      	movs	r2, #1
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8005c5c:	4618      	mov	r0, r3
  hadc2.Init.Resolution = ADC_RESOLUTION_12B;
 8005c5e:	609c      	str	r4, [r3, #8]
  hadc2.Instance = ADC2;
 8005c60:	6019      	str	r1, [r3, #0]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005c62:	4947      	ldr	r1, [pc, #284]	; (8005d80 <main+0x690>)
  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8005c64:	611c      	str	r4, [r3, #16]
  hadc2.Init.ContinuousConvMode = DISABLE;
 8005c66:	619c      	str	r4, [r3, #24]
  hadc2.Init.DiscontinuousConvMode = DISABLE;
 8005c68:	f883 4020 	strb.w	r4, [r3, #32]
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8005c6c:	62dc      	str	r4, [r3, #44]	; 0x2c
  hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8005c6e:	60dc      	str	r4, [r3, #12]
  hadc2.Init.DMAContinuousRequests = DISABLE;
 8005c70:	f883 4030 	strb.w	r4, [r3, #48]	; 0x30
  hadc2.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8005c74:	615c      	str	r4, [r3, #20]
  hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005c76:	605d      	str	r5, [r3, #4]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005c78:	6299      	str	r1, [r3, #40]	; 0x28
  hadc2.Init.NbrOfConversion = 1;
 8005c7a:	61da      	str	r2, [r3, #28]
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8005c7c:	f7fa fcb0 	bl	80005e0 <HAL_ADC_Init>
 8005c80:	2800      	cmp	r0, #0
 8005c82:	f040 815c 	bne.w	8005f3e <main+0x84e>
  sConfig.Channel = ADC_CHANNEL_7;
 8005c86:	2407      	movs	r4, #7
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005c88:	2201      	movs	r2, #1
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005c8a:	2300      	movs	r3, #0
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8005c8c:	a911      	add	r1, sp, #68	; 0x44
 8005c8e:	483a      	ldr	r0, [pc, #232]	; (8005d78 <main+0x688>)
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005c90:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005c92:	e9cd 4211 	strd	r4, r2, [sp, #68]	; 0x44
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8005c96:	f7fa fe39 	bl	800090c <HAL_ADC_ConfigChannel>
 8005c9a:	2800      	cmp	r0, #0
 8005c9c:	f040 814c 	bne.w	8005f38 <main+0x848>
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 8005ca0:	4838      	ldr	r0, [pc, #224]	; (8005d84 <main+0x694>)
 8005ca2:	2100      	movs	r1, #0
  sConfigInjected.AutoInjectedConv = DISABLE;
 8005ca4:	2300      	movs	r3, #0
  sConfigInjected.InjectedNbrOfConversion = 1;
 8005ca6:	2201      	movs	r2, #1
  sConfigInjected.InjectedChannel = ADC_CHANNEL_15;
 8005ca8:	260f      	movs	r6, #15
 8005caa:	2701      	movs	r7, #1
 8005cac:	2400      	movs	r4, #0
 8005cae:	2500      	movs	r5, #0
  sConfigInjected.InjectedNbrOfConversion = 1;
 8005cb0:	921c      	str	r2, [sp, #112]	; 0x70
  sConfigInjected.AutoInjectedConv = DISABLE;
 8005cb2:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8005cb6:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 8005cba:	e9cd 011e 	strd	r0, r1, [sp, #120]	; 0x78
  if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)
 8005cbe:	a918      	add	r1, sp, #96	; 0x60
 8005cc0:	482d      	ldr	r0, [pc, #180]	; (8005d78 <main+0x688>)
  sConfigInjected.InjectedChannel = ADC_CHANNEL_15;
 8005cc2:	e9cd 6718 	strd	r6, r7, [sp, #96]	; 0x60
 8005cc6:	e9cd 451a 	strd	r4, r5, [sp, #104]	; 0x68
  if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)
 8005cca:	f7fa fed3 	bl	8000a74 <HAL_ADCEx_InjectedConfigChannel>
 8005cce:	2800      	cmp	r0, #0
 8005cd0:	f040 812f 	bne.w	8005f32 <main+0x842>
  hadc1.Instance = ADC1;
 8005cd4:	4b2c      	ldr	r3, [pc, #176]	; (8005d88 <main+0x698>)
  ADC_ChannelConfTypeDef sConfig = {0};
 8005cd6:	2200      	movs	r2, #0
  hadc1.Instance = ADC1;
 8005cd8:	482c      	ldr	r0, [pc, #176]	; (8005d8c <main+0x69c>)
  hadc1.Init.NbrOfConversion = 1;
 8005cda:	2101      	movs	r1, #1
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005cdc:	f44f 3500 	mov.w	r5, #131072	; 0x20000
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005ce0:	4c27      	ldr	r4, [pc, #156]	; (8005d80 <main+0x690>)
  hadc1.Instance = ADC1;
 8005ce2:	6018      	str	r0, [r3, #0]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8005ce4:	4618      	mov	r0, r3
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005ce6:	605d      	str	r5, [r3, #4]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005ce8:	629c      	str	r4, [r3, #40]	; 0x28
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8005cea:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8005cec:	611a      	str	r2, [r3, #16]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8005cee:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8005cf0:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8005cf4:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8005cf6:	60da      	str	r2, [r3, #12]
  hadc1.Init.NbrOfConversion = 1;
 8005cf8:	61d9      	str	r1, [r3, #28]
  hadc1.Init.DMAContinuousRequests = ENABLE;
 8005cfa:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8005cfe:	6159      	str	r1, [r3, #20]
  ADC_ChannelConfTypeDef sConfig = {0};
 8005d00:	e9cd 2218 	strd	r2, r2, [sp, #96]	; 0x60
 8005d04:	e9cd 221a 	strd	r2, r2, [sp, #104]	; 0x68
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8005d08:	f7fa fc6a 	bl	80005e0 <HAL_ADC_Init>
 8005d0c:	2800      	cmp	r0, #0
 8005d0e:	f040 810d 	bne.w	8005f2c <main+0x83c>
  sConfig.Channel = ADC_CHANNEL_6;
 8005d12:	2406      	movs	r4, #6
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005d14:	2201      	movs	r2, #1
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005d16:	2300      	movs	r3, #0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8005d18:	a918      	add	r1, sp, #96	; 0x60
 8005d1a:	481b      	ldr	r0, [pc, #108]	; (8005d88 <main+0x698>)
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005d1c:	931a      	str	r3, [sp, #104]	; 0x68
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005d1e:	e9cd 4218 	strd	r4, r2, [sp, #96]	; 0x60
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8005d22:	f7fa fdf3 	bl	800090c <HAL_ADC_ConfigChannel>
 8005d26:	2800      	cmp	r0, #0
 8005d28:	f040 80fd 	bne.w	8005f26 <main+0x836>
  hadc3.Instance = ADC3;
 8005d2c:	4b18      	ldr	r3, [pc, #96]	; (8005d90 <main+0x6a0>)
  ADC_ChannelConfTypeDef sConfig = {0};
 8005d2e:	2200      	movs	r2, #0
  hadc3.Instance = ADC3;
 8005d30:	4818      	ldr	r0, [pc, #96]	; (8005d94 <main+0x6a4>)
  hadc3.Init.NbrOfConversion = 1;
 8005d32:	2101      	movs	r1, #1
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005d34:	f44f 3500 	mov.w	r5, #131072	; 0x20000
 8005d38:	e02e      	b.n	8005d98 <main+0x6a8>
 8005d3a:	bf00      	nop
 8005d3c:	2000255c 	.word	0x2000255c
 8005d40:	40017460 	.word	0x40017460
 8005d44:	200023fc 	.word	0x200023fc
 8005d48:	40017480 	.word	0x40017480
 8005d4c:	00040010 	.word	0x00040010
 8005d50:	20002444 	.word	0x20002444
 8005d54:	2000272c 	.word	0x2000272c
 8005d58:	40010000 	.word	0x40010000
 8005d5c:	00010002 	.word	0x00010002
 8005d60:	200025dc 	.word	0x200025dc
 8005d64:	00030008 	.word	0x00030008
 8005d68:	200026d8 	.word	0x200026d8
 8005d6c:	200022a0 	.word	0x200022a0
 8005d70:	20002260 	.word	0x20002260
 8005d74:	40000400 	.word	0x40000400
 8005d78:	200023b4 	.word	0x200023b4
 8005d7c:	40012100 	.word	0x40012100
 8005d80:	0f000001 	.word	0x0f000001
 8005d84:	000f0001 	.word	0x000f0001
 8005d88:	20002594 	.word	0x20002594
 8005d8c:	40012000 	.word	0x40012000
 8005d90:	20002630 	.word	0x20002630
 8005d94:	40012200 	.word	0x40012200
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005d98:	4c82      	ldr	r4, [pc, #520]	; (8005fa4 <main+0x8b4>)
  hadc3.Instance = ADC3;
 8005d9a:	6018      	str	r0, [r3, #0]
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 8005d9c:	4618      	mov	r0, r3
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV6;
 8005d9e:	605d      	str	r5, [r3, #4]
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005da0:	629c      	str	r4, [r3, #40]	; 0x28
  hadc3.Init.Resolution = ADC_RESOLUTION_12B;
 8005da2:	609a      	str	r2, [r3, #8]
  hadc3.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8005da4:	611a      	str	r2, [r3, #16]
  hadc3.Init.ContinuousConvMode = DISABLE;
 8005da6:	619a      	str	r2, [r3, #24]
  hadc3.Init.DiscontinuousConvMode = DISABLE;
 8005da8:	f883 2020 	strb.w	r2, [r3, #32]
  hadc3.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8005dac:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc3.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8005dae:	60da      	str	r2, [r3, #12]
  hadc3.Init.DMAContinuousRequests = DISABLE;
 8005db0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc3.Init.NbrOfConversion = 1;
 8005db4:	61d9      	str	r1, [r3, #28]
  hadc3.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8005db6:	6159      	str	r1, [r3, #20]
  ADC_ChannelConfTypeDef sConfig = {0};
 8005db8:	e9cd 2218 	strd	r2, r2, [sp, #96]	; 0x60
 8005dbc:	e9cd 221a 	strd	r2, r2, [sp, #104]	; 0x68
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 8005dc0:	f7fa fc0e 	bl	80005e0 <HAL_ADC_Init>
 8005dc4:	2800      	cmp	r0, #0
 8005dc6:	f040 80ab 	bne.w	8005f20 <main+0x830>
  sConfig.Channel = ADC_CHANNEL_3;
 8005dca:	2403      	movs	r4, #3
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005dcc:	2201      	movs	r2, #1
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005dce:	2300      	movs	r3, #0
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 8005dd0:	a918      	add	r1, sp, #96	; 0x60
 8005dd2:	4875      	ldr	r0, [pc, #468]	; (8005fa8 <main+0x8b8>)
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8005dd4:	931a      	str	r3, [sp, #104]	; 0x68
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8005dd6:	e9cd 4218 	strd	r4, r2, [sp, #96]	; 0x60
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 8005dda:	f7fa fd97 	bl	800090c <HAL_ADC_ConfigChannel>
 8005dde:	2800      	cmp	r0, #0
 8005de0:	f040 809b 	bne.w	8005f1a <main+0x82a>
  huart2.Instance = USART2;
 8005de4:	4b71      	ldr	r3, [pc, #452]	; (8005fac <main+0x8bc>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8005de6:	2200      	movs	r2, #0
  huart2.Init.BaudRate = 921600;
 8005de8:	f44f 2461 	mov.w	r4, #921600	; 0xe1000
  huart2.Instance = USART2;
 8005dec:	4d70      	ldr	r5, [pc, #448]	; (8005fb0 <main+0x8c0>)
  huart2.Init.Mode = UART_MODE_TX_RX;
 8005dee:	210c      	movs	r1, #12
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8005df0:	4618      	mov	r0, r3
  huart2.Init.Parity = UART_PARITY_NONE;
 8005df2:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8005df4:	6159      	str	r1, [r3, #20]
  huart2.Init.BaudRate = 921600;
 8005df6:	e9c3 5400 	strd	r5, r4, [r3]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8005dfa:	e9c3 2202 	strd	r2, r2, [r3, #8]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8005dfe:	e9c3 2206 	strd	r2, r2, [r3, #24]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8005e02:	e9c3 2208 	strd	r2, r2, [r3, #32]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8005e06:	f7fe fbf9 	bl	80045fc <HAL_UART_Init>
 8005e0a:	2800      	cmp	r0, #0
 8005e0c:	f040 8082 	bne.w	8005f14 <main+0x824>
  hcan1.Instance = CAN1;
 8005e10:	4b68      	ldr	r3, [pc, #416]	; (8005fb4 <main+0x8c4>)
  hcan1.Init.Mode = CAN_MODE_NORMAL;
 8005e12:	2200      	movs	r2, #0
  hcan1.Instance = CAN1;
 8005e14:	4868      	ldr	r0, [pc, #416]	; (8005fb8 <main+0x8c8>)
  hcan1.Init.Prescaler = 20;
 8005e16:	2514      	movs	r5, #20
  hcan1.Init.TimeSeg1 = CAN_BS1_4TQ;
 8005e18:	f44f 3440 	mov.w	r4, #196608	; 0x30000
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
 8005e1c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  hcan1.Instance = CAN1;
 8005e20:	6018      	str	r0, [r3, #0]
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
 8005e22:	4618      	mov	r0, r3
  hcan1.Init.TimeTriggeredMode = DISABLE;
 8005e24:	619a      	str	r2, [r3, #24]
  hcan1.Init.Prescaler = 20;
 8005e26:	605d      	str	r5, [r3, #4]
  hcan1.Init.ReceiveFifoLocked = DISABLE;
 8005e28:	771a      	strb	r2, [r3, #28]
  hcan1.Init.TransmitFifoPriority = DISABLE;
 8005e2a:	775a      	strb	r2, [r3, #29]
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
 8005e2c:	e9c3 4104 	strd	r4, r1, [r3, #16]
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
 8005e30:	e9c3 2202 	strd	r2, r2, [r3, #8]
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
 8005e34:	f7fa fefa 	bl	8000c2c <HAL_CAN_Init>
 8005e38:	2800      	cmp	r0, #0
 8005e3a:	d168      	bne.n	8005f0e <main+0x81e>
  hspi6.Instance = SPI6;
 8005e3c:	4b5f      	ldr	r3, [pc, #380]	; (8005fbc <main+0x8cc>)
  hspi6.Init.Mode = SPI_MODE_MASTER;
 8005e3e:	f44f 7182 	mov.w	r1, #260	; 0x104
  hspi6.Instance = SPI6;
 8005e42:	4c5f      	ldr	r4, [pc, #380]	; (8005fc0 <main+0x8d0>)
  hspi6.Init.DataSize = SPI_DATASIZE_8BIT;
 8005e44:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  hspi6.Init.NSS = SPI_NSS_SOFT;
 8005e48:	f44f 7000 	mov.w	r0, #512	; 0x200
  hspi6.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8005e4c:	2510      	movs	r5, #16
  hspi6.Instance = SPI6;
 8005e4e:	601c      	str	r4, [r3, #0]
  hspi6.Init.CRCPolynomial = 7;
 8005e50:	2407      	movs	r4, #7
  hspi6.Init.Mode = SPI_MODE_MASTER;
 8005e52:	6059      	str	r1, [r3, #4]
  hspi6.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8005e54:	2108      	movs	r1, #8
  hspi6.Init.DataSize = SPI_DATASIZE_8BIT;
 8005e56:	60da      	str	r2, [r3, #12]
  hspi6.Init.Direction = SPI_DIRECTION_2LINES;
 8005e58:	2200      	movs	r2, #0
  hspi6.Init.NSS = SPI_NSS_SOFT;
 8005e5a:	6198      	str	r0, [r3, #24]
  if (HAL_SPI_Init(&hspi6) != HAL_OK)
 8005e5c:	4618      	mov	r0, r3
  hspi6.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8005e5e:	61dd      	str	r5, [r3, #28]
  hspi6.Init.CRCPolynomial = 7;
 8005e60:	62dc      	str	r4, [r3, #44]	; 0x2c
  hspi6.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8005e62:	6359      	str	r1, [r3, #52]	; 0x34
  hspi6.Init.Direction = SPI_DIRECTION_2LINES;
 8005e64:	609a      	str	r2, [r3, #8]
  hspi6.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005e66:	629a      	str	r2, [r3, #40]	; 0x28
  hspi6.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8005e68:	631a      	str	r2, [r3, #48]	; 0x30
  hspi6.Init.CLKPhase = SPI_PHASE_1EDGE;
 8005e6a:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hspi6.Init.TIMode = SPI_TIMODE_DISABLE;
 8005e6e:	e9c3 2208 	strd	r2, r2, [r3, #32]
  if (HAL_SPI_Init(&hspi6) != HAL_OK)
 8005e72:	f7fc ffd7 	bl	8002e24 <HAL_SPI_Init>
 8005e76:	2800      	cmp	r0, #0
 8005e78:	d146      	bne.n	8005f08 <main+0x818>
  can_init(&hcan1);
 8005e7a:	484e      	ldr	r0, [pc, #312]	; (8005fb4 <main+0x8c4>)
 8005e7c:	f000 fcbc 	bl	80067f8 <can_init>
  hiwdg.Instance = IWDG;
 8005e80:	4c50      	ldr	r4, [pc, #320]	; (8005fc4 <main+0x8d4>)
  control_init();
 8005e82:	f7fe ff29 	bl	8004cd8 <control_init>
  hiwdg.Instance = IWDG;
 8005e86:	4b50      	ldr	r3, [pc, #320]	; (8005fc8 <main+0x8d8>)
  hiwdg.Init.Prescaler = IWDG_PRESCALER_8;
 8005e88:	2101      	movs	r1, #1
  hiwdg.Init.Window = 4095;
 8005e8a:	f640 72ff 	movw	r2, #4095	; 0xfff
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 8005e8e:	4618      	mov	r0, r3
  hiwdg.Init.Prescaler = IWDG_PRESCALER_8;
 8005e90:	e9c3 4100 	strd	r4, r1, [r3]
  hiwdg.Init.Reload = 4095;
 8005e94:	e9c3 2202 	strd	r2, r2, [r3, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 8005e98:	f7fc f944 	bl	8002124 <HAL_IWDG_Init>
 8005e9c:	bb88      	cbnz	r0, 8005f02 <main+0x812>
  serial_init(&huart2);
 8005e9e:	4843      	ldr	r0, [pc, #268]	; (8005fac <main+0x8bc>)
 8005ea0:	f000 feec 	bl	8006c7c <serial_init>
 8005ea4:	4c49      	ldr	r4, [pc, #292]	; (8005fcc <main+0x8dc>)
  log_init();
 8005ea6:	f000 fd07 	bl	80068b8 <log_init>
  data_init(&hcan1, &hadc1);
 8005eaa:	4949      	ldr	r1, [pc, #292]	; (8005fd0 <main+0x8e0>)
 8005eac:	4841      	ldr	r0, [pc, #260]	; (8005fb4 <main+0x8c4>)
		log_push(&mc_vars);
 8005eae:	4626      	mov	r6, r4
  data_init(&hcan1, &hadc1);
 8005eb0:	f000 fc72 	bl	8006798 <data_init>
  HAL_GPIO_WritePin(GPIOF, LED_RED_Pin, LOW);
 8005eb4:	2200      	movs	r2, #0
 8005eb6:	2104      	movs	r1, #4
 8005eb8:	4846      	ldr	r0, [pc, #280]	; (8005fd4 <main+0x8e4>)
 8005eba:	f7fc f92f 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, LED_GREEN_Pin, LOW);
 8005ebe:	2200      	movs	r2, #0
 8005ec0:	2102      	movs	r1, #2
 8005ec2:	4844      	ldr	r0, [pc, #272]	; (8005fd4 <main+0x8e4>)
 8005ec4:	f7fc f92a 	bl	800211c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, HIGH);
 8005ec8:	2201      	movs	r2, #1
 8005eca:	4842      	ldr	r0, [pc, #264]	; (8005fd4 <main+0x8e4>)
 8005ecc:	4611      	mov	r1, r2
	HAL_IWDG_Refresh(&hiwdg);	// refresh independed watchdog
 8005ece:	4d3e      	ldr	r5, [pc, #248]	; (8005fc8 <main+0x8d8>)
  HAL_GPIO_WritePin(GPIOF, LED_BLUE_Pin, HIGH);
 8005ed0:	f7fc f924 	bl	800211c <HAL_GPIO_WritePin>
 8005ed4:	e008      	b.n	8005ee8 <main+0x7f8>
	can_poll();					// poll for VCU CAN
 8005ed6:	f000 fca9 	bl	800682c <can_poll>
	update_temps();				// update IGBT and motor temp
 8005eda:	f003 fb91 	bl	8009600 <update_temps>
	HAL_IWDG_Refresh(&hiwdg);	// refresh independed watchdog
 8005ede:	4628      	mov	r0, r5
 8005ee0:	f7fc f94a 	bl	8002178 <HAL_IWDG_Refresh>
	update_Vdc(); 		    	// update Vdc
 8005ee4:	f003 fb28 	bl	8009538 <update_Vdc>
	start_Vdc_conversion(); 	// start Vdc conversion
 8005ee8:	f003 fb1e 	bl	8009528 <start_Vdc_conversion>
	check_enable_switch();		// update state
 8005eec:	f7fe ffaa 	bl	8004e44 <check_enable_switch>
	update_lvbatt_voltage();	// check for brown outs
 8005ef0:	f000 fc62 	bl	80067b8 <update_lvbatt_voltage>
	if (!mc_vars.mc_enable) {	// if not enabled, push log
 8005ef4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8005ef6:	2b00      	cmp	r3, #0
 8005ef8:	d1ed      	bne.n	8005ed6 <main+0x7e6>
		log_push(&mc_vars);
 8005efa:	4630      	mov	r0, r6
 8005efc:	f000 fcfe 	bl	80068fc <log_push>
 8005f00:	e7e9      	b.n	8005ed6 <main+0x7e6>
    Error_Handler();
 8005f02:	f7ff fbd5 	bl	80056b0 <Error_Handler>
 8005f06:	e7ca      	b.n	8005e9e <main+0x7ae>
    Error_Handler();
 8005f08:	f7ff fbd2 	bl	80056b0 <Error_Handler>
 8005f0c:	e7b5      	b.n	8005e7a <main+0x78a>
    Error_Handler();
 8005f0e:	f7ff fbcf 	bl	80056b0 <Error_Handler>
 8005f12:	e793      	b.n	8005e3c <main+0x74c>
    Error_Handler();
 8005f14:	f7ff fbcc 	bl	80056b0 <Error_Handler>
 8005f18:	e77a      	b.n	8005e10 <main+0x720>
    Error_Handler();
 8005f1a:	f7ff fbc9 	bl	80056b0 <Error_Handler>
 8005f1e:	e761      	b.n	8005de4 <main+0x6f4>
    Error_Handler();
 8005f20:	f7ff fbc6 	bl	80056b0 <Error_Handler>
 8005f24:	e751      	b.n	8005dca <main+0x6da>
    Error_Handler();
 8005f26:	f7ff fbc3 	bl	80056b0 <Error_Handler>
 8005f2a:	e6ff      	b.n	8005d2c <main+0x63c>
    Error_Handler();
 8005f2c:	f7ff fbc0 	bl	80056b0 <Error_Handler>
 8005f30:	e6ef      	b.n	8005d12 <main+0x622>
    Error_Handler();
 8005f32:	f7ff fbbd 	bl	80056b0 <Error_Handler>
 8005f36:	e6cd      	b.n	8005cd4 <main+0x5e4>
    Error_Handler();
 8005f38:	f7ff fbba 	bl	80056b0 <Error_Handler>
 8005f3c:	e6b0      	b.n	8005ca0 <main+0x5b0>
    Error_Handler();
 8005f3e:	f7ff fbb7 	bl	80056b0 <Error_Handler>
 8005f42:	e6a0      	b.n	8005c86 <main+0x596>
    Error_Handler();
 8005f44:	f7ff fbb4 	bl	80056b0 <Error_Handler>
 8005f48:	e679      	b.n	8005c3e <main+0x54e>
    Error_Handler();
 8005f4a:	f7ff fbb1 	bl	80056b0 <Error_Handler>
 8005f4e:	e66b      	b.n	8005c28 <main+0x538>
    Error_Handler();
 8005f50:	f7ff fbae 	bl	80056b0 <Error_Handler>
 8005f54:	e65e      	b.n	8005c14 <main+0x524>
    Error_Handler();
 8005f56:	f7ff fbab 	bl	80056b0 <Error_Handler>
 8005f5a:	e63f      	b.n	8005bdc <main+0x4ec>
    Error_Handler();
 8005f5c:	f7ff fba8 	bl	80056b0 <Error_Handler>
 8005f60:	e624      	b.n	8005bac <main+0x4bc>
    Error_Handler();
 8005f62:	f7ff fba5 	bl	80056b0 <Error_Handler>
 8005f66:	e617      	b.n	8005b98 <main+0x4a8>
    Error_Handler();
 8005f68:	f7ff fba2 	bl	80056b0 <Error_Handler>
 8005f6c:	e60c      	b.n	8005b88 <main+0x498>
    Error_Handler();
 8005f6e:	f7ff fb9f 	bl	80056b0 <Error_Handler>
 8005f72:	e5f8      	b.n	8005b66 <main+0x476>
    Error_Handler();
 8005f74:	f7ff fb9c 	bl	80056b0 <Error_Handler>
 8005f78:	e5ea      	b.n	8005b50 <main+0x460>
    Error_Handler();
 8005f7a:	f7ff fb99 	bl	80056b0 <Error_Handler>
 8005f7e:	e5e1      	b.n	8005b44 <main+0x454>
    Error_Handler();
 8005f80:	f7ff fb96 	bl	80056b0 <Error_Handler>
 8005f84:	e5d4      	b.n	8005b30 <main+0x440>
    Error_Handler();
 8005f86:	f7ff fb93 	bl	80056b0 <Error_Handler>
 8005f8a:	e596      	b.n	8005aba <main+0x3ca>
    Error_Handler();
 8005f8c:	f7ff fb90 	bl	80056b0 <Error_Handler>
 8005f90:	e57a      	b.n	8005a88 <main+0x398>
    Error_Handler();
 8005f92:	f7ff fb8d 	bl	80056b0 <Error_Handler>
 8005f96:	e55e      	b.n	8005a56 <main+0x366>
    Error_Handler();
 8005f98:	f7ff fb8a 	bl	80056b0 <Error_Handler>
 8005f9c:	e519      	b.n	80059d2 <main+0x2e2>
    Error_Handler();
 8005f9e:	f7ff fb87 	bl	80056b0 <Error_Handler>
 8005fa2:	e4ca      	b.n	800593a <main+0x24a>
 8005fa4:	0f000001 	.word	0x0f000001
 8005fa8:	20002630 	.word	0x20002630
 8005fac:	20002818 	.word	0x20002818
 8005fb0:	40004400 	.word	0x40004400
 8005fb4:	200028f8 	.word	0x200028f8
 8005fb8:	40006400 	.word	0x40006400
 8005fbc:	200024f8 	.word	0x200024f8
 8005fc0:	40015400 	.word	0x40015400
 8005fc4:	40003000 	.word	0x40003000
 8005fc8:	20002434 	.word	0x20002434
 8005fcc:	200021cc 	.word	0x200021cc
 8005fd0:	20002594 	.word	0x20002594
 8005fd4:	40021400 	.word	0x40021400

08005fd8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8005fd8:	4b0a      	ldr	r3, [pc, #40]	; (8006004 <HAL_MspInit+0x2c>)
{
 8005fda:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 8005fdc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005fde:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005fe2:	641a      	str	r2, [r3, #64]	; 0x40
 8005fe4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005fe6:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8005fea:	9200      	str	r2, [sp, #0]
 8005fec:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005fee:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005ff0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005ff4:	645a      	str	r2, [r3, #68]	; 0x44
 8005ff6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005ff8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8005ffc:	9301      	str	r3, [sp, #4]
 8005ffe:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8006000:	b002      	add	sp, #8
 8006002:	4770      	bx	lr
 8006004:	40023800 	.word	0x40023800

08006008 <HAL_ADC_MspInit>:
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hadc->Instance==ADC1)
 8006008:	4a63      	ldr	r2, [pc, #396]	; (8006198 <HAL_ADC_MspInit+0x190>)
 800600a:	6803      	ldr	r3, [r0, #0]
{
 800600c:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hadc->Instance==ADC1)
 800600e:	4293      	cmp	r3, r2
{
 8006010:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006012:	f04f 0400 	mov.w	r4, #0
{
 8006016:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006018:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
 800601c:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
 8006020:	940d      	str	r4, [sp, #52]	; 0x34
  if(hadc->Instance==ADC1)
 8006022:	d008      	beq.n	8006036 <HAL_ADC_MspInit+0x2e>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
  else if(hadc->Instance==ADC2)
 8006024:	4a5d      	ldr	r2, [pc, #372]	; (800619c <HAL_ADC_MspInit+0x194>)
 8006026:	4293      	cmp	r3, r2
 8006028:	d050      	beq.n	80060cc <HAL_ADC_MspInit+0xc4>

  /* USER CODE BEGIN ADC2_MspInit 1 */

  /* USER CODE END ADC2_MspInit 1 */
  }
  else if(hadc->Instance==ADC3)
 800602a:	4a5d      	ldr	r2, [pc, #372]	; (80061a0 <HAL_ADC_MspInit+0x198>)
 800602c:	4293      	cmp	r3, r2
 800602e:	f000 8096 	beq.w	800615e <HAL_ADC_MspInit+0x156>
  /* USER CODE BEGIN ADC3_MspInit 1 */

  /* USER CODE END ADC3_MspInit 1 */
  }

}
 8006032:	b00f      	add	sp, #60	; 0x3c
 8006034:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_ADC1_CLK_ENABLE();
 8006036:	4b5b      	ldr	r3, [pc, #364]	; (80061a4 <HAL_ADC_MspInit+0x19c>)
    GPIO_InitStruct.Pin = VLL_AB_Pin|MOTOR_TEMP_Pin|BATTERY_Pin|IGBT_TEMP_Pin;
 8006038:	20c9      	movs	r0, #201	; 0xc9
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800603a:	2703      	movs	r7, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800603c:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_ADC1_CLK_ENABLE();
 800603e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    hdma_adc1.Instance = DMA2_Stream0;
 8006040:	4e59      	ldr	r6, [pc, #356]	; (80061a8 <HAL_ADC_MspInit+0x1a0>)
    __HAL_RCC_ADC1_CLK_ENABLE();
 8006042:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006046:	645a      	str	r2, [r3, #68]	; 0x44
 8006048:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800604a:	f402 7280 	and.w	r2, r2, #256	; 0x100
 800604e:	9201      	str	r2, [sp, #4]
 8006050:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006052:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006054:	f042 0201 	orr.w	r2, r2, #1
 8006058:	631a      	str	r2, [r3, #48]	; 0x30
 800605a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800605c:	f002 0201 	and.w	r2, r2, #1
 8006060:	9202      	str	r2, [sp, #8]
 8006062:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006064:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006066:	f042 0204 	orr.w	r2, r2, #4
 800606a:	631a      	str	r2, [r3, #48]	; 0x30
 800606c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = VLL_AB_Pin|MOTOR_TEMP_Pin|BATTERY_Pin|IGBT_TEMP_Pin;
 800606e:	9009      	str	r0, [sp, #36]	; 0x24
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006070:	f003 0304 	and.w	r3, r3, #4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006074:	484d      	ldr	r0, [pc, #308]	; (80061ac <HAL_ADC_MspInit+0x1a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006076:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006078:	9303      	str	r3, [sp, #12]
 800607a:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800607c:	f7fb ff2a 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DC_CURRENT_Pin;
 8006080:	2320      	movs	r3, #32
    HAL_GPIO_Init(DC_CURRENT_GPIO_Port, &GPIO_InitStruct);
 8006082:	a909      	add	r1, sp, #36	; 0x24
 8006084:	484a      	ldr	r0, [pc, #296]	; (80061b0 <HAL_ADC_MspInit+0x1a8>)
    GPIO_InitStruct.Pin = DC_CURRENT_Pin;
 8006086:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006088:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(DC_CURRENT_GPIO_Port, &GPIO_InitStruct);
 800608c:	f7fb ff22 	bl	8001ed4 <HAL_GPIO_Init>
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8006090:	f44f 6780 	mov.w	r7, #1024	; 0x400
    hdma_adc1.Instance = DMA2_Stream0;
 8006094:	f8df c120 	ldr.w	ip, [pc, #288]	; 80061b8 <HAL_ADC_MspInit+0x1b0>
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8006098:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 800609c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 80060a0:	f44f 7380 	mov.w	r3, #256	; 0x100
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 80060a4:	4630      	mov	r0, r6
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
 80060a6:	6074      	str	r4, [r6, #4]
    hdma_adc1.Instance = DMA2_Stream0;
 80060a8:	f8c6 c000 	str.w	ip, [r6]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 80060ac:	e9c6 4402 	strd	r4, r4, [r6, #8]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80060b0:	e9c6 4408 	strd	r4, r4, [r6, #32]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80060b4:	e9c6 7104 	strd	r7, r1, [r6, #16]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 80060b8:	e9c6 2306 	strd	r2, r3, [r6, #24]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 80060bc:	f7fb fb2a 	bl	8001714 <HAL_DMA_Init>
 80060c0:	2800      	cmp	r0, #0
 80060c2:	d149      	bne.n	8006158 <HAL_ADC_MspInit+0x150>
    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc2);
 80060c4:	63ae      	str	r6, [r5, #56]	; 0x38
 80060c6:	63b5      	str	r5, [r6, #56]	; 0x38
}
 80060c8:	b00f      	add	sp, #60	; 0x3c
 80060ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_ADC2_CLK_ENABLE();
 80060cc:	4b35      	ldr	r3, [pc, #212]	; (80061a4 <HAL_ADC_MspInit+0x19c>)
    GPIO_InitStruct.Pin = VLL_AB_Pin|VLL_BC_Pin|MOTOR_TEMP_Pin|IGBT_TEMP_Pin;
 80060ce:	208b      	movs	r0, #139	; 0x8b
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80060d0:	2703      	movs	r7, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80060d2:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_ADC2_CLK_ENABLE();
 80060d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    hdma_adc2.Instance = DMA2_Stream2;
 80060d6:	4e37      	ldr	r6, [pc, #220]	; (80061b4 <HAL_ADC_MspInit+0x1ac>)
    __HAL_RCC_ADC2_CLK_ENABLE();
 80060d8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80060dc:	645a      	str	r2, [r3, #68]	; 0x44
 80060de:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80060e0:	f402 7200 	and.w	r2, r2, #512	; 0x200
 80060e4:	9204      	str	r2, [sp, #16]
 80060e6:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80060e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80060ea:	f042 0201 	orr.w	r2, r2, #1
 80060ee:	631a      	str	r2, [r3, #48]	; 0x30
 80060f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80060f2:	f002 0201 	and.w	r2, r2, #1
 80060f6:	9205      	str	r2, [sp, #20]
 80060f8:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80060fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80060fc:	f042 0204 	orr.w	r2, r2, #4
 8006100:	631a      	str	r2, [r3, #48]	; 0x30
 8006102:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = VLL_AB_Pin|VLL_BC_Pin|MOTOR_TEMP_Pin|IGBT_TEMP_Pin;
 8006104:	9009      	str	r0, [sp, #36]	; 0x24
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006106:	f003 0304 	and.w	r3, r3, #4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800610a:	4828      	ldr	r0, [pc, #160]	; (80061ac <HAL_ADC_MspInit+0x1a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800610c:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800610e:	9306      	str	r3, [sp, #24]
 8006110:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006112:	f7fb fedf 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DC_CURRENT_Pin;
 8006116:	2320      	movs	r3, #32
    HAL_GPIO_Init(DC_CURRENT_GPIO_Port, &GPIO_InitStruct);
 8006118:	a909      	add	r1, sp, #36	; 0x24
 800611a:	4825      	ldr	r0, [pc, #148]	; (80061b0 <HAL_ADC_MspInit+0x1a8>)
    GPIO_InitStruct.Pin = DC_CURRENT_Pin;
 800611c:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800611e:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(DC_CURRENT_GPIO_Port, &GPIO_InitStruct);
 8006122:	f7fb fed7 	bl	8001ed4 <HAL_GPIO_Init>
    hdma_adc2.Init.Channel = DMA_CHANNEL_1;
 8006126:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
    hdma_adc2.Instance = DMA2_Stream2;
 800612a:	f8df c090 	ldr.w	ip, [pc, #144]	; 80061bc <HAL_ADC_MspInit+0x1b4>
    hdma_adc2.Init.MemInc = DMA_MINC_ENABLE;
 800612e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hdma_adc2.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8006132:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    hdma_adc2.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8006136:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    if (HAL_DMA_Init(&hdma_adc2) != HAL_OK)
 800613a:	4630      	mov	r0, r6
    hdma_adc2.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800613c:	60b4      	str	r4, [r6, #8]
    hdma_adc2.Init.PeriphInc = DMA_PINC_DISABLE;
 800613e:	60f4      	str	r4, [r6, #12]
    hdma_adc2.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8006140:	6274      	str	r4, [r6, #36]	; 0x24
    hdma_adc2.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8006142:	61b3      	str	r3, [r6, #24]
    hdma_adc2.Init.Priority = DMA_PRIORITY_LOW;
 8006144:	e9c6 4407 	strd	r4, r4, [r6, #28]
    hdma_adc2.Init.Channel = DMA_CHANNEL_1;
 8006148:	e9c6 c700 	strd	ip, r7, [r6]
    hdma_adc2.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800614c:	e9c6 1204 	strd	r1, r2, [r6, #16]
    if (HAL_DMA_Init(&hdma_adc2) != HAL_OK)
 8006150:	f7fb fae0 	bl	8001714 <HAL_DMA_Init>
 8006154:	2800      	cmp	r0, #0
 8006156:	d0b5      	beq.n	80060c4 <HAL_ADC_MspInit+0xbc>
      Error_Handler();
 8006158:	f7ff faaa 	bl	80056b0 <Error_Handler>
 800615c:	e7b2      	b.n	80060c4 <HAL_ADC_MspInit+0xbc>
    __HAL_RCC_ADC3_CLK_ENABLE();
 800615e:	4b11      	ldr	r3, [pc, #68]	; (80061a4 <HAL_ADC_MspInit+0x19c>)
    GPIO_InitStruct.Pin = VLL_BC_Pin|MOTOR_TEMP_Pin;
 8006160:	250a      	movs	r5, #10
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006162:	2403      	movs	r4, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006164:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_ADC3_CLK_ENABLE();
 8006166:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006168:	4810      	ldr	r0, [pc, #64]	; (80061ac <HAL_ADC_MspInit+0x1a4>)
    __HAL_RCC_ADC3_CLK_ENABLE();
 800616a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800616e:	645a      	str	r2, [r3, #68]	; 0x44
 8006170:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006172:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8006176:	9207      	str	r2, [sp, #28]
 8006178:	9a07      	ldr	r2, [sp, #28]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800617a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800617c:	f042 0201 	orr.w	r2, r2, #1
 8006180:	631a      	str	r2, [r3, #48]	; 0x30
 8006182:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = VLL_BC_Pin|MOTOR_TEMP_Pin;
 8006184:	9509      	str	r5, [sp, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006186:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800618a:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800618c:	9308      	str	r3, [sp, #32]
 800618e:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006190:	f7fb fea0 	bl	8001ed4 <HAL_GPIO_Init>
}
 8006194:	b00f      	add	sp, #60	; 0x3c
 8006196:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006198:	40012000 	.word	0x40012000
 800619c:	40012100 	.word	0x40012100
 80061a0:	40012200 	.word	0x40012200
 80061a4:	40023800 	.word	0x40023800
 80061a8:	20002780 	.word	0x20002780
 80061ac:	40020000 	.word	0x40020000
 80061b0:	40020800 	.word	0x40020800
 80061b4:	20002898 	.word	0x20002898
 80061b8:	40026410 	.word	0x40026410
 80061bc:	40026440 	.word	0x40026440

080061c0 <HAL_CAN_MspInit>:
* @retval None
*/
void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcan->Instance==CAN1)
 80061c0:	6802      	ldr	r2, [r0, #0]
 80061c2:	4b21      	ldr	r3, [pc, #132]	; (8006248 <HAL_CAN_MspInit+0x88>)
{
 80061c4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hcan->Instance==CAN1)
 80061c6:	429a      	cmp	r2, r3
{
 80061c8:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80061ca:	f04f 0400 	mov.w	r4, #0
 80061ce:	e9cd 4403 	strd	r4, r4, [sp, #12]
 80061d2:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80061d6:	9407      	str	r4, [sp, #28]
  if(hcan->Instance==CAN1)
 80061d8:	d001      	beq.n	80061de <HAL_CAN_MspInit+0x1e>
  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }

}
 80061da:	b009      	add	sp, #36	; 0x24
 80061dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_CAN1_CLK_ENABLE();
 80061de:	f503 33ea 	add.w	r3, r3, #119808	; 0x1d400
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80061e2:	2701      	movs	r7, #1
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 80061e4:	f44f 6100 	mov.w	r1, #2048	; 0x800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80061e8:	2502      	movs	r5, #2
    __HAL_RCC_CAN1_CLK_ENABLE();
 80061ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 80061ec:	2609      	movs	r6, #9
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80061ee:	4817      	ldr	r0, [pc, #92]	; (800624c <HAL_CAN_MspInit+0x8c>)
    __HAL_RCC_CAN1_CLK_ENABLE();
 80061f0:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80061f4:	641a      	str	r2, [r3, #64]	; 0x40
 80061f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80061f8:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 80061fc:	9201      	str	r2, [sp, #4]
 80061fe:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006200:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006202:	433a      	orrs	r2, r7
 8006204:	631a      	str	r2, [r3, #48]	; 0x30
 8006206:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8006208:	9103      	str	r1, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800620a:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800620c:	403b      	ands	r3, r7
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800620e:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8006210:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006212:	9302      	str	r3, [sp, #8]
 8006214:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006216:	9705      	str	r7, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 8006218:	9607      	str	r6, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800621a:	f7fb fe5b 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 800621e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006222:	a903      	add	r1, sp, #12
 8006224:	4809      	ldr	r0, [pc, #36]	; (800624c <HAL_CAN_MspInit+0x8c>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 8006226:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006228:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800622a:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
 800622c:	e9cd 5606 	strd	r5, r6, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006230:	f7fb fe50 	bl	8001ed4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 0, 0);
 8006234:	4622      	mov	r2, r4
 8006236:	4621      	mov	r1, r4
 8006238:	2014      	movs	r0, #20
 800623a:	f7fb f829 	bl	8001290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
 800623e:	2014      	movs	r0, #20
 8006240:	f7fb f85c 	bl	80012fc <HAL_NVIC_EnableIRQ>
}
 8006244:	b009      	add	sp, #36	; 0x24
 8006246:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006248:	40006400 	.word	0x40006400
 800624c:	40020000 	.word	0x40020000

08006250 <HAL_DFSDM_FilterMspInit>:
 8006250:	4a27      	ldr	r2, [pc, #156]	; (80062f0 <HAL_DFSDM_FilterMspInit+0xa0>)
 8006252:	2300      	movs	r3, #0
 8006254:	b570      	push	{r4, r5, r6, lr}
 8006256:	6812      	ldr	r2, [r2, #0]
 8006258:	b088      	sub	sp, #32
 800625a:	e9cd 3303 	strd	r3, r3, [sp, #12]
 800625e:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8006262:	9307      	str	r3, [sp, #28]
 8006264:	2a00      	cmp	r2, #0
 8006266:	d136      	bne.n	80062d6 <HAL_DFSDM_FilterMspInit+0x86>
 8006268:	4a22      	ldr	r2, [pc, #136]	; (80062f4 <HAL_DFSDM_FilterMspInit+0xa4>)
 800626a:	6813      	ldr	r3, [r2, #0]
 800626c:	3301      	adds	r3, #1
 800626e:	2b01      	cmp	r3, #1
 8006270:	6013      	str	r3, [r2, #0]
 8006272:	d032      	beq.n	80062da <HAL_DFSDM_FilterMspInit+0x8a>
 8006274:	4b20      	ldr	r3, [pc, #128]	; (80062f8 <HAL_DFSDM_FilterMspInit+0xa8>)
 8006276:	2410      	movs	r4, #16
 8006278:	2502      	movs	r5, #2
 800627a:	260a      	movs	r6, #10
 800627c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800627e:	a903      	add	r1, sp, #12
 8006280:	481e      	ldr	r0, [pc, #120]	; (80062fc <HAL_DFSDM_FilterMspInit+0xac>)
 8006282:	4322      	orrs	r2, r4
 8006284:	631a      	str	r2, [r3, #48]	; 0x30
 8006286:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006288:	4022      	ands	r2, r4
 800628a:	9201      	str	r2, [sp, #4]
 800628c:	9a01      	ldr	r2, [sp, #4]
 800628e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006290:	f042 0204 	orr.w	r2, r2, #4
 8006294:	631a      	str	r2, [r3, #48]	; 0x30
 8006296:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006298:	9403      	str	r4, [sp, #12]
 800629a:	2400      	movs	r4, #0
 800629c:	f003 0304 	and.w	r3, r3, #4
 80062a0:	9504      	str	r5, [sp, #16]
 80062a2:	9607      	str	r6, [sp, #28]
 80062a4:	9300      	str	r3, [sp, #0]
 80062a6:	9b00      	ldr	r3, [sp, #0]
 80062a8:	f7fb fe14 	bl	8001ed4 <HAL_GPIO_Init>
 80062ac:	2306      	movs	r3, #6
 80062ae:	2205      	movs	r2, #5
 80062b0:	a903      	add	r1, sp, #12
 80062b2:	4813      	ldr	r0, [pc, #76]	; (8006300 <HAL_DFSDM_FilterMspInit+0xb0>)
 80062b4:	9307      	str	r3, [sp, #28]
 80062b6:	e9cd 2503 	strd	r2, r5, [sp, #12]
 80062ba:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80062be:	f7fb fe09 	bl	8001ed4 <HAL_GPIO_Init>
 80062c2:	2303      	movs	r3, #3
 80062c4:	a903      	add	r1, sp, #12
 80062c6:	480e      	ldr	r0, [pc, #56]	; (8006300 <HAL_DFSDM_FilterMspInit+0xb0>)
 80062c8:	9307      	str	r3, [sp, #28]
 80062ca:	e9cd 6503 	strd	r6, r5, [sp, #12]
 80062ce:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80062d2:	f7fb fdff 	bl	8001ed4 <HAL_GPIO_Init>
 80062d6:	b008      	add	sp, #32
 80062d8:	bd70      	pop	{r4, r5, r6, pc}
 80062da:	4b07      	ldr	r3, [pc, #28]	; (80062f8 <HAL_DFSDM_FilterMspInit+0xa8>)
 80062dc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80062de:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80062e2:	645a      	str	r2, [r3, #68]	; 0x44
 80062e4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80062e6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80062ea:	9302      	str	r3, [sp, #8]
 80062ec:	9b02      	ldr	r3, [sp, #8]
 80062ee:	e7c1      	b.n	8006274 <HAL_DFSDM_FilterMspInit+0x24>
 80062f0:	200020a8 	.word	0x200020a8
 80062f4:	200020ac 	.word	0x200020ac
 80062f8:	40023800 	.word	0x40023800
 80062fc:	40021000 	.word	0x40021000
 8006300:	40020800 	.word	0x40020800

08006304 <HAL_DFSDM_ChannelMspInit>:
* @retval None
*/
void HAL_DFSDM_ChannelMspInit(DFSDM_Channel_HandleTypeDef* hdfsdm_channel)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(DFSDM1_Init == 0)
 8006304:	4a27      	ldr	r2, [pc, #156]	; (80063a4 <HAL_DFSDM_ChannelMspInit+0xa0>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006306:	2300      	movs	r3, #0
{
 8006308:	b570      	push	{r4, r5, r6, lr}
  if(DFSDM1_Init == 0)
 800630a:	6812      	ldr	r2, [r2, #0]
{
 800630c:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800630e:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8006312:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8006316:	9307      	str	r3, [sp, #28]
  if(DFSDM1_Init == 0)
 8006318:	2a00      	cmp	r2, #0
 800631a:	d136      	bne.n	800638a <HAL_DFSDM_ChannelMspInit+0x86>
  {
  /* USER CODE BEGIN DFSDM1_MspInit 0 */

  /* USER CODE END DFSDM1_MspInit 0 */
    /* Peripheral clock enable */
    HAL_RCC_DFSDM1_CLK_ENABLED++;
 800631c:	4a22      	ldr	r2, [pc, #136]	; (80063a8 <HAL_DFSDM_ChannelMspInit+0xa4>)
 800631e:	6813      	ldr	r3, [r2, #0]
 8006320:	3301      	adds	r3, #1
    if(HAL_RCC_DFSDM1_CLK_ENABLED==1){
 8006322:	2b01      	cmp	r3, #1
    HAL_RCC_DFSDM1_CLK_ENABLED++;
 8006324:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_DFSDM1_CLK_ENABLED==1){
 8006326:	d032      	beq.n	800638e <HAL_DFSDM_ChannelMspInit+0x8a>
      __HAL_RCC_DFSDM1_CLK_ENABLE();
    }
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006328:	4b20      	ldr	r3, [pc, #128]	; (80063ac <HAL_DFSDM_ChannelMspInit+0xa8>)
    PC0     ------> DFSDM1_DATIN4
    PC1     ------> DFSDM1_DATIN0
    PC2     ------> DFSDM1_CKOUT
    PC3     ------> DFSDM1_DATIN1 
    */
    GPIO_InitStruct.Pin = DFSDM_VDC_Pin;
 800632a:	2410      	movs	r4, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800632c:	2502      	movs	r5, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_DFSDM1;
 800632e:	260a      	movs	r6, #10
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006330:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(DFSDM_VDC_GPIO_Port, &GPIO_InitStruct);
 8006332:	a903      	add	r1, sp, #12
 8006334:	481e      	ldr	r0, [pc, #120]	; (80063b0 <HAL_DFSDM_ChannelMspInit+0xac>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006336:	4322      	orrs	r2, r4
 8006338:	631a      	str	r2, [r3, #48]	; 0x30
 800633a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800633c:	4022      	ands	r2, r4
 800633e:	9201      	str	r2, [sp, #4]
 8006340:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006342:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006344:	f042 0204 	orr.w	r2, r2, #4
 8006348:	631a      	str	r2, [r3, #48]	; 0x30
 800634a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = DFSDM_VDC_Pin;
 800634c:	9403      	str	r4, [sp, #12]

    GPIO_InitStruct.Pin = DFSDM_IA_Pin|DFSDM_CLK_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800634e:	2400      	movs	r4, #0
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006350:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006354:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_DFSDM1;
 8006356:	9607      	str	r6, [sp, #28]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006358:	9302      	str	r3, [sp, #8]
 800635a:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(DFSDM_VDC_GPIO_Port, &GPIO_InitStruct);
 800635c:	f7fb fdba 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF6_DFSDM1;
 8006360:	2306      	movs	r3, #6
    GPIO_InitStruct.Pin = DFSDM_IA_Pin|DFSDM_CLK_Pin;
 8006362:	2205      	movs	r2, #5
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006364:	a903      	add	r1, sp, #12
 8006366:	4813      	ldr	r0, [pc, #76]	; (80063b4 <HAL_DFSDM_ChannelMspInit+0xb0>)
    GPIO_InitStruct.Alternate = GPIO_AF6_DFSDM1;
 8006368:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pin = DFSDM_IA_Pin|DFSDM_CLK_Pin;
 800636a:	e9cd 2503 	strd	r2, r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800636e:	e9cd 4405 	strd	r4, r4, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006372:	f7fb fdaf 	bl	8001ed4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = DFSDM_IB_Pin|DFSDM_IC_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF3_DFSDM1;
 8006376:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006378:	a903      	add	r1, sp, #12
 800637a:	480e      	ldr	r0, [pc, #56]	; (80063b4 <HAL_DFSDM_ChannelMspInit+0xb0>)
    GPIO_InitStruct.Alternate = GPIO_AF3_DFSDM1;
 800637c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800637e:	e9cd 6503 	strd	r6, r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8006382:	e9cd 4405 	strd	r4, r4, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006386:	f7fb fda5 	bl	8001ed4 <HAL_GPIO_Init>
  /* USER CODE BEGIN DFSDM1_MspInit 1 */

  /* USER CODE END DFSDM1_MspInit 1 */
  }

}
 800638a:	b008      	add	sp, #32
 800638c:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_RCC_DFSDM1_CLK_ENABLE();
 800638e:	4b07      	ldr	r3, [pc, #28]	; (80063ac <HAL_DFSDM_ChannelMspInit+0xa8>)
 8006390:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006392:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8006396:	645a      	str	r2, [r3, #68]	; 0x44
 8006398:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800639a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800639e:	9300      	str	r3, [sp, #0]
 80063a0:	9b00      	ldr	r3, [sp, #0]
 80063a2:	e7c1      	b.n	8006328 <HAL_DFSDM_ChannelMspInit+0x24>
 80063a4:	200020a8 	.word	0x200020a8
 80063a8:	200020ac 	.word	0x200020ac
 80063ac:	40023800 	.word	0x40023800
 80063b0:	40021000 	.word	0x40021000
 80063b4:	40020800 	.word	0x40020800

080063b8 <HAL_SPI_MspInit>:
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hspi->Instance==SPI2)
 80063b8:	4a55      	ldr	r2, [pc, #340]	; (8006510 <HAL_SPI_MspInit+0x158>)
 80063ba:	6803      	ldr	r3, [r0, #0]
{
 80063bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(hspi->Instance==SPI2)
 80063c0:	4293      	cmp	r3, r2
{
 80063c2:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80063c4:	f04f 0400 	mov.w	r4, #0
 80063c8:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80063cc:	e9cd 4407 	strd	r4, r4, [sp, #28]
 80063d0:	9409      	str	r4, [sp, #36]	; 0x24
  if(hspi->Instance==SPI2)
 80063d2:	d005      	beq.n	80063e0 <HAL_SPI_MspInit+0x28>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
  else if(hspi->Instance==SPI6)
 80063d4:	4a4f      	ldr	r2, [pc, #316]	; (8006514 <HAL_SPI_MspInit+0x15c>)
 80063d6:	4293      	cmp	r3, r2
 80063d8:	d058      	beq.n	800648c <HAL_SPI_MspInit+0xd4>
  /* USER CODE BEGIN SPI6_MspInit 1 */

  /* USER CODE END SPI6_MspInit 1 */
  }

}
 80063da:	b00b      	add	sp, #44	; 0x2c
 80063dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SPI2_CLK_ENABLE();
 80063e0:	4b4d      	ldr	r3, [pc, #308]	; (8006518 <HAL_SPI_MspInit+0x160>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80063e2:	2702      	movs	r7, #2
 80063e4:	4606      	mov	r6, r0
    GPIO_InitStruct.Pin = RDC_CLK_Pin|RDC_MISO_Pin;
 80063e6:	f44f 40c0 	mov.w	r0, #24576	; 0x6000
    __HAL_RCC_SPI2_CLK_ENABLE();
 80063ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80063ec:	f04f 0903 	mov.w	r9, #3
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80063f0:	f04f 0805 	mov.w	r8, #5
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80063f4:	a905      	add	r1, sp, #20
    __HAL_RCC_SPI2_CLK_ENABLE();
 80063f6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    hdma_spi2_rx.Instance = DMA1_Stream1;
 80063fa:	4d48      	ldr	r5, [pc, #288]	; (800651c <HAL_SPI_MspInit+0x164>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 80063fc:	641a      	str	r2, [r3, #64]	; 0x40
 80063fe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006400:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8006404:	9200      	str	r2, [sp, #0]
 8006406:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006408:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800640a:	433a      	orrs	r2, r7
 800640c:	631a      	str	r2, [r3, #48]	; 0x30
 800640e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = RDC_CLK_Pin|RDC_MISO_Pin;
 8006410:	9005      	str	r0, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006412:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006416:	403b      	ands	r3, r7
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006418:	9706      	str	r7, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800641a:	f500 30d2 	add.w	r0, r0, #107520	; 0x1a400
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800641e:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006422:	9301      	str	r3, [sp, #4]
 8006424:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006426:	e9cd 7907 	strd	r7, r9, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800642a:	f7fb fd53 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RDC_MOSI_Pin;
 800642e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    HAL_GPIO_Init(RDC_MOSI_GPIO_Port, &GPIO_InitStruct);
 8006432:	a905      	add	r1, sp, #20
 8006434:	483a      	ldr	r0, [pc, #232]	; (8006520 <HAL_SPI_MspInit+0x168>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006436:	9706      	str	r7, [sp, #24]
    GPIO_InitStruct.Pin = RDC_MOSI_Pin;
 8006438:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800643a:	9407      	str	r4, [sp, #28]
    hdma_spi2_rx.Instance = DMA1_Stream1;
 800643c:	4f39      	ldr	r7, [pc, #228]	; (8006524 <HAL_SPI_MspInit+0x16c>)
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800643e:	e9cd 9808 	strd	r9, r8, [sp, #32]
    HAL_GPIO_Init(RDC_MOSI_GPIO_Port, &GPIO_InitStruct);
 8006442:	f7fb fd47 	bl	8001ed4 <HAL_GPIO_Init>
    hdma_spi2_rx.Init.Channel = DMA_CHANNEL_9;
 8006446:	f04f 5190 	mov.w	r1, #301989888	; 0x12000000
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
 800644a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_spi2_rx.Init.Mode = DMA_CIRCULAR;
 800644e:	f44f 7380 	mov.w	r3, #256	; 0x100
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
 8006452:	4628      	mov	r0, r5
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
 8006454:	612a      	str	r2, [r5, #16]
    hdma_spi2_rx.Init.Mode = DMA_CIRCULAR;
 8006456:	61eb      	str	r3, [r5, #28]
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8006458:	e9c5 4402 	strd	r4, r4, [r5, #8]
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800645c:	e9c5 4405 	strd	r4, r4, [r5, #20]
    hdma_spi2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8006460:	e9c5 4408 	strd	r4, r4, [r5, #32]
    hdma_spi2_rx.Init.Channel = DMA_CHANNEL_9;
 8006464:	e9c5 7100 	strd	r7, r1, [r5]
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
 8006468:	f7fb f954 	bl	8001714 <HAL_DMA_Init>
 800646c:	b108      	cbz	r0, 8006472 <HAL_SPI_MspInit+0xba>
      Error_Handler();
 800646e:	f7ff f91f 	bl	80056b0 <Error_Handler>
    HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0);
 8006472:	2200      	movs	r2, #0
    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);
 8006474:	65b5      	str	r5, [r6, #88]	; 0x58
    HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0);
 8006476:	2024      	movs	r0, #36	; 0x24
    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);
 8006478:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0);
 800647a:	4611      	mov	r1, r2
 800647c:	f7fa ff08 	bl	8001290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8006480:	2024      	movs	r0, #36	; 0x24
 8006482:	f7fa ff3b 	bl	80012fc <HAL_NVIC_EnableIRQ>
}
 8006486:	b00b      	add	sp, #44	; 0x2c
 8006488:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SPI6_CLK_ENABLE();
 800648c:	4b22      	ldr	r3, [pc, #136]	; (8006518 <HAL_SPI_MspInit+0x160>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800648e:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = IABC_MISO_Pin;
 8006490:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006494:	2001      	movs	r0, #1
    __HAL_RCC_SPI6_CLK_ENABLE();
 8006496:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006498:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
 800649a:	2705      	movs	r7, #5
    __HAL_RCC_SPI6_CLK_ENABLE();
 800649c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80064a0:	645a      	str	r2, [r3, #68]	; 0x44
 80064a2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80064a4:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 80064a8:	9202      	str	r2, [sp, #8]
 80064aa:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 80064ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80064ae:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80064b2:	631a      	str	r2, [r3, #48]	; 0x30
 80064b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80064b6:	f002 0240 	and.w	r2, r2, #64	; 0x40
 80064ba:	9203      	str	r2, [sp, #12]
 80064bc:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80064be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80064c0:	432a      	orrs	r2, r5
 80064c2:	631a      	str	r2, [r3, #48]	; 0x30
 80064c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = IABC_MISO_Pin;
 80064c6:	9105      	str	r1, [sp, #20]
    HAL_GPIO_Init(IABC_MISO_GPIO_Port, &GPIO_InitStruct);
 80064c8:	a905      	add	r1, sp, #20
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80064ca:	402b      	ands	r3, r5
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80064cc:	e9cd 5006 	strd	r5, r0, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80064d0:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(IABC_MISO_GPIO_Port, &GPIO_InitStruct);
 80064d2:	4815      	ldr	r0, [pc, #84]	; (8006528 <HAL_SPI_MspInit+0x170>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80064d4:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
 80064d6:	e9cd 6708 	strd	r6, r7, [sp, #32]
    HAL_GPIO_Init(IABC_MISO_GPIO_Port, &GPIO_InitStruct);
 80064da:	f7fb fcfb 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = IABC_CLK_Pin;
 80064de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(IABC_CLK_GPIO_Port, &GPIO_InitStruct);
 80064e2:	a905      	add	r1, sp, #20
 80064e4:	4810      	ldr	r0, [pc, #64]	; (8006528 <HAL_SPI_MspInit+0x170>)
    GPIO_InitStruct.Pin = IABC_CLK_Pin;
 80064e6:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80064e8:	e9cd 5506 	strd	r5, r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
 80064ec:	e9cd 6708 	strd	r6, r7, [sp, #32]
    HAL_GPIO_Init(IABC_CLK_GPIO_Port, &GPIO_InitStruct);
 80064f0:	f7fb fcf0 	bl	8001ed4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 80064f4:	2220      	movs	r2, #32
    GPIO_InitStruct.Alternate = GPIO_AF8_SPI6;
 80064f6:	2308      	movs	r3, #8
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80064f8:	a905      	add	r1, sp, #20
 80064fa:	4809      	ldr	r0, [pc, #36]	; (8006520 <HAL_SPI_MspInit+0x168>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80064fc:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 80064fe:	9205      	str	r2, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF8_SPI6;
 8006500:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006502:	e9cd 4607 	strd	r4, r6, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006506:	f7fb fce5 	bl	8001ed4 <HAL_GPIO_Init>
}
 800650a:	b00b      	add	sp, #44	; 0x2c
 800650c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006510:	40003800 	.word	0x40003800
 8006514:	40015400 	.word	0x40015400
 8006518:	40023800 	.word	0x40023800
 800651c:	20002498 	.word	0x20002498
 8006520:	40020400 	.word	0x40020400
 8006524:	40026028 	.word	0x40026028
 8006528:	40021800 	.word	0x40021800

0800652c <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM1)
 800652c:	6803      	ldr	r3, [r0, #0]
 800652e:	4a1a      	ldr	r2, [pc, #104]	; (8006598 <HAL_TIM_Base_MspInit+0x6c>)
 8006530:	4293      	cmp	r3, r2
{
 8006532:	b510      	push	{r4, lr}
 8006534:	b082      	sub	sp, #8
  if(htim_base->Instance==TIM1)
 8006536:	d019      	beq.n	800656c <HAL_TIM_Base_MspInit+0x40>
    HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 8006538:	4a18      	ldr	r2, [pc, #96]	; (800659c <HAL_TIM_Base_MspInit+0x70>)
 800653a:	4293      	cmp	r3, r2
 800653c:	d001      	beq.n	8006542 <HAL_TIM_Base_MspInit+0x16>
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }

}
 800653e:	b002      	add	sp, #8
 8006540:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM3_CLK_ENABLE();
 8006542:	4b17      	ldr	r3, [pc, #92]	; (80065a0 <HAL_TIM_Base_MspInit+0x74>)
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
 8006544:	2200      	movs	r2, #0
 8006546:	201d      	movs	r0, #29
    __HAL_RCC_TIM3_CLK_ENABLE();
 8006548:	6c1c      	ldr	r4, [r3, #64]	; 0x40
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
 800654a:	4611      	mov	r1, r2
    __HAL_RCC_TIM3_CLK_ENABLE();
 800654c:	f044 0402 	orr.w	r4, r4, #2
 8006550:	641c      	str	r4, [r3, #64]	; 0x40
 8006552:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006554:	f003 0302 	and.w	r3, r3, #2
 8006558:	9301      	str	r3, [sp, #4]
 800655a:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
 800655c:	f7fa fe98 	bl	8001290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8006560:	201d      	movs	r0, #29
}
 8006562:	b002      	add	sp, #8
 8006564:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8006568:	f7fa bec8 	b.w	80012fc <HAL_NVIC_EnableIRQ>
    __HAL_RCC_TIM1_CLK_ENABLE();
 800656c:	4b0c      	ldr	r3, [pc, #48]	; (80065a0 <HAL_TIM_Base_MspInit+0x74>)
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 800656e:	2200      	movs	r2, #0
 8006570:	201b      	movs	r0, #27
    __HAL_RCC_TIM1_CLK_ENABLE();
 8006572:	6c5c      	ldr	r4, [r3, #68]	; 0x44
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 8006574:	4611      	mov	r1, r2
    __HAL_RCC_TIM1_CLK_ENABLE();
 8006576:	f044 0401 	orr.w	r4, r4, #1
 800657a:	645c      	str	r4, [r3, #68]	; 0x44
 800657c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800657e:	f003 0301 	and.w	r3, r3, #1
 8006582:	9300      	str	r3, [sp, #0]
 8006584:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 8006586:	f7fa fe83 	bl	8001290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
 800658a:	201b      	movs	r0, #27
}
 800658c:	b002      	add	sp, #8
 800658e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8006592:	f7fa beb3 	b.w	80012fc <HAL_NVIC_EnableIRQ>
 8006596:	bf00      	nop
 8006598:	40010000 	.word	0x40010000
 800659c:	40000400 	.word	0x40000400
 80065a0:	40023800 	.word	0x40023800

080065a4 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim->Instance==TIM1)
 80065a4:	6801      	ldr	r1, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80065a6:	2300      	movs	r3, #0
  if(htim->Instance==TIM1)
 80065a8:	4a11      	ldr	r2, [pc, #68]	; (80065f0 <HAL_TIM_MspPostInit+0x4c>)
{
 80065aa:	b570      	push	{r4, r5, r6, lr}
  if(htim->Instance==TIM1)
 80065ac:	4291      	cmp	r1, r2
{
 80065ae:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80065b0:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80065b4:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80065b8:	9305      	str	r3, [sp, #20]
  if(htim->Instance==TIM1)
 80065ba:	d001      	beq.n	80065c0 <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 80065bc:	b006      	add	sp, #24
 80065be:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80065c0:	4b0c      	ldr	r3, [pc, #48]	; (80065f4 <HAL_TIM_MspPostInit+0x50>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80065c2:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = NGATEA_Pin|GATEA_Pin|NGATEB_Pin|GATEB_Pin 
 80065c4:	f44f 567c 	mov.w	r6, #16128	; 0x3f00
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80065c8:	a901      	add	r1, sp, #4
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80065ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80065cc:	2501      	movs	r5, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80065ce:	480a      	ldr	r0, [pc, #40]	; (80065f8 <HAL_TIM_MspPostInit+0x54>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80065d0:	f042 0210 	orr.w	r2, r2, #16
 80065d4:	631a      	str	r2, [r3, #48]	; 0x30
 80065d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = NGATEA_Pin|GATEA_Pin|NGATEB_Pin|GATEB_Pin 
 80065d8:	9601      	str	r6, [sp, #4]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80065da:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80065de:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80065e0:	9404      	str	r4, [sp, #16]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80065e2:	9300      	str	r3, [sp, #0]
 80065e4:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80065e6:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80065e8:	f7fb fc74 	bl	8001ed4 <HAL_GPIO_Init>
}
 80065ec:	b006      	add	sp, #24
 80065ee:	bd70      	pop	{r4, r5, r6, pc}
 80065f0:	40010000 	.word	0x40010000
 80065f4:	40023800 	.word	0x40023800
 80065f8:	40021000 	.word	0x40021000

080065fc <HAL_UART_MspInit>:
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance==USART2)
 80065fc:	4b29      	ldr	r3, [pc, #164]	; (80066a4 <HAL_UART_MspInit+0xa8>)
 80065fe:	6802      	ldr	r2, [r0, #0]
{
 8006600:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(huart->Instance==USART2)
 8006602:	429a      	cmp	r2, r3
{
 8006604:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006606:	f04f 0400 	mov.w	r4, #0
 800660a:	e9cd 4403 	strd	r4, r4, [sp, #12]
 800660e:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8006612:	9407      	str	r4, [sp, #28]
  if(huart->Instance==USART2)
 8006614:	d001      	beq.n	800661a <HAL_UART_MspInit+0x1e>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8006616:	b009      	add	sp, #36	; 0x24
 8006618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_USART2_CLK_ENABLE();
 800661a:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800661e:	2502      	movs	r5, #2
 8006620:	4606      	mov	r6, r0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006622:	2003      	movs	r0, #3
    __HAL_RCC_USART2_CLK_ENABLE();
 8006624:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 8006626:	2760      	movs	r7, #96	; 0x60
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006628:	a903      	add	r1, sp, #12
    __HAL_RCC_USART2_CLK_ENABLE();
 800662a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800662e:	641a      	str	r2, [r3, #64]	; 0x40
 8006630:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006632:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8006636:	9201      	str	r2, [sp, #4]
 8006638:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800663a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800663c:	f042 0208 	orr.w	r2, r2, #8
 8006640:	631a      	str	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8006642:	2207      	movs	r2, #7
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006644:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006646:	9504      	str	r5, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006648:	f003 0308 	and.w	r3, r3, #8
    hdma_usart2_tx.Instance = DMA1_Stream6;
 800664c:	4d16      	ldr	r5, [pc, #88]	; (80066a8 <HAL_UART_MspInit+0xac>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800664e:	9006      	str	r0, [sp, #24]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006650:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006652:	4816      	ldr	r0, [pc, #88]	; (80066ac <HAL_UART_MspInit+0xb0>)
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 8006654:	9703      	str	r7, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006656:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8006658:	9207      	str	r2, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800665a:	f7fb fc3b 	bl	8001ed4 <HAL_GPIO_Init>
    hdma_usart2_tx.Instance = DMA1_Stream6;
 800665e:	4f14      	ldr	r7, [pc, #80]	; (80066b0 <HAL_UART_MspInit+0xb4>)
    hdma_usart2_tx.Init.Channel = DMA_CHANNEL_4;
 8006660:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006664:	2240      	movs	r2, #64	; 0x40
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006666:	f44f 6380 	mov.w	r3, #1024	; 0x400
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 800666a:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800666c:	60ec      	str	r4, [r5, #12]
    hdma_usart2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800666e:	626c      	str	r4, [r5, #36]	; 0x24
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006670:	60aa      	str	r2, [r5, #8]
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8006672:	612b      	str	r3, [r5, #16]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8006674:	e9c5 4405 	strd	r4, r4, [r5, #20]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8006678:	e9c5 4407 	strd	r4, r4, [r5, #28]
    hdma_usart2_tx.Init.Channel = DMA_CHANNEL_4;
 800667c:	e9c5 7100 	strd	r7, r1, [r5]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8006680:	f7fb f848 	bl	8001714 <HAL_DMA_Init>
 8006684:	b958      	cbnz	r0, 800669e <HAL_UART_MspInit+0xa2>
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 8006686:	2200      	movs	r2, #0
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8006688:	66b5      	str	r5, [r6, #104]	; 0x68
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 800668a:	2026      	movs	r0, #38	; 0x26
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 800668c:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 800668e:	4611      	mov	r1, r2
 8006690:	f7fa fdfe 	bl	8001290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8006694:	2026      	movs	r0, #38	; 0x26
 8006696:	f7fa fe31 	bl	80012fc <HAL_NVIC_EnableIRQ>
}
 800669a:	b009      	add	sp, #36	; 0x24
 800669c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
 800669e:	f7ff f807 	bl	80056b0 <Error_Handler>
 80066a2:	e7f0      	b.n	8006686 <HAL_UART_MspInit+0x8a>
 80066a4:	40004400 	.word	0x40004400
 80066a8:	20002678 	.word	0x20002678
 80066ac:	40020c00 	.word	0x40020c00
 80066b0:	400260a0 	.word	0x400260a0

080066b4 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 80066b4:	4770      	bx	lr
 80066b6:	bf00      	nop

080066b8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80066b8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN HardFault_IRQn 0 */
	Error_Handler();
 80066ba:	f7fe fff9 	bl	80056b0 <Error_Handler>
 80066be:	e7fe      	b.n	80066be <HardFault_Handler+0x6>

080066c0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80066c0:	e7fe      	b.n	80066c0 <MemManage_Handler>
 80066c2:	bf00      	nop

080066c4 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80066c4:	e7fe      	b.n	80066c4 <BusFault_Handler>
 80066c6:	bf00      	nop

080066c8 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80066c8:	e7fe      	b.n	80066c8 <UsageFault_Handler>
 80066ca:	bf00      	nop

080066cc <SVC_Handler>:
 80066cc:	4770      	bx	lr
 80066ce:	bf00      	nop

080066d0 <DebugMon_Handler>:
 80066d0:	4770      	bx	lr
 80066d2:	bf00      	nop

080066d4 <PendSV_Handler>:
 80066d4:	4770      	bx	lr
 80066d6:	bf00      	nop

080066d8 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80066d8:	f7f9 bf5e 	b.w	8000598 <HAL_IncTick>

080066dc <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
 80066dc:	4801      	ldr	r0, [pc, #4]	; (80066e4 <DMA1_Stream1_IRQHandler+0x8>)
 80066de:	f7fb b90f 	b.w	8001900 <HAL_DMA_IRQHandler>
 80066e2:	bf00      	nop
 80066e4:	20002498 	.word	0x20002498

080066e8 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream6_IRQn 0 */

  /* USER CODE END DMA1_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 80066e8:	4801      	ldr	r0, [pc, #4]	; (80066f0 <DMA1_Stream6_IRQHandler+0x8>)
 80066ea:	f7fb b909 	b.w	8001900 <HAL_DMA_IRQHandler>
 80066ee:	bf00      	nop
 80066f0:	20002678 	.word	0x20002678

080066f4 <CAN1_RX0_IRQHandler>:
void CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN CAN1_RX0_IRQn 0 */

  /* USER CODE END CAN1_RX0_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan1);
 80066f4:	4801      	ldr	r0, [pc, #4]	; (80066fc <CAN1_RX0_IRQHandler+0x8>)
 80066f6:	f7fa bc8f 	b.w	8001018 <HAL_CAN_IRQHandler>
 80066fa:	bf00      	nop
 80066fc:	200028f8 	.word	0x200028f8

08006700 <TIM1_CC_IRQHandler>:
void TIM1_CC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_CC_IRQn 0 */

  /* USER CODE END TIM1_CC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8006700:	4801      	ldr	r0, [pc, #4]	; (8006708 <TIM1_CC_IRQHandler+0x8>)
 8006702:	f7fd baf7 	b.w	8003cf4 <HAL_TIM_IRQHandler>
 8006706:	bf00      	nop
 8006708:	200022a0 	.word	0x200022a0

0800670c <TIM3_IRQHandler>:
void TIM3_IRQHandler(void)
{
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
 800670c:	4801      	ldr	r0, [pc, #4]	; (8006714 <TIM3_IRQHandler+0x8>)
 800670e:	f7fd baf1 	b.w	8003cf4 <HAL_TIM_IRQHandler>
 8006712:	bf00      	nop
 8006714:	20002260 	.word	0x20002260

08006718 <SPI2_IRQHandler>:
void SPI2_IRQHandler(void)
{
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 8006718:	4801      	ldr	r0, [pc, #4]	; (8006720 <SPI2_IRQHandler+0x8>)
 800671a:	f7fc be31 	b.w	8003380 <HAL_SPI_IRQHandler>
 800671e:	bf00      	nop
 8006720:	20002350 	.word	0x20002350

08006724 <USART2_IRQHandler>:
{
  /* USER CODE BEGIN USART2_IRQn 0 */


  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8006724:	4801      	ldr	r0, [pc, #4]	; (800672c <USART2_IRQHandler+0x8>)
 8006726:	f7fd be65 	b.w	80043f4 <HAL_UART_IRQHandler>
 800672a:	bf00      	nop
 800672c:	20002818 	.word	0x20002818

08006730 <DMA2_Stream0_IRQHandler>:
void DMA2_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 8006730:	4801      	ldr	r0, [pc, #4]	; (8006738 <DMA2_Stream0_IRQHandler+0x8>)
 8006732:	f7fb b8e5 	b.w	8001900 <HAL_DMA_IRQHandler>
 8006736:	bf00      	nop
 8006738:	20002780 	.word	0x20002780

0800673c <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc2);
 800673c:	4801      	ldr	r0, [pc, #4]	; (8006744 <DMA2_Stream2_IRQHandler+0x8>)
 800673e:	f7fb b8df 	b.w	8001900 <HAL_DMA_IRQHandler>
 8006742:	bf00      	nop
 8006744:	20002898 	.word	0x20002898

08006748 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006748:	4a0f      	ldr	r2, [pc, #60]	; (8006788 <SystemInit+0x40>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800674a:	4b10      	ldr	r3, [pc, #64]	; (800678c <SystemInit+0x44>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800674c:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006750:	490f      	ldr	r1, [pc, #60]	; (8006790 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006752:	f440 0070 	orr.w	r0, r0, #15728640	; 0xf00000
{
 8006756:	b470      	push	{r4, r5, r6}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006758:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
  RCC->CFGR = 0x00000000;
 800675c:	2400      	movs	r4, #0
  RCC->CR |= (uint32_t)0x00000001;
 800675e:	6818      	ldr	r0, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006760:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
  RCC->PLLCFGR = 0x24003010;
 8006764:	4e0b      	ldr	r6, [pc, #44]	; (8006794 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001;
 8006766:	f040 0001 	orr.w	r0, r0, #1
 800676a:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0x00000000;
 800676c:	609c      	str	r4, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800676e:	6818      	ldr	r0, [r3, #0]
 8006770:	4001      	ands	r1, r0
 8006772:	6019      	str	r1, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8006774:	605e      	str	r6, [r3, #4]
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8006776:	6819      	ldr	r1, [r3, #0]
 8006778:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800677c:	6019      	str	r1, [r3, #0]
  RCC->CIR = 0x00000000;
 800677e:	60dc      	str	r4, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006780:	6095      	str	r5, [r2, #8]
#endif
}
 8006782:	bc70      	pop	{r4, r5, r6}
 8006784:	4770      	bx	lr
 8006786:	bf00      	nop
 8006788:	e000ed00 	.word	0xe000ed00
 800678c:	40023800 	.word	0x40023800
 8006790:	fef6ffff 	.word	0xfef6ffff
 8006794:	24003010 	.word	0x24003010

08006798 <data_init>:
#include "modules/_data.h"

void data_init(CAN_HandleTypeDef *hcan, ADC_HandleTypeDef *hadc){
 8006798:	b510      	push	{r4, lr}
 800679a:	460c      	mov	r4, r1
    can_init(hcan);
 800679c:	f000 f82c 	bl	80067f8 <can_init>
    adc_init(hadc);
 80067a0:	4620      	mov	r0, r4
 80067a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    adc_init(hadc);
 80067a6:	f000 b801 	b.w	80067ac <adc_init>
 80067aa:	bf00      	nop

080067ac <adc_init>:
void handle_value(uint32_t value, adc_states_t state);
extern void Error_Handler(void);
static ADC_HandleTypeDef *_hadc;

void adc_init(ADC_HandleTypeDef *hadc){
    _hadc = hadc;
 80067ac:	4b01      	ldr	r3, [pc, #4]	; (80067b4 <adc_init+0x8>)
 80067ae:	6018      	str	r0, [r3, #0]
}
 80067b0:	4770      	bx	lr
 80067b2:	bf00      	nop
 80067b4:	200020b0 	.word	0x200020b0

080067b8 <update_lvbatt_voltage>:

void update_lvbatt_voltage(){
 80067b8:	b510      	push	{r4, lr}
    HAL_ADC_Start(_hadc);
 80067ba:	4c0d      	ldr	r4, [pc, #52]	; (80067f0 <update_lvbatt_voltage+0x38>)
 80067bc:	6820      	ldr	r0, [r4, #0]
 80067be:	f7f9 ffc5 	bl	800074c <HAL_ADC_Start>
    for(adc_states_t state = 0; state < TOTAL_STATES; state++){
        if( HAL_ADC_PollForConversion(_hadc, 100) == HAL_OK ){
 80067c2:	6820      	ldr	r0, [r4, #0]
 80067c4:	2164      	movs	r1, #100	; 0x64
 80067c6:	f7fa f84b 	bl	8000860 <HAL_ADC_PollForConversion>
 80067ca:	b930      	cbnz	r0, 80067da <update_lvbatt_voltage+0x22>
            handle_value( HAL_ADC_GetValue(_hadc), state );
 80067cc:	6820      	ldr	r0, [r4, #0]
 80067ce:	f7fa f899 	bl	8000904 <HAL_ADC_GetValue>
        else{
        	mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
            Error_Handler();
        }
    }
}
 80067d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void handle_value(uint32_t value, adc_states_t state){
    switch(state){
        case BATTERY:
            return update_battery_voltage(value);
 80067d6:	f002 beeb 	b.w	80095b0 <update_battery_voltage>
        	mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
 80067da:	4a06      	ldr	r2, [pc, #24]	; (80067f4 <update_lvbatt_voltage+0x3c>)
 80067dc:	f8b2 3070 	ldrh.w	r3, [r2, #112]	; 0x70
 80067e0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
}
 80067e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        	mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
 80067e8:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
            Error_Handler();
 80067ec:	f7fe bf60 	b.w	80056b0 <Error_Handler>
 80067f0:	200020b0 	.word	0x200020b0
 80067f4:	200021cc 	.word	0x200021cc

080067f8 <can_init>:
CAN_RxHeaderTypeDef *header;
uint8_t can_data[3];
uint8_t data_id;
CAN_FilterTypeDef sFilterConfig;

void can_init(CAN_HandleTypeDef *hcan){
 80067f8:	b538      	push	{r3, r4, r5, lr}
    _hcan = hcan;
    sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
 80067fa:	4b0a      	ldr	r3, [pc, #40]	; (8006824 <can_init+0x2c>)
 80067fc:	2200      	movs	r2, #0
    _hcan = hcan;
 80067fe:	4c0a      	ldr	r4, [pc, #40]	; (8006828 <can_init+0x30>)
    sFilterConfig.FilterIdHigh = 0;
    sFilterConfig.FilterIdLow = 0;
    sFilterConfig.FilterMaskIdHigh = 0;
    sFilterConfig.FilterMaskIdLow = 0;
    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 8006800:	2501      	movs	r5, #1
    sFilterConfig.FilterActivation = ENABLE;
    HAL_CAN_ConfigFilter(_hcan, &sFilterConfig);
 8006802:	4619      	mov	r1, r3
    sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
 8006804:	611a      	str	r2, [r3, #16]
    _hcan = hcan;
 8006806:	6020      	str	r0, [r4, #0]
    sFilterConfig.FilterIdLow = 0;
 8006808:	e9c3 2200 	strd	r2, r2, [r3]
    sFilterConfig.FilterMaskIdLow = 0;
 800680c:	e9c3 2202 	strd	r2, r2, [r3, #8]
    sFilterConfig.FilterActivation = ENABLE;
 8006810:	e9c3 5507 	strd	r5, r5, [r3, #28]
    HAL_CAN_ConfigFilter(_hcan, &sFilterConfig);
 8006814:	f7fa fa8c 	bl	8000d30 <HAL_CAN_ConfigFilter>
    HAL_CAN_Start(_hcan);
 8006818:	6820      	ldr	r0, [r4, #0]
    //To enable interrupt, uncomment the following. 
    //HAL_CAN_ActivateNotification(_hcan, CAN_IT_RX_FIFO0_MSG_PENDING);
}
 800681a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    HAL_CAN_Start(_hcan);
 800681e:	f7fa bb1f 	b.w	8000e60 <HAL_CAN_Start>
 8006822:	bf00      	nop
 8006824:	20002920 	.word	0x20002920
 8006828:	20002954 	.word	0x20002954

0800682c <can_poll>:

void can_poll(){
 800682c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t fifo = 0;
	uint32_t fill_level = HAL_CAN_GetRxFifoFillLevel(_hcan, fifo);
 8006830:	f8df 8074 	ldr.w	r8, [pc, #116]	; 80068a8 <can_poll+0x7c>
 8006834:	2100      	movs	r1, #0
 8006836:	f8d8 0000 	ldr.w	r0, [r8]
 800683a:	f7fa fbc1 	bl	8000fc0 <HAL_CAN_GetRxFifoFillLevel>
	uint16_t torque = 0;
	for(int i = 0; i < fill_level; i++){
 800683e:	b350      	cbz	r0, 8006896 <can_poll+0x6a>
 8006840:	4c16      	ldr	r4, [pc, #88]	; (800689c <can_poll+0x70>)
 8006842:	4607      	mov	r7, r0
 8006844:	2500      	movs	r5, #0
 8006846:	f8df b064 	ldr.w	fp, [pc, #100]	; 80068ac <can_poll+0x80>
		HAL_CAN_GetRxMessage(_hcan, fifo, header,can_data);
 800684a:	46a2      	mov	sl, r4
 800684c:	f8df 9060 	ldr.w	r9, [pc, #96]	; 80068b0 <can_poll+0x84>
 8006850:	4e13      	ldr	r6, [pc, #76]	; (80068a0 <can_poll+0x74>)
 8006852:	4653      	mov	r3, sl
 8006854:	f8db 2000 	ldr.w	r2, [fp]
 8006858:	2100      	movs	r1, #0
 800685a:	f8d8 0000 	ldr.w	r0, [r8]
 800685e:	f7fa fb2f 	bl	8000ec0 <HAL_CAN_GetRxMessage>
		data_id = can_data[0];
		torque = can_data[1] << 8 | (can_data[2]);
 8006862:	7860      	ldrb	r0, [r4, #1]
 8006864:	78a3      	ldrb	r3, [r4, #2]
		mc_vars.can_watchdog = 1;
 8006866:	2201      	movs	r2, #1
	for(int i = 0; i < fill_level; i++){
 8006868:	3501      	adds	r5, #1
		data_id = can_data[0];
 800686a:	7821      	ldrb	r1, [r4, #0]
		torque = can_data[1] << 8 | (can_data[2]);
 800686c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
		mc_vars.can_watchdog = 1;
 8006870:	f886 2064 	strb.w	r2, [r6, #100]	; 0x64
		mc_vars.TqRequest = (float)(torque*10/1454);
 8006874:	4a0b      	ldr	r2, [pc, #44]	; (80068a4 <can_poll+0x78>)
	for(int i = 0; i < fill_level; i++){
 8006876:	42bd      	cmp	r5, r7
		mc_vars.TqRequest = (float)(torque*10/1454);
 8006878:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		data_id = can_data[0];
 800687c:	f889 1000 	strb.w	r1, [r9]
		mc_vars.TqRequest = (float)(torque*10/1454);
 8006880:	fba2 2303 	umull	r2, r3, r2, r3
 8006884:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8006888:	ee07 3a90 	vmov	s15, r3
 800688c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006890:	edc6 7a0e 	vstr	s15, [r6, #56]	; 0x38
	for(int i = 0; i < fill_level; i++){
 8006894:	d1dd      	bne.n	8006852 <can_poll+0x26>
	}
}
 8006896:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800689a:	bf00      	nop
 800689c:	2000294c 	.word	0x2000294c
 80068a0:	200021cc 	.word	0x200021cc
 80068a4:	5a255375 	.word	0x5a255375
 80068a8:	20002954 	.word	0x20002954
 80068ac:	20002950 	.word	0x20002950
 80068b0:	20002948 	.word	0x20002948

080068b4 <do_nothing>:
    frequency = f;
}

void do_nothing(){
    return;
}
 80068b4:	4770      	bx	lr
 80068b6:	bf00      	nop

080068b8 <log_init>:
void log_init(){
 80068b8:	b430      	push	{r4, r5}
    w_ptr = 0;
 80068ba:	2300      	movs	r3, #0
 80068bc:	4c08      	ldr	r4, [pc, #32]	; (80068e0 <log_init+0x28>)
    r_ptr = 0;
 80068be:	4809      	ldr	r0, [pc, #36]	; (80068e4 <log_init+0x2c>)
    live_log_enable = true;
 80068c0:	2101      	movs	r1, #1
    count = 0;
 80068c2:	4a09      	ldr	r2, [pc, #36]	; (80068e8 <log_init+0x30>)
    cease_log = false;
 80068c4:	4d09      	ldr	r5, [pc, #36]	; (80068ec <log_init+0x34>)
    w_ptr = 0;
 80068c6:	8023      	strh	r3, [r4, #0]
    r_ptr = 0;
 80068c8:	8003      	strh	r3, [r0, #0]
    triggered_count = 0;
 80068ca:	4c09      	ldr	r4, [pc, #36]	; (80068f0 <log_init+0x38>)
    count = 0;
 80068cc:	8013      	strh	r3, [r2, #0]
    triggered = false;
 80068ce:	4809      	ldr	r0, [pc, #36]	; (80068f4 <log_init+0x3c>)
    live_log_enable = true;
 80068d0:	4a09      	ldr	r2, [pc, #36]	; (80068f8 <log_init+0x40>)
    cease_log = false;
 80068d2:	702b      	strb	r3, [r5, #0]
    triggered_count = 0;
 80068d4:	8023      	strh	r3, [r4, #0]
    triggered = false;
 80068d6:	7003      	strb	r3, [r0, #0]
    live_log_enable = true;
 80068d8:	7011      	strb	r1, [r2, #0]
}
 80068da:	bc30      	pop	{r4, r5}
 80068dc:	4770      	bx	lr
 80068de:	bf00      	nop
 80068e0:	2000c796 	.word	0x2000c796
 80068e4:	2000c79c 	.word	0x2000c79c
 80068e8:	20069402 	.word	0x20069402
 80068ec:	20069400 	.word	0x20069400
 80068f0:	2000c798 	.word	0x2000c798
 80068f4:	20069401 	.word	0x20069401
 80068f8:	2000c79e 	.word	0x2000c79e

080068fc <log_push>:
void log_push(MotorController_Variables* data){
 80068fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(cease_log){
 80068fe:	4b87      	ldr	r3, [pc, #540]	; (8006b1c <log_push+0x220>)
 8006900:	781b      	ldrb	r3, [r3, #0]
 8006902:	2b00      	cmp	r3, #0
 8006904:	d15c      	bne.n	80069c0 <log_push+0xc4>
    high_freq_log_t *log_ptr = triggered_count >= LOG_SIZE_HALF ? &temp_buf : &data_log[w_ptr];
 8006906:	4a86      	ldr	r2, [pc, #536]	; (8006b20 <log_push+0x224>)
 8006908:	f640 11c3 	movw	r1, #2499	; 0x9c3
 800690c:	8813      	ldrh	r3, [r2, #0]
 800690e:	428b      	cmp	r3, r1
 8006910:	d957      	bls.n	80069c2 <log_push+0xc6>
 8006912:	4c84      	ldr	r4, [pc, #528]	; (8006b24 <log_push+0x228>)
    log_ptr->id_ref = (float)data->idq_ref[0];
 8006914:	6806      	ldr	r6, [r0, #0]
    log_ptr->iq_ref = (float)data->idq_ref[1];
 8006916:	6845      	ldr	r5, [r0, #4]
    log_ptr->id = (float)data->idq[0];
 8006918:	6a81      	ldr	r1, [r0, #40]	; 0x28
    log_ptr->iq = (float)data->idq[1];
 800691a:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
    log_ptr->TqRequest = (float)data->TqRequest;
 800691c:	edd0 7a0e 	vldr	s15, [r0, #56]	; 0x38
    log_ptr->rpm = (float)data->rpm;
 8006920:	ed90 7a10 	vldr	s14, [r0, #64]	; 0x40
    log_ptr->id_ref = (float)data->idq_ref[0];
 8006924:	6026      	str	r6, [r4, #0]
    log_ptr->Vdc = (float)data->Vdc;
 8006926:	69c6      	ldr	r6, [r0, #28]
    log_ptr->iq_ref = (float)data->idq_ref[1];
 8006928:	6065      	str	r5, [r4, #4]
    log_ptr->vd_ref = (float)data->vdq_ref[0];
 800692a:	6a05      	ldr	r5, [r0, #32]
    log_ptr->id = (float)data->idq[0];
 800692c:	60a1      	str	r1, [r4, #8]
    log_ptr->vq_ref = (float)data->vdq_ref[1];
 800692e:	6a41      	ldr	r1, [r0, #36]	; 0x24
    log_ptr->iq = (float)data->idq[1];
 8006930:	60e7      	str	r7, [r4, #12]
    log_ptr->TqRef = (float)data->TqRef;
 8006932:	6b07      	ldr	r7, [r0, #48]	; 0x30
    log_ptr->Vdc = (float)data->Vdc;
 8006934:	6126      	str	r6, [r4, #16]
    log_ptr->TqLim = (float)data->TqLim;
 8006936:	6b46      	ldr	r6, [r0, #52]	; 0x34
    log_ptr->vd_ref = (float)data->vdq_ref[0];
 8006938:	6165      	str	r5, [r4, #20]
    log_ptr->motorTemp = (float)data->motorTemp;
 800693a:	6c45      	ldr	r5, [r0, #68]	; 0x44
    log_ptr->vq_ref = (float)data->vdq_ref[1];
 800693c:	61a1      	str	r1, [r4, #24]
    log_ptr->igbtTemp = (float)data->igbtTemp;
 800693e:	6c81      	ldr	r1, [r0, #72]	; 0x48
    log_ptr->TqRef = (float)data->TqRef;
 8006940:	61e7      	str	r7, [r4, #28]
    log_ptr->power = (float)data->power_out;
 8006942:	6e87      	ldr	r7, [r0, #104]	; 0x68
    log_ptr->TqLim = (float)data->TqLim;
 8006944:	6226      	str	r6, [r4, #32]
    log_ptr->faults=(uint32_t)data->fault_reg1;
 8006946:	f8b0 6070 	ldrh.w	r6, [r0, #112]	; 0x70
    log_ptr->motorTemp = (float)data->motorTemp;
 800694a:	62e5      	str	r5, [r4, #44]	; 0x2c
    log_ptr->ia = (float)data->iabc[0];
 800694c:	68c5      	ldr	r5, [r0, #12]
    log_ptr->igbtTemp = (float)data->igbtTemp;
 800694e:	6321      	str	r1, [r4, #48]	; 0x30
    if(triggered){
 8006950:	4975      	ldr	r1, [pc, #468]	; (8006b28 <log_push+0x22c>)
    log_ptr->faults=(uint32_t)data->fault_reg1;
 8006952:	63a6      	str	r6, [r4, #56]	; 0x38
    log_ptr->ia = (float)data->iabc[0];
 8006954:	63e5      	str	r5, [r4, #60]	; 0x3c
    log_ptr->TqRequest = (float)data->TqRequest;
 8006956:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    log_ptr->rpm = (float)data->rpm;
 800695a:	ed84 7a0a 	vstr	s14, [r4, #40]	; 0x28
    log_ptr->power = (float)data->power_out;
 800695e:	6367      	str	r7, [r4, #52]	; 0x34
    log_ptr->ib = (float)data->iabc[1];
 8006960:	6907      	ldr	r7, [r0, #16]
    log_ptr->ic = (float)data->iabc[2];
 8006962:	6946      	ldr	r6, [r0, #20]
    if(triggered){
 8006964:	780d      	ldrb	r5, [r1, #0]
    log_ptr->theta = (float)data->theta_e;
 8006966:	6980      	ldr	r0, [r0, #24]
    log_ptr->ib = (float)data->iabc[1];
 8006968:	6427      	str	r7, [r4, #64]	; 0x40
    log_ptr->ic = (float)data->iabc[2];
 800696a:	6466      	str	r6, [r4, #68]	; 0x44
    log_ptr->theta = (float)data->theta_e;
 800696c:	64a0      	str	r0, [r4, #72]	; 0x48
    if(triggered){
 800696e:	2d00      	cmp	r5, #0
 8006970:	d02e      	beq.n	80069d0 <log_push+0xd4>
        triggered_count++;
 8006972:	3301      	adds	r3, #1
 8006974:	b29b      	uxth	r3, r3
 8006976:	8013      	strh	r3, [r2, #0]
    if(!(triggered_count >= LOG_SIZE_HALF)){
 8006978:	f640 12c3 	movw	r2, #2499	; 0x9c3
 800697c:	4293      	cmp	r3, r2
 800697e:	d81c      	bhi.n	80069ba <log_push+0xbe>
 8006980:	486a      	ldr	r0, [pc, #424]	; (8006b2c <log_push+0x230>)
 8006982:	f241 3188 	movw	r1, #5000	; 0x1388
 8006986:	4b6a      	ldr	r3, [pc, #424]	; (8006b30 <log_push+0x234>)
 8006988:	8807      	ldrh	r7, [r0, #0]
        count = (count == LOG_SIZE) ? LOG_SIZE : count+1;
 800698a:	4e6a      	ldr	r6, [pc, #424]	; (8006b34 <log_push+0x238>)
 800698c:	f107 0e01 	add.w	lr, r7, #1
 8006990:	4d69      	ldr	r5, [pc, #420]	; (8006b38 <log_push+0x23c>)
 8006992:	8832      	ldrh	r2, [r6, #0]
 8006994:	fba3 c30e 	umull	ip, r3, r3, lr
 8006998:	f8b5 c000 	ldrh.w	ip, [r5]
 800699c:	428a      	cmp	r2, r1
 800699e:	ea4f 3313 	mov.w	r3, r3, lsr #12
 80069a2:	fb01 e313 	mls	r3, r1, r3, lr
 80069a6:	b29b      	uxth	r3, r3
 80069a8:	d06e      	beq.n	8006a88 <log_push+0x18c>
 80069aa:	3201      	adds	r2, #1
 80069ac:	b292      	uxth	r2, r2
        r_ptr = (count == LOG_SIZE && w_ptr == r_ptr) ? ((r_ptr + 1) % LOG_SIZE) : r_ptr;
 80069ae:	428a      	cmp	r2, r1
        count = (count == LOG_SIZE) ? LOG_SIZE : count+1;
 80069b0:	8032      	strh	r2, [r6, #0]
        r_ptr = (count == LOG_SIZE && w_ptr == r_ptr) ? ((r_ptr + 1) % LOG_SIZE) : r_ptr;
 80069b2:	d069      	beq.n	8006a88 <log_push+0x18c>
 80069b4:	f8a5 c000 	strh.w	ip, [r5]
        w_ptr = (w_ptr + 1) % LOG_SIZE;
 80069b8:	8003      	strh	r3, [r0, #0]
    if(live_log_enable && getUARTState() == HAL_UART_STATE_READY){
 80069ba:	4b60      	ldr	r3, [pc, #384]	; (8006b3c <log_push+0x240>)
 80069bc:	781b      	ldrb	r3, [r3, #0]
 80069be:	b9a3      	cbnz	r3, 80069ea <log_push+0xee>
}
 80069c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    high_freq_log_t *log_ptr = triggered_count >= LOG_SIZE_HALF ? &temp_buf : &data_log[w_ptr];
 80069c2:	4c5a      	ldr	r4, [pc, #360]	; (8006b2c <log_push+0x230>)
 80069c4:	254c      	movs	r5, #76	; 0x4c
 80069c6:	495e      	ldr	r1, [pc, #376]	; (8006b40 <log_push+0x244>)
 80069c8:	8824      	ldrh	r4, [r4, #0]
 80069ca:	fb05 1404 	mla	r4, r5, r4, r1
 80069ce:	e7a1      	b.n	8006914 <log_push+0x18>
    else if(data->TqRequest > mc_params.Tq_trigger || data->rpm > mc_params.rpm_trigger){
 80069d0:	4a5c      	ldr	r2, [pc, #368]	; (8006b44 <log_push+0x248>)
 80069d2:	edd2 6a1c 	vldr	s13, [r2, #112]	; 0x70
 80069d6:	eef8 6a66 	vcvt.f32.u32	s13, s13
 80069da:	eef4 7ae6 	vcmpe.f32	s15, s13
 80069de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80069e2:	dd46      	ble.n	8006a72 <log_push+0x176>
        triggered = true;
 80069e4:	2201      	movs	r2, #1
 80069e6:	700a      	strb	r2, [r1, #0]
 80069e8:	e7c6      	b.n	8006978 <log_push+0x7c>
    if(live_log_enable && getUARTState() == HAL_UART_STATE_READY){
 80069ea:	f000 f969 	bl	8006cc0 <getUARTState>
 80069ee:	2820      	cmp	r0, #32
 80069f0:	d1e6      	bne.n	80069c0 <log_push+0xc4>
        switch(frequency){
 80069f2:	4b55      	ldr	r3, [pc, #340]	; (8006b48 <log_push+0x24c>)
 80069f4:	781b      	ldrb	r3, [r3, #0]
 80069f6:	2b00      	cmp	r3, #0
 80069f8:	d04a      	beq.n	8006a90 <log_push+0x194>
 80069fa:	2b01      	cmp	r3, #1
 80069fc:	d177      	bne.n	8006aee <log_push+0x1f2>
    live_data_log[ll_w_ptr++] = 0x11;
 80069fe:	4e53      	ldr	r6, [pc, #332]	; (8006b4c <log_push+0x250>)
    memcpy(&live_data_log[ll_w_ptr], data, sizeof(high_freq_log_t));
 8006a00:	4621      	mov	r1, r4
    live_data_log[ll_w_ptr++] = 0x11;
 8006a02:	4d53      	ldr	r5, [pc, #332]	; (8006b50 <log_push+0x254>)
 8006a04:	2311      	movs	r3, #17
 8006a06:	8834      	ldrh	r4, [r6, #0]
    memcpy(&live_data_log[ll_w_ptr], data, sizeof(high_freq_log_t));
 8006a08:	224c      	movs	r2, #76	; 0x4c
    live_data_log[ll_w_ptr++] = 0x11;
 8006a0a:	1c60      	adds	r0, r4, #1
 8006a0c:	552b      	strb	r3, [r5, r4]
    ll_w_ptr = ll_w_ptr + sizeof(high_freq_log_t);
 8006a0e:	f104 074d 	add.w	r7, r4, #77	; 0x4d
    memcpy(&live_data_log[ll_w_ptr], data, sizeof(high_freq_log_t));
 8006a12:	fa15 f080 	uxtah	r0, r5, r0
 8006a16:	f002 ff73 	bl	8009900 <memcpy>
    live_data_log[ll_w_ptr++] = 0x21;
 8006a1a:	f104 004e 	add.w	r0, r4, #78	; 0x4e
 8006a1e:	2321      	movs	r3, #33	; 0x21
    live_data_log[ll_w_ptr++] = 0x21;
 8006a20:	f104 014f 	add.w	r1, r4, #79	; 0x4f
    live_data_log[ll_w_ptr++] = 0x21;
 8006a24:	f104 0250 	add.w	r2, r4, #80	; 0x50
    live_data_log[ll_w_ptr++] = 0x21;
 8006a28:	b280      	uxth	r0, r0
    live_data_log[ll_w_ptr++] = 0x21;
 8006a2a:	3451      	adds	r4, #81	; 0x51
    live_data_log[ll_w_ptr++] = 0x21;
 8006a2c:	b2bf      	uxth	r7, r7
    live_data_log[ll_w_ptr++] = 0x21;
 8006a2e:	b289      	uxth	r1, r1
    live_data_log[ll_w_ptr++] = 0x21;
 8006a30:	55eb      	strb	r3, [r5, r7]
    live_data_log[ll_w_ptr++] = 0x21;
 8006a32:	b2a4      	uxth	r4, r4
    live_data_log[ll_w_ptr++] = 0x21;
 8006a34:	542b      	strb	r3, [r5, r0]
    if(ll_w_ptr == LIVE_LOG_DMA_LENGTH_HIGH_FREQ - 10){
 8006a36:	f649 6034 	movw	r0, #40500	; 0x9e34
    live_data_log[ll_w_ptr++] = 0x21;
 8006a3a:	b292      	uxth	r2, r2
    live_data_log[ll_w_ptr++] = 0x21;
 8006a3c:	546b      	strb	r3, [r5, r1]
    if(ll_w_ptr == LIVE_LOG_DMA_LENGTH_HIGH_FREQ - 10){
 8006a3e:	4284      	cmp	r4, r0
    live_data_log[ll_w_ptr++] = 0x21;
 8006a40:	8034      	strh	r4, [r6, #0]
 8006a42:	54ab      	strb	r3, [r5, r2]
    if(ll_w_ptr == LIVE_LOG_DMA_LENGTH_HIGH_FREQ - 10){
 8006a44:	d1bc      	bne.n	80069c0 <log_push+0xc4>
        live_data_log[ll_w_ptr++] = 0x4C;
 8006a46:	4943      	ldr	r1, [pc, #268]	; (8006b54 <log_push+0x258>)
 8006a48:	f649 6238 	movw	r2, #40504	; 0x9e38
 8006a4c:	4842      	ldr	r0, [pc, #264]	; (8006b58 <log_push+0x25c>)
 8006a4e:	5129      	str	r1, [r5, r4]
        live_data_log[ll_w_ptr++] = 0x21;
 8006a50:	f649 613c 	movw	r1, #40508	; 0x9e3c
        live_data_log[ll_w_ptr++] = 0x4C;
 8006a54:	50a8      	str	r0, [r5, r2]
        ll_w_ptr = 0;
 8006a56:	2400      	movs	r4, #0
        live_data_log[ll_w_ptr++] = 0x21;
 8006a58:	f649 623d 	movw	r2, #40509	; 0x9e3d
        live_data_log[ll_w_ptr++] = 0x21;
 8006a5c:	546b      	strb	r3, [r5, r1]
        send_message_DMA(live_data_log, LIVE_LOG_DMA_LENGTH_HIGH_FREQ, do_nothing);
 8006a5e:	4628      	mov	r0, r5
        ll_w_ptr = 0;
 8006a60:	8034      	strh	r4, [r6, #0]
        live_data_log[ll_w_ptr++] = 0x21;
 8006a62:	54ab      	strb	r3, [r5, r2]
        send_message_DMA(live_data_log, LIVE_LOG_DMA_LENGTH_HIGH_FREQ, do_nothing);
 8006a64:	f649 613e 	movw	r1, #40510	; 0x9e3e
 8006a68:	4a3c      	ldr	r2, [pc, #240]	; (8006b5c <log_push+0x260>)
}
 8006a6a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        send_message_DMA(live_data_log, LIVE_LOG_DMA_LENGTH_HIGH_FREQ, do_nothing);
 8006a6e:	f000 b90f 	b.w	8006c90 <send_message_DMA>
    else if(data->TqRequest > mc_params.Tq_trigger || data->rpm > mc_params.rpm_trigger){
 8006a72:	edd2 7a1d 	vldr	s15, [r2, #116]	; 0x74
 8006a76:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006a7a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8006a7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006a82:	f77f af79 	ble.w	8006978 <log_push+0x7c>
 8006a86:	e7ad      	b.n	80069e4 <log_push+0xe8>
        r_ptr = (count == LOG_SIZE && w_ptr == r_ptr) ? ((r_ptr + 1) % LOG_SIZE) : r_ptr;
 8006a88:	4567      	cmp	r7, ip
 8006a8a:	bf08      	it	eq
 8006a8c:	469c      	moveq	ip, r3
 8006a8e:	e791      	b.n	80069b4 <log_push+0xb8>
    live_data[ptr++] = 0x11;
 8006a90:	4f33      	ldr	r7, [pc, #204]	; (8006b60 <log_push+0x264>)
 8006a92:	2311      	movs	r3, #17
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006a94:	f104 0c30 	add.w	ip, r4, #48	; 0x30
    live_data[ptr++] = 0x11;
 8006a98:	463d      	mov	r5, r7
 8006a9a:	f805 3b01 	strb.w	r3, [r5], #1
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006a9e:	4626      	mov	r6, r4
 8006aa0:	3510      	adds	r5, #16
 8006aa2:	3410      	adds	r4, #16
 8006aa4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006aa6:	4566      	cmp	r6, ip
 8006aa8:	f845 0c10 	str.w	r0, [r5, #-16]
 8006aac:	f845 1c0c 	str.w	r1, [r5, #-12]
 8006ab0:	f845 2c08 	str.w	r2, [r5, #-8]
 8006ab4:	f845 3c04 	str.w	r3, [r5, #-4]
 8006ab8:	d1f1      	bne.n	8006a9e <log_push+0x1a2>
    live_data[ptr++] = 0x21;
 8006aba:	2321      	movs	r3, #33	; 0x21
    live_data[ptr++] = 0x21;
 8006abc:	f04f 3621 	mov.w	r6, #555819297	; 0x21212121
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006ac0:	cc07      	ldmia	r4!, {r0, r1, r2}
    live_data[ptr++] = 0x21;
 8006ac2:	4c25      	ldr	r4, [pc, #148]	; (8006b58 <log_push+0x25c>)
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006ac4:	6028      	str	r0, [r5, #0]
    live_data[ptr++] = 0x21;
 8006ac6:	4823      	ldr	r0, [pc, #140]	; (8006b54 <log_push+0x258>)
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006ac8:	6069      	str	r1, [r5, #4]
    send_message_DMA(live_data, LIVE_LOG_DMA_LENGTH_LOW_FREQ, do_nothing);
 8006aca:	214b      	movs	r1, #75	; 0x4b
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006acc:	60aa      	str	r2, [r5, #8]
    live_data[ptr++] = 0x21;
 8006ace:	f8c7 0041 	str.w	r0, [r7, #65]	; 0x41
 8006ad2:	f8c7 603d 	str.w	r6, [r7, #61]	; 0x3d
 8006ad6:	f8c7 4045 	str.w	r4, [r7, #69]	; 0x45
    live_data[ptr++] = 0x21;
 8006ada:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49
    live_data[ptr++] = 0x21;
 8006ade:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
    send_message_DMA(live_data, LIVE_LOG_DMA_LENGTH_LOW_FREQ, do_nothing);
 8006ae2:	4a1e      	ldr	r2, [pc, #120]	; (8006b5c <log_push+0x260>)
 8006ae4:	481e      	ldr	r0, [pc, #120]	; (8006b60 <log_push+0x264>)
}
 8006ae6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    send_message_DMA(live_data, LIVE_LOG_DMA_LENGTH_LOW_FREQ, do_nothing);
 8006aea:	f000 b8d1 	b.w	8006c90 <send_message_DMA>
    live_data[ptr++] = 0x11;
 8006aee:	4f1c      	ldr	r7, [pc, #112]	; (8006b60 <log_push+0x264>)
 8006af0:	2311      	movs	r3, #17
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006af2:	f104 0c30 	add.w	ip, r4, #48	; 0x30
    live_data[ptr++] = 0x11;
 8006af6:	463d      	mov	r5, r7
 8006af8:	f805 3b01 	strb.w	r3, [r5], #1
    memcpy(&live_data[ptr], data, sizeof(low_freq_log_t));
 8006afc:	4626      	mov	r6, r4
 8006afe:	3510      	adds	r5, #16
 8006b00:	3410      	adds	r4, #16
 8006b02:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006b04:	4566      	cmp	r6, ip
 8006b06:	f845 0c10 	str.w	r0, [r5, #-16]
 8006b0a:	f845 1c0c 	str.w	r1, [r5, #-12]
 8006b0e:	f845 2c08 	str.w	r2, [r5, #-8]
 8006b12:	f845 3c04 	str.w	r3, [r5, #-4]
 8006b16:	d1f1      	bne.n	8006afc <log_push+0x200>
 8006b18:	e7cf      	b.n	8006aba <log_push+0x1be>
 8006b1a:	bf00      	nop
 8006b1c:	20069400 	.word	0x20069400
 8006b20:	2000c798 	.word	0x2000c798
 8006b24:	20069450 	.word	0x20069450
 8006b28:	20069401 	.word	0x20069401
 8006b2c:	2000c796 	.word	0x2000c796
 8006b30:	d1b71759 	.word	0xd1b71759
 8006b34:	20069402 	.word	0x20069402
 8006b38:	2000c79c 	.word	0x2000c79c
 8006b3c:	2000c79e 	.word	0x2000c79e
 8006b40:	2000c7a0 	.word	0x2000c7a0
 8006b44:	20002130 	.word	0x20002130
 8006b48:	20001f4c 	.word	0x20001f4c
 8006b4c:	2000c79a 	.word	0x2000c79a
 8006b50:	20002958 	.word	0x20002958
 8006b54:	455f4c4c 	.word	0x455f4c4c
 8006b58:	2121444e 	.word	0x2121444e
 8006b5c:	080068b5 	.word	0x080068b5
 8006b60:	20069404 	.word	0x20069404

08006b64 <set_frequency>:
    frequency = f;
 8006b64:	4b01      	ldr	r3, [pc, #4]	; (8006b6c <set_frequency+0x8>)
 8006b66:	7018      	strb	r0, [r3, #0]
}
 8006b68:	4770      	bx	lr
 8006b6a:	bf00      	nop
 8006b6c:	20001f4c 	.word	0x20001f4c

08006b70 <enable_live_log>:

void enable_live_log(){
    live_log_enable = true;
 8006b70:	4b01      	ldr	r3, [pc, #4]	; (8006b78 <enable_live_log+0x8>)
 8006b72:	2201      	movs	r2, #1
 8006b74:	701a      	strb	r2, [r3, #0]
}
 8006b76:	4770      	bx	lr
 8006b78:	2000c79e 	.word	0x2000c79e

08006b7c <cease_logging>:
void disable_live_log(){
    live_log_enable = false;
}

void cease_logging(){
    cease_log = true;
 8006b7c:	4b01      	ldr	r3, [pc, #4]	; (8006b84 <cease_logging+0x8>)
 8006b7e:	2201      	movs	r2, #1
 8006b80:	701a      	strb	r2, [r3, #0]
}
 8006b82:	4770      	bx	lr
 8006b84:	20069400 	.word	0x20069400

08006b88 <resume_logging>:

void resume_logging(){
    cease_log = false;
 8006b88:	4b01      	ldr	r3, [pc, #4]	; (8006b90 <resume_logging+0x8>)
 8006b8a:	2200      	movs	r2, #0
 8006b8c:	701a      	strb	r2, [r3, #0]
}
 8006b8e:	4770      	bx	lr
 8006b90:	20069400 	.word	0x20069400

08006b94 <log_pop>:

int log_pop(high_freq_log_t *data){
 8006b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int res = (count > 1) ? 0 : -1;
 8006b98:	f8df 8050 	ldr.w	r8, [pc, #80]	; 8006bec <log_pop+0x58>
 8006b9c:	f8b8 4000 	ldrh.w	r4, [r8]
 8006ba0:	2c01      	cmp	r4, #1
 8006ba2:	d918      	bls.n	8006bd6 <log_pop+0x42>
 8006ba4:	2600      	movs	r6, #0
    if(count > 0){
        *data = data_log[r_ptr];
 8006ba6:	4f0e      	ldr	r7, [pc, #56]	; (8006be0 <log_pop+0x4c>)
 8006ba8:	224c      	movs	r2, #76	; 0x4c
 8006baa:	490e      	ldr	r1, [pc, #56]	; (8006be4 <log_pop+0x50>)
        r_ptr = (r_ptr + 1) % LOG_SIZE;
        count--;
 8006bac:	3c01      	subs	r4, #1
        *data = data_log[r_ptr];
 8006bae:	883d      	ldrh	r5, [r7, #0]
 8006bb0:	fb02 1105 	mla	r1, r2, r5, r1
        r_ptr = (r_ptr + 1) % LOG_SIZE;
 8006bb4:	3501      	adds	r5, #1
        *data = data_log[r_ptr];
 8006bb6:	f002 fea3 	bl	8009900 <memcpy>
        r_ptr = (r_ptr + 1) % LOG_SIZE;
 8006bba:	4b0b      	ldr	r3, [pc, #44]	; (8006be8 <log_pop+0x54>)
 8006bbc:	f241 3288 	movw	r2, #5000	; 0x1388
        count--;
 8006bc0:	f8a8 4000 	strh.w	r4, [r8]
        r_ptr = (r_ptr + 1) % LOG_SIZE;
 8006bc4:	fba3 1305 	umull	r1, r3, r3, r5
 8006bc8:	0b1b      	lsrs	r3, r3, #12
 8006bca:	fb02 5313 	mls	r3, r2, r3, r5
 8006bce:	803b      	strh	r3, [r7, #0]
    }
    return res;
}
 8006bd0:	4630      	mov	r0, r6
 8006bd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    int res = (count > 1) ? 0 : -1;
 8006bd6:	f04f 36ff 	mov.w	r6, #4294967295
    if(count > 0){
 8006bda:	2c00      	cmp	r4, #0
 8006bdc:	d0f8      	beq.n	8006bd0 <log_pop+0x3c>
 8006bde:	e7e2      	b.n	8006ba6 <log_pop+0x12>
 8006be0:	2000c79c 	.word	0x2000c79c
 8006be4:	2000c7a0 	.word	0x2000c7a0
 8006be8:	d1b71759 	.word	0xd1b71759
 8006bec:	20069402 	.word	0x20069402

08006bf0 <error_handler>:
    HAL_UART_Receive_IT(_huart, buffer, 7);
}

void error_handler()
{
  HAL_UART_Transmit(_huart, "ERROR!!!!", 9, 0xFFFF);
 8006bf0:	4803      	ldr	r0, [pc, #12]	; (8006c00 <error_handler+0x10>)
 8006bf2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006bf6:	2209      	movs	r2, #9
 8006bf8:	4902      	ldr	r1, [pc, #8]	; (8006c04 <error_handler+0x14>)
 8006bfa:	6800      	ldr	r0, [r0, #0]
 8006bfc:	f7fd ba02 	b.w	8004004 <HAL_UART_Transmit>
 8006c00:	200020b4 	.word	0x200020b4
 8006c04:	080099b8 	.word	0x080099b8

08006c08 <download_log>:

HAL_UART_StateTypeDef getUARTState(){
  return _huart->gState;
}

void download_log(){
 8006c08:	b510      	push	{r4, lr}
 8006c0a:	b0a8      	sub	sp, #160	; 0xa0
  high_freq_log_t log;
  int ptr = 0;
  uint8_t buf[(sizeof(high_freq_log_t) + 3)];
  int status = log_pop(&log);
 8006c0c:	a801      	add	r0, sp, #4
 8006c0e:	f7ff ffc1 	bl	8006b94 <log_pop>
  if(status == -1){
 8006c12:	3001      	adds	r0, #1
 8006c14:	d014      	beq.n	8006c40 <download_log+0x38>
    HAL_UART_Transmit(_huart, "LOG_END!!!!", 11, 0xFFFF);
    resume_logging();
  }
  else{
    buf[ptr++] = 0x11;
 8006c16:	2311      	movs	r3, #17
 8006c18:	ac28      	add	r4, sp, #160	; 0xa0
    memcpy(&buf[ptr], &log, sizeof(high_freq_log_t));
 8006c1a:	224c      	movs	r2, #76	; 0x4c
 8006c1c:	a901      	add	r1, sp, #4
 8006c1e:	f10d 0051 	add.w	r0, sp, #81	; 0x51
    buf[ptr++] = 0x11;
 8006c22:	f804 3d50 	strb.w	r3, [r4, #-80]!
    memcpy(&buf[ptr], &log, sizeof(high_freq_log_t));
 8006c26:	f002 fe6b 	bl	8009900 <memcpy>
  if (_huart->gState != HAL_UART_STATE_READY){
 8006c2a:	4a10      	ldr	r2, [pc, #64]	; (8006c6c <download_log+0x64>)
    ptr = ptr + sizeof(high_freq_log_t);
    buf[ptr++] = 0x21;
 8006c2c:	f04f 3321 	mov.w	r3, #555819297	; 0x21212121
  if (_huart->gState != HAL_UART_STATE_READY){
 8006c30:	6810      	ldr	r0, [r2, #0]
    buf[ptr++] = 0x21;
 8006c32:	f8cd 309d 	str.w	r3, [sp, #157]	; 0x9d
  if (_huart->gState != HAL_UART_STATE_READY){
 8006c36:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8006c38:	2b20      	cmp	r3, #32
 8006c3a:	d00d      	beq.n	8006c58 <download_log+0x50>
    buf[ptr++] = 0x21;
    buf[ptr++] = 0x21;
    buf[ptr++] = 0x21;
    send_message_DMA(buf, 73, download_log);
  }
}
 8006c3c:	b028      	add	sp, #160	; 0xa0
 8006c3e:	bd10      	pop	{r4, pc}
    HAL_UART_Transmit(_huart, "LOG_END!!!!", 11, 0xFFFF);
 8006c40:	480a      	ldr	r0, [pc, #40]	; (8006c6c <download_log+0x64>)
 8006c42:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006c46:	220b      	movs	r2, #11
 8006c48:	4909      	ldr	r1, [pc, #36]	; (8006c70 <download_log+0x68>)
 8006c4a:	6800      	ldr	r0, [r0, #0]
 8006c4c:	f7fd f9da 	bl	8004004 <HAL_UART_Transmit>
    resume_logging();
 8006c50:	f7ff ff9a 	bl	8006b88 <resume_logging>
}
 8006c54:	b028      	add	sp, #160	; 0xa0
 8006c56:	bd10      	pop	{r4, pc}
  TxCpltCallback = onComplete;
 8006c58:	4b06      	ldr	r3, [pc, #24]	; (8006c74 <download_log+0x6c>)
  HAL_UART_Transmit_DMA(_huart, data, length);
 8006c5a:	4621      	mov	r1, r4
 8006c5c:	2249      	movs	r2, #73	; 0x49
  TxCpltCallback = onComplete;
 8006c5e:	4c06      	ldr	r4, [pc, #24]	; (8006c78 <download_log+0x70>)
 8006c60:	601c      	str	r4, [r3, #0]
  HAL_UART_Transmit_DMA(_huart, data, length);
 8006c62:	f7fd facb 	bl	80041fc <HAL_UART_Transmit_DMA>
}
 8006c66:	b028      	add	sp, #160	; 0xa0
 8006c68:	bd10      	pop	{r4, pc}
 8006c6a:	bf00      	nop
 8006c6c:	200020b4 	.word	0x200020b4
 8006c70:	080099ac 	.word	0x080099ac
 8006c74:	2006949c 	.word	0x2006949c
 8006c78:	08006c09 	.word	0x08006c09

08006c7c <serial_init>:
    _huart = huart;
 8006c7c:	4b02      	ldr	r3, [pc, #8]	; (8006c88 <serial_init+0xc>)
    HAL_UART_Receive_IT(_huart, buffer, 7);
 8006c7e:	2207      	movs	r2, #7
 8006c80:	4902      	ldr	r1, [pc, #8]	; (8006c8c <serial_init+0x10>)
    _huart = huart;
 8006c82:	6018      	str	r0, [r3, #0]
    HAL_UART_Receive_IT(_huart, buffer, 7);
 8006c84:	f7fd ba4a 	b.w	800411c <HAL_UART_Receive_IT>
 8006c88:	200020b4 	.word	0x200020b4
 8006c8c:	200020b8 	.word	0x200020b8

08006c90 <send_message_DMA>:
int8_t send_message_DMA(uint8_t data[], int length, void (*onComplete)()){
 8006c90:	b538      	push	{r3, r4, r5, lr}
  if (_huart->gState != HAL_UART_STATE_READY){
 8006c92:	4b09      	ldr	r3, [pc, #36]	; (8006cb8 <send_message_DMA+0x28>)
 8006c94:	681c      	ldr	r4, [r3, #0]
 8006c96:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006c98:	2b20      	cmp	r3, #32
 8006c9a:	d10a      	bne.n	8006cb2 <send_message_DMA+0x22>
 8006c9c:	4613      	mov	r3, r2
 8006c9e:	460a      	mov	r2, r1
  TxCpltCallback = onComplete;
 8006ca0:	4d06      	ldr	r5, [pc, #24]	; (8006cbc <send_message_DMA+0x2c>)
 8006ca2:	4601      	mov	r1, r0
  HAL_UART_Transmit_DMA(_huart, data, length);
 8006ca4:	b292      	uxth	r2, r2
 8006ca6:	4620      	mov	r0, r4
  TxCpltCallback = onComplete;
 8006ca8:	602b      	str	r3, [r5, #0]
  HAL_UART_Transmit_DMA(_huart, data, length);
 8006caa:	f7fd faa7 	bl	80041fc <HAL_UART_Transmit_DMA>
  return 0;
 8006cae:	2000      	movs	r0, #0
}
 8006cb0:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 8006cb2:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006cb6:	bd38      	pop	{r3, r4, r5, pc}
 8006cb8:	200020b4 	.word	0x200020b4
 8006cbc:	2006949c 	.word	0x2006949c

08006cc0 <getUARTState>:
  return _huart->gState;
 8006cc0:	4b01      	ldr	r3, [pc, #4]	; (8006cc8 <getUARTState+0x8>)
 8006cc2:	681b      	ldr	r3, [r3, #0]
 8006cc4:	6f58      	ldr	r0, [r3, #116]	; 0x74
}
 8006cc6:	4770      	bx	lr
 8006cc8:	200020b4 	.word	0x200020b4

08006ccc <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
 8006ccc:	b538      	push	{r3, r4, r5, lr}
    data[i] = buffer[6-i];
 8006cce:	4b3d      	ldr	r3, [pc, #244]	; (8006dc4 <HAL_UART_RxCpltCallback+0xf8>)
 8006cd0:	493d      	ldr	r1, [pc, #244]	; (8006dc8 <HAL_UART_RxCpltCallback+0xfc>)
 8006cd2:	799a      	ldrb	r2, [r3, #6]
 8006cd4:	795d      	ldrb	r5, [r3, #5]
 8006cd6:	700a      	strb	r2, [r1, #0]
  switch(command){
 8006cd8:	781a      	ldrb	r2, [r3, #0]
    data[i] = buffer[6-i];
 8006cda:	791c      	ldrb	r4, [r3, #4]
 8006cdc:	78d8      	ldrb	r0, [r3, #3]
  switch(command){
 8006cde:	2a1f      	cmp	r2, #31
    data[i] = buffer[6-i];
 8006ce0:	704d      	strb	r5, [r1, #1]
 8006ce2:	708c      	strb	r4, [r1, #2]
 8006ce4:	70c8      	strb	r0, [r1, #3]
  switch(command){
 8006ce6:	d065      	beq.n	8006db4 <HAL_UART_RxCpltCallback+0xe8>
 8006ce8:	d806      	bhi.n	8006cf8 <HAL_UART_RxCpltCallback+0x2c>
 8006cea:	2a1d      	cmp	r2, #29
 8006cec:	d01d      	beq.n	8006d2a <HAL_UART_RxCpltCallback+0x5e>
 8006cee:	d85a      	bhi.n	8006da6 <HAL_UART_RxCpltCallback+0xda>
 8006cf0:	2a10      	cmp	r2, #16
 8006cf2:	d107      	bne.n	8006d04 <HAL_UART_RxCpltCallback+0x38>
 8006cf4:	4c35      	ldr	r4, [pc, #212]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006cf6:	e036      	b.n	8006d66 <HAL_UART_RxCpltCallback+0x9a>
 8006cf8:	2aaa      	cmp	r2, #170	; 0xaa
 8006cfa:	d05b      	beq.n	8006db4 <HAL_UART_RxCpltCallback+0xe8>
 8006cfc:	2aee      	cmp	r2, #238	; 0xee
 8006cfe:	d048      	beq.n	8006d92 <HAL_UART_RxCpltCallback+0xc6>
 8006d00:	2a97      	cmp	r2, #151	; 0x97
 8006d02:	d037      	beq.n	8006d74 <HAL_UART_RxCpltCallback+0xa8>
  HAL_UART_Transmit(_huart, "ERROR!!!!", 9, 0xFFFF);
 8006d04:	4c31      	ldr	r4, [pc, #196]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006d06:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d0a:	2209      	movs	r2, #9
 8006d0c:	4930      	ldr	r1, [pc, #192]	; (8006dd0 <HAL_UART_RxCpltCallback+0x104>)
 8006d0e:	6820      	ldr	r0, [r4, #0]
 8006d10:	f7fd f978 	bl	8004004 <HAL_UART_Transmit>
      status = HAL_ERROR;
 8006d14:	4b2f      	ldr	r3, [pc, #188]	; (8006dd4 <HAL_UART_RxCpltCallback+0x108>)
 8006d16:	2201      	movs	r2, #1
 8006d18:	6820      	ldr	r0, [r4, #0]
 8006d1a:	701a      	strb	r2, [r3, #0]
    HAL_UART_Transmit(_huart, "NACK!!!!", 8, 0xFFFF);
 8006d1c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d20:	2208      	movs	r2, #8
 8006d22:	492d      	ldr	r1, [pc, #180]	; (8006dd8 <HAL_UART_RxCpltCallback+0x10c>)
 8006d24:	f7fd f96e 	bl	8004004 <HAL_UART_Transmit>
 8006d28:	e01d      	b.n	8006d66 <HAL_UART_RxCpltCallback+0x9a>
      HAL_UART_Transmit(_huart, "DOWNLOAD_ACK!!!!", 16, 0xFFFF);
 8006d2a:	4c28      	ldr	r4, [pc, #160]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006d2c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d30:	2210      	movs	r2, #16
 8006d32:	492a      	ldr	r1, [pc, #168]	; (8006ddc <HAL_UART_RxCpltCallback+0x110>)
 8006d34:	6820      	ldr	r0, [r4, #0]
 8006d36:	f7fd f965 	bl	8004004 <HAL_UART_Transmit>
      HAL_UART_Transmit(_huart, "LEN_5000!!!!", 12, 0xffff);
 8006d3a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d3e:	220c      	movs	r2, #12
 8006d40:	4927      	ldr	r1, [pc, #156]	; (8006de0 <HAL_UART_RxCpltCallback+0x114>)
 8006d42:	6820      	ldr	r0, [r4, #0]
 8006d44:	f7fd f95e 	bl	8004004 <HAL_UART_Transmit>
      cease_logging();
 8006d48:	f7ff ff18 	bl	8006b7c <cease_logging>
      download_log();
 8006d4c:	f7ff ff5c 	bl	8006c08 <download_log>
 8006d50:	4b20      	ldr	r3, [pc, #128]	; (8006dd4 <HAL_UART_RxCpltCallback+0x108>)
 8006d52:	781b      	ldrb	r3, [r3, #0]
 8006d54:	6820      	ldr	r0, [r4, #0]
  if(status == HAL_OK){
 8006d56:	2b00      	cmp	r3, #0
 8006d58:	d1e0      	bne.n	8006d1c <HAL_UART_RxCpltCallback+0x50>
    HAL_UART_Transmit(_huart, "ACK!!!!", 7, 0xFFFF);
 8006d5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d5e:	2207      	movs	r2, #7
 8006d60:	4920      	ldr	r1, [pc, #128]	; (8006de4 <HAL_UART_RxCpltCallback+0x118>)
 8006d62:	f7fd f94f 	bl	8004004 <HAL_UART_Transmit>
  _handle();
  HAL_UART_Receive_IT(_huart, buffer, 7);
 8006d66:	6820      	ldr	r0, [r4, #0]
 8006d68:	2207      	movs	r2, #7
 8006d6a:	4916      	ldr	r1, [pc, #88]	; (8006dc4 <HAL_UART_RxCpltCallback+0xf8>)
}
 8006d6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_UART_Receive_IT(_huart, buffer, 7);
 8006d70:	f7fd b9d4 	b.w	800411c <HAL_UART_Receive_IT>
  id = (buffer[1] << 8) | buffer[2];
 8006d74:	785a      	ldrb	r2, [r3, #1]
 8006d76:	789b      	ldrb	r3, [r3, #2]
      status = flash_program_sequential(derive_address(id), data, error_handler);
 8006d78:	481b      	ldr	r0, [pc, #108]	; (8006de8 <HAL_UART_RxCpltCallback+0x11c>)
  return (0x081FFFFF - ((id + 1) * 4));
 8006d7a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      status = flash_program_sequential(derive_address(id), data, error_handler);
 8006d7e:	4a1b      	ldr	r2, [pc, #108]	; (8006dec <HAL_UART_RxCpltCallback+0x120>)
 8006d80:	4c12      	ldr	r4, [pc, #72]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
  return (0x081FFFFF - ((id + 1) * 4));
 8006d82:	009b      	lsls	r3, r3, #2
      status = flash_program_sequential(derive_address(id), data, error_handler);
 8006d84:	1ac0      	subs	r0, r0, r3
 8006d86:	f002 fd35 	bl	80097f4 <flash_program_sequential>
 8006d8a:	4a12      	ldr	r2, [pc, #72]	; (8006dd4 <HAL_UART_RxCpltCallback+0x108>)
 8006d8c:	4603      	mov	r3, r0
 8006d8e:	7010      	strb	r0, [r2, #0]
 8006d90:	e7e0      	b.n	8006d54 <HAL_UART_RxCpltCallback+0x88>
      status = flash_erase_sector(FLASH_SECTOR_11, VOLTAGE_RANGE_3, error_handler);
 8006d92:	4a16      	ldr	r2, [pc, #88]	; (8006dec <HAL_UART_RxCpltCallback+0x120>)
 8006d94:	2102      	movs	r1, #2
 8006d96:	200b      	movs	r0, #11
 8006d98:	4c0c      	ldr	r4, [pc, #48]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006d9a:	f002 fd13 	bl	80097c4 <flash_erase_sector>
 8006d9e:	4a0d      	ldr	r2, [pc, #52]	; (8006dd4 <HAL_UART_RxCpltCallback+0x108>)
 8006da0:	4603      	mov	r3, r0
 8006da2:	7010      	strb	r0, [r2, #0]
 8006da4:	e7d6      	b.n	8006d54 <HAL_UART_RxCpltCallback+0x88>
      set_frequency(LOW_FREQ);
 8006da6:	2000      	movs	r0, #0
 8006da8:	4c08      	ldr	r4, [pc, #32]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006daa:	f7ff fedb 	bl	8006b64 <set_frequency>
      enable_live_log();
 8006dae:	f7ff fedf 	bl	8006b70 <enable_live_log>
 8006db2:	e7d8      	b.n	8006d66 <HAL_UART_RxCpltCallback+0x9a>
      set_frequency(HIGH_FREQ);
 8006db4:	2001      	movs	r0, #1
 8006db6:	4c05      	ldr	r4, [pc, #20]	; (8006dcc <HAL_UART_RxCpltCallback+0x100>)
 8006db8:	f7ff fed4 	bl	8006b64 <set_frequency>
      enable_live_log();
 8006dbc:	f7ff fed8 	bl	8006b70 <enable_live_log>
 8006dc0:	e7d1      	b.n	8006d66 <HAL_UART_RxCpltCallback+0x9a>
 8006dc2:	bf00      	nop
 8006dc4:	200020b8 	.word	0x200020b8
 8006dc8:	200020d8 	.word	0x200020d8
 8006dcc:	200020b4 	.word	0x200020b4
 8006dd0:	080099b8 	.word	0x080099b8
 8006dd4:	200020f8 	.word	0x200020f8
 8006dd8:	080099a0 	.word	0x080099a0
 8006ddc:	08009974 	.word	0x08009974
 8006de0:	08009988 	.word	0x08009988
 8006de4:	08009998 	.word	0x08009998
 8006de8:	081ffffb 	.word	0x081ffffb
 8006dec:	08006bf1 	.word	0x08006bf1

08006df0 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart){
  TxCpltCallback();
 8006df0:	4b01      	ldr	r3, [pc, #4]	; (8006df8 <HAL_UART_TxCpltCallback+0x8>)
 8006df2:	681b      	ldr	r3, [r3, #0]
 8006df4:	4718      	bx	r3
 8006df6:	bf00      	nop
 8006df8:	2006949c 	.word	0x2006949c

08006dfc <start_iabc_conversions>:

/*
 * Start the ADC conversion.
 */
void start_iabc_conversions(void) {
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 8006dfc:	2200      	movs	r2, #0
 8006dfe:	f44f 7100 	mov.w	r1, #512	; 0x200
 8006e02:	4801      	ldr	r0, [pc, #4]	; (8006e08 <start_iabc_conversions+0xc>)
 8006e04:	f7fb b98a 	b.w	800211c <HAL_GPIO_WritePin>
 8006e08:	40021800 	.word	0x40021800

08006e0c <check_for_iabc_zeros>:

/*
 * Check for phase current zeros. If the phase current magnitude is < 0.5, then just make it zero. We had some
 * issues with the control system and small noise when we were asking for zero torque and this fixed it.
 */
void check_for_iabc_zeros(void) {
 8006e0c:	b510      	push	{r4, lr}
	if (absVal(mc_vars.iabc[0])<0.5) {
 8006e0e:	4c14      	ldr	r4, [pc, #80]	; (8006e60 <check_for_iabc_zeros+0x54>)
 8006e10:	ed94 0a03 	vldr	s0, [r4, #12]
 8006e14:	f7fe fa84 	bl	8005320 <absVal>
 8006e18:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8006e1c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006e20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e24:	d501      	bpl.n	8006e2a <check_for_iabc_zeros+0x1e>
		mc_vars.iabc[0]=0;
 8006e26:	2300      	movs	r3, #0
 8006e28:	60e3      	str	r3, [r4, #12]
	}
	if (absVal(mc_vars.iabc[1])<0.5) {
 8006e2a:	ed94 0a04 	vldr	s0, [r4, #16]
 8006e2e:	f7fe fa77 	bl	8005320 <absVal>
 8006e32:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8006e36:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e3e:	d501      	bpl.n	8006e44 <check_for_iabc_zeros+0x38>
		mc_vars.iabc[1]=0;
 8006e40:	2300      	movs	r3, #0
 8006e42:	6123      	str	r3, [r4, #16]
	}
	if (absVal(mc_vars.iabc[2])<0.5) {
 8006e44:	ed94 0a05 	vldr	s0, [r4, #20]
 8006e48:	f7fe fa6a 	bl	8005320 <absVal>
 8006e4c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8006e50:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006e54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e58:	d501      	bpl.n	8006e5e <check_for_iabc_zeros+0x52>
		mc_vars.iabc[2]=0;
 8006e5a:	2300      	movs	r3, #0
 8006e5c:	6163      	str	r3, [r4, #20]
	}
}
 8006e5e:	bd10      	pop	{r4, pc}
 8006e60:	200021cc 	.word	0x200021cc
 8006e64:	00000000 	.word	0x00000000

08006e68 <update_iabc>:

/*
 * Update the phase currents by reading the currents from the three external ADCs over SPI
 */
void update_iabc(void) {
 8006e68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * Send a byte over SPI. Refactored from the HAL libraries.
 */
void spi_rx_byte(SPI_HandleTypeDef *hspi, uint8_t *pRxData) {
	uint8_t temp = 0x00;
	/* Set the transaction information */
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8006e6c:	4ca2      	ldr	r4, [pc, #648]	; (80070f8 <update_iabc+0x290>)
void update_iabc(void) {
 8006e6e:	b083      	sub	sp, #12
	HAL_GPIO_WritePin(IABC_CS_A_GPIO_Port, IABC_CS_A_Pin, 0);
 8006e70:	2200      	movs	r2, #0
 8006e72:	2180      	movs	r1, #128	; 0x80
 8006e74:	48a1      	ldr	r0, [pc, #644]	; (80070fc <update_iabc+0x294>)
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8006e76:	f10d 0806 	add.w	r8, sp, #6
	HAL_GPIO_WritePin(IABC_CS_A_GPIO_Port, IABC_CS_A_Pin, 0);
 8006e7a:	f7fb f94f 	bl	800211c <HAL_GPIO_WritePin>
	uint8_t buffer2 = 0;
 8006e7e:	2300      	movs	r3, #0
	hspi->RxXferCount = 1;
 8006e80:	2101      	movs	r1, #1
	/*Init field not used in handle to zero */
	hspi->RxISR       = NULL;
	hspi->TxISR       = NULL;


	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006e82:	6822      	ldr	r2, [r4, #0]
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8006e84:	6623      	str	r3, [r4, #96]	; 0x60
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 8006e86:	f10d 0707 	add.w	r7, sp, #7
	hspi->RxXferCount = 1;
 8006e8a:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
	uint8_t buffer2 = 0;
 8006e8e:	f88d 3006 	strb.w	r3, [sp, #6]
	hspi->TxXferCount = 1;
 8006e92:	87e1      	strh	r1, [r4, #62]	; 0x3e
	uint8_t temp = 0x00;
 8006e94:	f88d 3007 	strb.w	r3, [sp, #7]
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006e98:	6850      	ldr	r0, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 8006e9a:	63a7      	str	r7, [r4, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006e9c:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
	hspi->RxISR       = NULL;
 8006ea0:	64e3      	str	r3, [r4, #76]	; 0x4c
	hspi->TxISR       = NULL;
 8006ea2:	6523      	str	r3, [r4, #80]	; 0x50
	hspi->RxXferSize  = 1;
 8006ea4:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 8006ea8:	87a1      	strh	r1, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8006eaa:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006eae:	6050      	str	r0, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8006eb0:	7313      	strb	r3, [r2, #12]
	hspi->pTxBuffPtr++;
	hspi->TxXferCount--;
 8006eb2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8006eb4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006eb6:	3b01      	subs	r3, #1
	hspi->pTxBuffPtr++;
 8006eb8:	3101      	adds	r1, #1
	hspi->TxXferCount--;
 8006eba:	b29b      	uxth	r3, r3
	hspi->pTxBuffPtr++;
 8006ebc:	63a1      	str	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006ebe:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8006ec0:	e003      	b.n	8006eca <update_iabc+0x62>

	while (hspi->RxXferCount > 0U)
	{
	  /* Wait until RXNE flag is reset */
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8006ec2:	6893      	ldr	r3, [r2, #8]
 8006ec4:	07d8      	lsls	r0, r3, #31
 8006ec6:	f100 819c 	bmi.w	8007202 <update_iabc+0x39a>
	while (hspi->RxXferCount > 0U)
 8006eca:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8006ece:	b29b      	uxth	r3, r3
 8006ed0:	2b00      	cmp	r3, #0
 8006ed2:	d1f6      	bne.n	8006ec2 <update_iabc+0x5a>
	hspi->RxXferCount = 1;
 8006ed4:	2101      	movs	r1, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8006ed6:	6623      	str	r3, [r4, #96]	; 0x60
	uint8_t temp = 0x00;
 8006ed8:	f88d 3007 	strb.w	r3, [sp, #7]
	hspi->RxXferCount = 1;
 8006edc:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
	hspi->TxXferCount = 1;
 8006ee0:	87e1      	strh	r1, [r4, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006ee2:	6855      	ldr	r5, [r2, #4]
	miso = buffer2;
 8006ee4:	f89d 0006 	ldrb.w	r0, [sp, #6]
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006ee8:	f445 5580 	orr.w	r5, r5, #4096	; 0x1000
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 8006eec:	63a7      	str	r7, [r4, #56]	; 0x38
	hspi->RxXferSize  = 1;
 8006eee:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 8006ef2:	87a1      	strh	r1, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8006ef4:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	hspi->TxISR       = NULL;
 8006ef8:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006efc:	6055      	str	r5, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8006efe:	7313      	strb	r3, [r2, #12]
	hspi->TxXferCount--;
 8006f00:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8006f02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006f04:	3901      	subs	r1, #1
	hspi->pTxBuffPtr++;
 8006f06:	3301      	adds	r3, #1
	hspi->TxXferCount--;
 8006f08:	b289      	uxth	r1, r1
	hspi->pTxBuffPtr++;
 8006f0a:	63a3      	str	r3, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006f0c:	87e1      	strh	r1, [r4, #62]	; 0x3e
 8006f0e:	e003      	b.n	8006f18 <update_iabc+0xb0>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8006f10:	6893      	ldr	r3, [r2, #8]
 8006f12:	07d9      	lsls	r1, r3, #31
 8006f14:	f100 8183 	bmi.w	800721e <update_iabc+0x3b6>
	while (hspi->RxXferCount > 0U)
 8006f18:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
 8006f1c:	b2ad      	uxth	r5, r5
 8006f1e:	2d00      	cmp	r5, #0
 8006f20:	d1f6      	bne.n	8006f10 <update_iabc+0xa8>
	miso= ((miso<< 8) | buffer2);
 8006f22:	f89d 3006 	ldrb.w	r3, [sp, #6]
 * Hal only has delay in ms, and that's too long.
 */
void delay_us(int microsec){
	int num = 2*microsec;
	for (int i=0; i<num; i++) {
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8006f26:	462a      	mov	r2, r5
	mc_vars.iabc[0] -= offset_vals[0];
 8006f28:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 8007104 <update_iabc+0x29c>
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8006f2c:	2180      	movs	r1, #128	; 0x80
	miso= ((miso<< 8) | buffer2);
 8006f2e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	mc_vars.iabc[0] -= offset_vals[0];
 8006f32:	4e73      	ldr	r6, [pc, #460]	; (8007100 <update_iabc+0x298>)
 8006f34:	edd9 6a00 	vldr	s13, [r9]
	miso= ((miso<< 8) | buffer2);
 8006f38:	b21b      	sxth	r3, r3
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8006f3a:	4870      	ldr	r0, [pc, #448]	; (80070fc <update_iabc+0x294>)
	miso= ((miso<< 8) | buffer2);
 8006f3c:	ee07 3a10 	vmov	s14, r3
	mc_vars.iabc[0] = (float) (temp*CURRENT_MULTIPLIER_A);
 8006f40:	ed9f 5b69 	vldr	d5, [pc, #420]	; 80070e8 <update_iabc+0x280>
 8006f44:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
 8006f48:	ee27 7b05 	vmul.f64	d7, d7, d5
 8006f4c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	mc_vars.iabc[0] -= offset_vals[0];
 8006f50:	ee37 7a66 	vsub.f32	s14, s14, s13
 8006f54:	ed86 7a03 	vstr	s14, [r6, #12]
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8006f58:	f7fb f8e0 	bl	800211c <HAL_GPIO_WritePin>
 8006f5c:	462a      	mov	r2, r5
 8006f5e:	2180      	movs	r1, #128	; 0x80
 8006f60:	4866      	ldr	r0, [pc, #408]	; (80070fc <update_iabc+0x294>)
 8006f62:	f7fb f8db 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_B_Pin, 0);
 8006f66:	462a      	mov	r2, r5
 8006f68:	2140      	movs	r1, #64	; 0x40
 8006f6a:	4864      	ldr	r0, [pc, #400]	; (80070fc <update_iabc+0x294>)
 8006f6c:	f7fb f8d6 	bl	800211c <HAL_GPIO_WritePin>
	hspi->RxXferCount = 1;
 8006f70:	2301      	movs	r3, #1
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006f72:	6822      	ldr	r2, [r4, #0]
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8006f74:	6625      	str	r5, [r4, #96]	; 0x60
	uint8_t buffer2 = 0;
 8006f76:	f88d 5006 	strb.w	r5, [sp, #6]
	hspi->RxXferCount = 1;
 8006f7a:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
	uint8_t temp = 0x00;
 8006f7e:	f88d 5007 	strb.w	r5, [sp, #7]
	hspi->TxXferCount = 1;
 8006f82:	87e3      	strh	r3, [r4, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006f84:	6851      	ldr	r1, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 8006f86:	63a7      	str	r7, [r4, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006f88:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
	hspi->RxXferSize  = 1;
 8006f8c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 8006f90:	87a3      	strh	r3, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8006f92:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	hspi->TxISR       = NULL;
 8006f96:	e9c4 5513 	strd	r5, r5, [r4, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006f9a:	6051      	str	r1, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8006f9c:	7315      	strb	r5, [r2, #12]
	hspi->TxXferCount--;
 8006f9e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8006fa0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006fa2:	3b01      	subs	r3, #1
	hspi->pTxBuffPtr++;
 8006fa4:	3101      	adds	r1, #1
	hspi->TxXferCount--;
 8006fa6:	b29b      	uxth	r3, r3
	hspi->pTxBuffPtr++;
 8006fa8:	63a1      	str	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006faa:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8006fac:	e003      	b.n	8006fb6 <update_iabc+0x14e>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8006fae:	6893      	ldr	r3, [r2, #8]
 8006fb0:	07db      	lsls	r3, r3, #31
 8006fb2:	f100 8142 	bmi.w	800723a <update_iabc+0x3d2>
	while (hspi->RxXferCount > 0U)
 8006fb6:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8006fba:	b29b      	uxth	r3, r3
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d1f6      	bne.n	8006fae <update_iabc+0x146>
	hspi->RxXferCount = 1;
 8006fc0:	2101      	movs	r1, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8006fc2:	6623      	str	r3, [r4, #96]	; 0x60
	uint8_t temp = 0x00;
 8006fc4:	f88d 3007 	strb.w	r3, [sp, #7]
	hspi->RxXferCount = 1;
 8006fc8:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
	hspi->TxXferCount = 1;
 8006fcc:	87e1      	strh	r1, [r4, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006fce:	6855      	ldr	r5, [r2, #4]
	miso = buffer2;
 8006fd0:	f89d 0006 	ldrb.w	r0, [sp, #6]
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006fd4:	f445 5580 	orr.w	r5, r5, #4096	; 0x1000
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 8006fd8:	63a7      	str	r7, [r4, #56]	; 0x38
	hspi->RxXferSize  = 1;
 8006fda:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 8006fde:	87a1      	strh	r1, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8006fe0:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	hspi->TxISR       = NULL;
 8006fe4:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8006fe8:	6055      	str	r5, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8006fea:	7313      	strb	r3, [r2, #12]
	hspi->TxXferCount--;
 8006fec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8006fee:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006ff0:	3b01      	subs	r3, #1
	hspi->pTxBuffPtr++;
 8006ff2:	3101      	adds	r1, #1
	hspi->TxXferCount--;
 8006ff4:	b29b      	uxth	r3, r3
	hspi->pTxBuffPtr++;
 8006ff6:	63a1      	str	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8006ff8:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8006ffa:	e003      	b.n	8007004 <update_iabc+0x19c>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8006ffc:	6893      	ldr	r3, [r2, #8]
 8006ffe:	07dd      	lsls	r5, r3, #31
 8007000:	f100 8129 	bmi.w	8007256 <update_iabc+0x3ee>
	while (hspi->RxXferCount > 0U)
 8007004:	f8b4 5046 	ldrh.w	r5, [r4, #70]	; 0x46
 8007008:	b2ad      	uxth	r5, r5
 800700a:	2d00      	cmp	r5, #0
 800700c:	d1f6      	bne.n	8006ffc <update_iabc+0x194>
	miso= ((miso<< 8) | buffer2);
 800700e:	f89d 3006 	ldrb.w	r3, [sp, #6]
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8007012:	462a      	mov	r2, r5
	mc_vars.iabc[1] -= offset_vals[1];
 8007014:	edd9 6a01 	vldr	s13, [r9, #4]
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 8007018:	2180      	movs	r1, #128	; 0x80
	miso= ((miso<< 8) | buffer2);
 800701a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 800701e:	4837      	ldr	r0, [pc, #220]	; (80070fc <update_iabc+0x294>)
	miso= ((miso<< 8) | buffer2);
 8007020:	b21b      	sxth	r3, r3
 8007022:	ee07 3a10 	vmov	s14, r3
	mc_vars.iabc[1] = (float) (temp*CURRENT_MULTIPLIER_B);
 8007026:	ed9f 5b32 	vldr	d5, [pc, #200]	; 80070f0 <update_iabc+0x288>
 800702a:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
 800702e:	ee27 7b05 	vmul.f64	d7, d7, d5
 8007032:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	mc_vars.iabc[1] -= offset_vals[1];
 8007036:	ee37 7a66 	vsub.f32	s14, s14, s13
 800703a:	ed86 7a04 	vstr	s14, [r6, #16]
		HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_A_Pin, 0);
 800703e:	f7fb f86d 	bl	800211c <HAL_GPIO_WritePin>
 8007042:	462a      	mov	r2, r5
 8007044:	2180      	movs	r1, #128	; 0x80
 8007046:	482d      	ldr	r0, [pc, #180]	; (80070fc <update_iabc+0x294>)
 8007048:	f7fb f868 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_C_GPIO_Port, IABC_CS_C_Pin, 0);
 800704c:	462a      	mov	r2, r5
 800704e:	2110      	movs	r1, #16
 8007050:	482a      	ldr	r0, [pc, #168]	; (80070fc <update_iabc+0x294>)
 8007052:	f7fb f863 	bl	800211c <HAL_GPIO_WritePin>
	hspi->RxXferCount = 1;
 8007056:	2301      	movs	r3, #1
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007058:	6822      	ldr	r2, [r4, #0]
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800705a:	6625      	str	r5, [r4, #96]	; 0x60
	uint8_t buffer2 = 0;
 800705c:	f88d 5006 	strb.w	r5, [sp, #6]
	hspi->RxXferCount = 1;
 8007060:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
	uint8_t temp = 0x00;
 8007064:	f88d 5007 	strb.w	r5, [sp, #7]
	hspi->TxXferCount = 1;
 8007068:	87e3      	strh	r3, [r4, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800706a:	6851      	ldr	r1, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 800706c:	63a7      	str	r7, [r4, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800706e:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
	hspi->RxXferSize  = 1;
 8007072:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 8007076:	87a3      	strh	r3, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8007078:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	hspi->TxISR       = NULL;
 800707c:	e9c4 5513 	strd	r5, r5, [r4, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007080:	6051      	str	r1, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8007082:	7315      	strb	r5, [r2, #12]
	hspi->TxXferCount--;
 8007084:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8007086:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8007088:	3b01      	subs	r3, #1
	hspi->pTxBuffPtr++;
 800708a:	3101      	adds	r1, #1
	hspi->TxXferCount--;
 800708c:	b29b      	uxth	r3, r3
	hspi->pTxBuffPtr++;
 800708e:	63a1      	str	r1, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 8007090:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8007092:	e003      	b.n	800709c <update_iabc+0x234>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007094:	6893      	ldr	r3, [r2, #8]
 8007096:	07d9      	lsls	r1, r3, #31
 8007098:	f100 8097 	bmi.w	80071ca <update_iabc+0x362>
	while (hspi->RxXferCount > 0U)
 800709c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80070a0:	b29b      	uxth	r3, r3
 80070a2:	2b00      	cmp	r3, #0
 80070a4:	d1f6      	bne.n	8007094 <update_iabc+0x22c>
	hspi->RxXferCount = 1;
 80070a6:	2101      	movs	r1, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80070a8:	6623      	str	r3, [r4, #96]	; 0x60
	uint8_t temp = 0x00;
 80070aa:	f88d 3007 	strb.w	r3, [sp, #7]
	hspi->RxXferCount = 1;
 80070ae:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
	hspi->TxXferCount = 1;
 80070b2:	87e1      	strh	r1, [r4, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80070b4:	6855      	ldr	r5, [r2, #4]
	miso = buffer2;
 80070b6:	f89d 0006 	ldrb.w	r0, [sp, #6]
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80070ba:	f445 5580 	orr.w	r5, r5, #4096	; 0x1000
	hspi->pTxBuffPtr  = (uint8_t *)&temp;
 80070be:	63a7      	str	r7, [r4, #56]	; 0x38
	hspi->RxXferSize  = 1;
 80070c0:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
	hspi->TxXferSize  = 1;
 80070c4:	87a1      	strh	r1, [r4, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80070c6:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
	hspi->TxISR       = NULL;
 80070ca:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80070ce:	6055      	str	r5, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 80070d0:	7313      	strb	r3, [r2, #12]
	hspi->TxXferCount--;
 80070d2:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 80070d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 80070d6:	3901      	subs	r1, #1
	hspi->pTxBuffPtr++;
 80070d8:	3301      	adds	r3, #1
	hspi->TxXferCount--;
 80070da:	b289      	uxth	r1, r1
	hspi->pTxBuffPtr++;
 80070dc:	63a3      	str	r3, [r4, #56]	; 0x38
	hspi->TxXferCount--;
 80070de:	87e1      	strh	r1, [r4, #62]	; 0x3e
 80070e0:	e015      	b.n	800710e <update_iabc+0x2a6>
 80070e2:	bf00      	nop
 80070e4:	f3af 8000 	nop.w
 80070e8:	cf13af4d 	.word	0xcf13af4d
 80070ec:	bfa768e5 	.word	0xbfa768e5
 80070f0:	1ee9f167 	.word	0x1ee9f167
 80070f4:	bfa7de29 	.word	0xbfa7de29
 80070f8:	200024f8 	.word	0x200024f8
 80070fc:	40020400 	.word	0x40020400
 8007100:	200021cc 	.word	0x200021cc
 8007104:	20069630 	.word	0x20069630
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007108:	6893      	ldr	r3, [r2, #8]
 800710a:	07db      	lsls	r3, r3, #31
 800710c:	d46b      	bmi.n	80071e6 <update_iabc+0x37e>
	while (hspi->RxXferCount > 0U)
 800710e:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8007112:	b29b      	uxth	r3, r3
 8007114:	2b00      	cmp	r3, #0
 8007116:	d1f7      	bne.n	8007108 <update_iabc+0x2a0>
	miso= ((miso<< 8) | buffer2);
 8007118:	f89d 3006 	ldrb.w	r3, [sp, #6]
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 800711c:	2201      	movs	r2, #1
	mc_vars.iabc[2] -= offset_vals[2];
 800711e:	edd9 6a02 	vldr	s13, [r9, #8]
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 8007122:	f44f 7100 	mov.w	r1, #512	; 0x200
	miso= ((miso<< 8) | buffer2);
 8007126:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 800712a:	485f      	ldr	r0, [pc, #380]	; (80072a8 <update_iabc+0x440>)
	miso= ((miso<< 8) | buffer2);
 800712c:	b21b      	sxth	r3, r3
 800712e:	ee07 3a10 	vmov	s14, r3
	mc_vars.iabc[2] = (float) (temp*CURRENT_MULTIPLIER_C);
 8007132:	ed9f 5b5b 	vldr	d5, [pc, #364]	; 80072a0 <update_iabc+0x438>
 8007136:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
 800713a:	ee27 7b05 	vmul.f64	d7, d7, d5
 800713e:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	mc_vars.iabc[2] -= offset_vals[2];
 8007142:	ee37 7a66 	vsub.f32	s14, s14, s13
 8007146:	ed86 7a05 	vstr	s14, [r6, #20]
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 800714a:	f7fa ffe7 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_A_GPIO_Port, IABC_CS_A_Pin, 1);
 800714e:	2201      	movs	r2, #1
 8007150:	2180      	movs	r1, #128	; 0x80
 8007152:	4856      	ldr	r0, [pc, #344]	; (80072ac <update_iabc+0x444>)
 8007154:	f7fa ffe2 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_B_Pin, 1);
 8007158:	2201      	movs	r2, #1
 800715a:	2140      	movs	r1, #64	; 0x40
 800715c:	4853      	ldr	r0, [pc, #332]	; (80072ac <update_iabc+0x444>)
 800715e:	f7fa ffdd 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_C_GPIO_Port, IABC_CS_C_Pin, 1);
 8007162:	2201      	movs	r2, #1
 8007164:	2110      	movs	r1, #16
 8007166:	4851      	ldr	r0, [pc, #324]	; (80072ac <update_iabc+0x444>)
 8007168:	f7fa ffd8 	bl	800211c <HAL_GPIO_WritePin>
	if (absVal(mc_vars.iabc[0]) > IABC_LIMIT) {
 800716c:	ed96 0a03 	vldr	s0, [r6, #12]
 8007170:	f7fe f8d6 	bl	8005320 <absVal>
 8007174:	eddf 7a4e 	vldr	s15, [pc, #312]	; 80072b0 <update_iabc+0x448>
 8007178:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800717c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007180:	f300 8082 	bgt.w	8007288 <update_iabc+0x420>
	if (absVal(mc_vars.iabc[1]) > IABC_LIMIT) {
 8007184:	ed96 0a04 	vldr	s0, [r6, #16]
 8007188:	f7fe f8ca 	bl	8005320 <absVal>
 800718c:	eddf 7a48 	vldr	s15, [pc, #288]	; 80072b0 <update_iabc+0x448>
 8007190:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007194:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007198:	dc6b      	bgt.n	8007272 <update_iabc+0x40a>
	if (absVal(mc_vars.iabc[2]) > IABC_LIMIT) {
 800719a:	ed96 0a05 	vldr	s0, [r6, #20]
 800719e:	f7fe f8bf 	bl	8005320 <absVal>
 80071a2:	eddf 7a43 	vldr	s15, [pc, #268]	; 80072b0 <update_iabc+0x448>
 80071a6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80071aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80071ae:	dd09      	ble.n	80071c4 <update_iabc+0x35c>
		mc_vars.fault_reg1 |= 1 << HIGH_IC_FLAG_BIT;
 80071b0:	f8b6 3070 	ldrh.w	r3, [r6, #112]	; 0x70
		mc_vars.fault_current[2] = mc_vars.iabc[2];
 80071b4:	6972      	ldr	r2, [r6, #20]
		mc_vars.fault_reg1 |= 1 << HIGH_IC_FLAG_BIT;
 80071b6:	f043 0310 	orr.w	r3, r3, #16
		mc_vars.fault_current[2] = mc_vars.iabc[2];
 80071ba:	67f2      	str	r2, [r6, #124]	; 0x7c
		mc_vars.fault_reg1 |= 1 << HIGH_IC_FLAG_BIT;
 80071bc:	f8a6 3070 	strh.w	r3, [r6, #112]	; 0x70
		Error_Handler();
 80071c0:	f7fe fa76 	bl	80056b0 <Error_Handler>
}
 80071c4:	b003      	add	sp, #12
 80071c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80071ca:	7b12      	ldrb	r2, [r2, #12]
 80071cc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80071ce:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 80071d0:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 80071d4:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 80071d6:	3b01      	subs	r3, #1
 80071d8:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 80071da:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 80071dc:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 80071de:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 80071e0:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 80071e4:	e75a      	b.n	800709c <update_iabc+0x234>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80071e6:	7b12      	ldrb	r2, [r2, #12]
 80071e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80071ea:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 80071ec:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 80071f0:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 80071f2:	3b01      	subs	r3, #1
 80071f4:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 80071f6:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 80071f8:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 80071fa:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 80071fc:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8007200:	e785      	b.n	800710e <update_iabc+0x2a6>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007202:	7b12      	ldrb	r2, [r2, #12]
 8007204:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8007206:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 8007208:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 800720c:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 800720e:	3b01      	subs	r3, #1
 8007210:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 8007212:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 8007214:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 8007216:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 8007218:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 800721c:	e655      	b.n	8006eca <update_iabc+0x62>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 800721e:	7b12      	ldrb	r2, [r2, #12]
 8007220:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8007222:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 8007224:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007228:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 800722a:	3b01      	subs	r3, #1
 800722c:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 800722e:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 8007230:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 8007232:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 8007234:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8007238:	e66e      	b.n	8006f18 <update_iabc+0xb0>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 800723a:	7b12      	ldrb	r2, [r2, #12]
 800723c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800723e:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 8007240:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007244:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 8007246:	3b01      	subs	r3, #1
 8007248:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 800724a:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 800724c:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 800724e:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 8007250:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8007254:	e6af      	b.n	8006fb6 <update_iabc+0x14e>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007256:	7b12      	ldrb	r2, [r2, #12]
 8007258:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800725a:	701a      	strb	r2, [r3, #0]
		  hspi->RxXferCount--;
 800725c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007260:	6c21      	ldr	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 8007262:	3b01      	subs	r3, #1
 8007264:	6822      	ldr	r2, [r4, #0]
		  hspi->pRxBuffPtr++;
 8007266:	3101      	adds	r1, #1
		  hspi->RxXferCount--;
 8007268:	b29b      	uxth	r3, r3
		  hspi->pRxBuffPtr++;
 800726a:	6421      	str	r1, [r4, #64]	; 0x40
		  hspi->RxXferCount--;
 800726c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8007270:	e6c8      	b.n	8007004 <update_iabc+0x19c>
		mc_vars.fault_reg1 |= 1 << HIGH_IB_FLAG_BIT;
 8007272:	f8b6 3070 	ldrh.w	r3, [r6, #112]	; 0x70
		mc_vars.fault_current[1] = mc_vars.iabc[1];
 8007276:	6932      	ldr	r2, [r6, #16]
		mc_vars.fault_reg1 |= 1 << HIGH_IB_FLAG_BIT;
 8007278:	f043 0308 	orr.w	r3, r3, #8
		mc_vars.fault_current[1] = mc_vars.iabc[1];
 800727c:	67b2      	str	r2, [r6, #120]	; 0x78
		mc_vars.fault_reg1 |= 1 << HIGH_IB_FLAG_BIT;
 800727e:	f8a6 3070 	strh.w	r3, [r6, #112]	; 0x70
		Error_Handler();
 8007282:	f7fe fa15 	bl	80056b0 <Error_Handler>
 8007286:	e788      	b.n	800719a <update_iabc+0x332>
		mc_vars.fault_reg1 |= 1 << HIGH_IA_FLAG_BIT;
 8007288:	f8b6 3070 	ldrh.w	r3, [r6, #112]	; 0x70
		mc_vars.fault_current[0] = mc_vars.iabc[0];
 800728c:	68f2      	ldr	r2, [r6, #12]
		mc_vars.fault_reg1 |= 1 << HIGH_IA_FLAG_BIT;
 800728e:	f043 0304 	orr.w	r3, r3, #4
		mc_vars.fault_current[0] = mc_vars.iabc[0];
 8007292:	6772      	str	r2, [r6, #116]	; 0x74
		mc_vars.fault_reg1 |= 1 << HIGH_IA_FLAG_BIT;
 8007294:	f8a6 3070 	strh.w	r3, [r6, #112]	; 0x70
		Error_Handler();
 8007298:	f7fe fa0a 	bl	80056b0 <Error_Handler>
 800729c:	e772      	b.n	8007184 <update_iabc+0x31c>
 800729e:	bf00      	nop
 80072a0:	f794fb3b 	.word	0xf794fb3b
 80072a4:	bfa735c5 	.word	0xbfa735c5
 80072a8:	40021800 	.word	0x40021800
 80072ac:	40020400 	.word	0x40020400
 80072b0:	42c80000 	.word	0x42c80000

080072b4 <ho250S_init>:
void ho250S_init(void) {
 80072b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 80072b6:	2201      	movs	r2, #1
 80072b8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80072bc:	483d      	ldr	r0, [pc, #244]	; (80073b4 <ho250S_init+0x100>)
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 80072be:	2480      	movs	r4, #128	; 0x80
		HAL_SPI_Transmit(&hspi6, &dummyData, 1, 100);
 80072c0:	4e3d      	ldr	r6, [pc, #244]	; (80073b8 <ho250S_init+0x104>)
void ho250S_init(void) {
 80072c2:	ed2d 8b04 	vpush	{d8-d9}
 80072c6:	b083      	sub	sp, #12
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 80072c8:	f7fa ff28 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_A_GPIO_Port, IABC_CS_A_Pin, 1);
 80072cc:	2201      	movs	r2, #1
 80072ce:	2180      	movs	r1, #128	; 0x80
 80072d0:	483a      	ldr	r0, [pc, #232]	; (80073bc <ho250S_init+0x108>)
 80072d2:	f7fa ff23 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_B_GPIO_Port, IABC_CS_B_Pin, 1);
 80072d6:	2201      	movs	r2, #1
 80072d8:	2140      	movs	r1, #64	; 0x40
 80072da:	4838      	ldr	r0, [pc, #224]	; (80073bc <ho250S_init+0x108>)
 80072dc:	f7fa ff1e 	bl	800211c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(IABC_CS_C_GPIO_Port, IABC_CS_C_Pin, 1);
 80072e0:	2201      	movs	r2, #1
 80072e2:	2110      	movs	r1, #16
 80072e4:	4835      	ldr	r0, [pc, #212]	; (80073bc <ho250S_init+0x108>)
 80072e6:	f7fa ff19 	bl	800211c <HAL_GPIO_WritePin>
	HAL_Delay(1);
 80072ea:	2001      	movs	r0, #1
 80072ec:	f7f9 f966 	bl	80005bc <HAL_Delay>
	uint16_t dummyData = 0x0000;
 80072f0:	2300      	movs	r3, #0
 80072f2:	ad02      	add	r5, sp, #8
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 80072f4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80072f8:	461a      	mov	r2, r3
 80072fa:	482e      	ldr	r0, [pc, #184]	; (80073b4 <ho250S_init+0x100>)
	uint16_t dummyData = 0x0000;
 80072fc:	f825 3d02 	strh.w	r3, [r5, #-2]!
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 8007300:	f7fa ff0c 	bl	800211c <HAL_GPIO_WritePin>
		HAL_SPI_Transmit(&hspi6, &dummyData, 1, 100);
 8007304:	2364      	movs	r3, #100	; 0x64
 8007306:	2201      	movs	r2, #1
 8007308:	4629      	mov	r1, r5
 800730a:	4630      	mov	r0, r6
 800730c:	f7fb fdec 	bl	8002ee8 <HAL_SPI_Transmit>
	for (int i =0; i<128; i++) {
 8007310:	3c01      	subs	r4, #1
 8007312:	d1f7      	bne.n	8007304 <ho250S_init+0x50>
 8007314:	2405      	movs	r4, #5
		HAL_Delay(100);
 8007316:	2064      	movs	r0, #100	; 0x64
 8007318:	f7f9 f950 	bl	80005bc <HAL_Delay>
	for (int i=0; i<5; i++) {
 800731c:	3c01      	subs	r4, #1
 800731e:	d1fa      	bne.n	8007316 <ho250S_init+0x62>
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 8007320:	2201      	movs	r2, #1
 8007322:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007326:	4823      	ldr	r0, [pc, #140]	; (80073b4 <ho250S_init+0x100>)
		offset_vals[i]=0;
 8007328:	2564      	movs	r5, #100	; 0x64
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 1);
 800732a:	f7fa fef7 	bl	800211c <HAL_GPIO_WritePin>
	HAL_Delay(500);
 800732e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007332:	f7f9 f943 	bl	80005bc <HAL_Delay>
		offset_vals[i]=0;
 8007336:	eddf 7a22 	vldr	s15, [pc, #136]	; 80073c0 <ho250S_init+0x10c>
 800733a:	4f22      	ldr	r7, [pc, #136]	; (80073c4 <ho250S_init+0x110>)
		temp[i] = 0;
 800733c:	eeb0 8a67 	vmov.f32	s16, s15
 8007340:	4c21      	ldr	r4, [pc, #132]	; (80073c8 <ho250S_init+0x114>)
 8007342:	eef0 8a67 	vmov.f32	s17, s15
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 8007346:	4e1b      	ldr	r6, [pc, #108]	; (80073b4 <ho250S_init+0x100>)
		temp[i] = 0;
 8007348:	eeb0 9a67 	vmov.f32	s18, s15
		offset_vals[i]=0;
 800734c:	edc7 7a00 	vstr	s15, [r7]
 8007350:	edc7 7a01 	vstr	s15, [r7, #4]
 8007354:	edc7 7a02 	vstr	s15, [r7, #8]
	HAL_GPIO_WritePin(IABC_CNVST_GPIO_Port, IABC_CNVST_Pin, 0);
 8007358:	2200      	movs	r2, #0
 800735a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800735e:	4630      	mov	r0, r6
 8007360:	f7fa fedc 	bl	800211c <HAL_GPIO_WritePin>
		HAL_Delay(1);
 8007364:	2001      	movs	r0, #1
 8007366:	f7f9 f929 	bl	80005bc <HAL_Delay>
		update_iabc();
 800736a:	f7ff fd7d 	bl	8006e68 <update_iabc>
		temp[0] += mc_vars.iabc[0];
 800736e:	edd4 6a03 	vldr	s13, [r4, #12]
		temp[1] += mc_vars.iabc[1];
 8007372:	ed94 7a04 	vldr	s14, [r4, #16]
		HAL_Delay(1);
 8007376:	2001      	movs	r0, #1
		temp[2] += mc_vars.iabc[2];
 8007378:	edd4 7a05 	vldr	s15, [r4, #20]
		temp[0] += mc_vars.iabc[0];
 800737c:	ee39 9a26 	vadd.f32	s18, s18, s13
		temp[1] += mc_vars.iabc[1];
 8007380:	ee78 8a87 	vadd.f32	s17, s17, s14
		temp[2] += mc_vars.iabc[2];
 8007384:	ee38 8a27 	vadd.f32	s16, s16, s15
		HAL_Delay(1);
 8007388:	f7f9 f918 	bl	80005bc <HAL_Delay>
	for (int i=0; i<100; i++) {
 800738c:	3d01      	subs	r5, #1
 800738e:	d1e3      	bne.n	8007358 <ho250S_init+0xa4>
	offset_vals[0] = temp[0] / 100;
 8007390:	eddf 7a0e 	vldr	s15, [pc, #56]	; 80073cc <ho250S_init+0x118>
 8007394:	ee29 9a27 	vmul.f32	s18, s18, s15
	offset_vals[1] = temp[1] / 100;
 8007398:	ee68 8aa7 	vmul.f32	s17, s17, s15
	offset_vals[2] = temp[2] / 100;
 800739c:	ee28 8a27 	vmul.f32	s16, s16, s15
	offset_vals[0] = temp[0] / 100;
 80073a0:	ed87 9a00 	vstr	s18, [r7]
	offset_vals[1] = temp[1] / 100;
 80073a4:	edc7 8a01 	vstr	s17, [r7, #4]
	offset_vals[2] = temp[2] / 100;
 80073a8:	ed87 8a02 	vstr	s16, [r7, #8]
}
 80073ac:	b003      	add	sp, #12
 80073ae:	ecbd 8b04 	vpop	{d8-d9}
 80073b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80073b4:	40021800 	.word	0x40021800
 80073b8:	200024f8 	.word	0x200024f8
 80073bc:	40020400 	.word	0x40020400
 80073c0:	00000000 	.word	0x00000000
 80073c4:	20069630 	.word	0x20069630
 80073c8:	200021cc 	.word	0x200021cc
 80073cc:	3c23d70a 	.word	0x3c23d70a

080073d0 <hal_Xmit4BSPI>:
	request_velocity();
	ignore_crc_error = FALSE;
}

/* Transmit four bytes */
uint32_t hal_Xmit4BSPI(uint32_t mosi) {
 80073d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80073d4:	4604      	mov	r4, r0
	uint32_t miso = 0; /* in coming data*/
	uint8_t buffer1 = 0;
 80073d6:	2300      	movs	r3, #0
	uint8_t buffer2 = 0;

	/* Send data byte by byte */
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 0);
 80073d8:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 8007488 <hal_Xmit4BSPI+0xb8>
uint32_t hal_Xmit4BSPI(uint32_t mosi) {
 80073dc:	b084      	sub	sp, #16
	miso = buffer2;
	// first byte
	buffer1 = mosi >> 24;
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT); /* most significant byte first */
 80073de:	4d29      	ldr	r5, [pc, #164]	; (8007484 <hal_Xmit4BSPI+0xb4>)
 80073e0:	2664      	movs	r6, #100	; 0x64
	buffer1 = mosi >> 24;
 80073e2:	0e27      	lsrs	r7, r4, #24
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 0);
 80073e4:	461a      	mov	r2, r3
 80073e6:	4648      	mov	r0, r9
 80073e8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
	uint8_t buffer1 = 0;
 80073ec:	f88d 300e 	strb.w	r3, [sp, #14]
	uint8_t buffer2 = 0;
 80073f0:	f88d 300f 	strb.w	r3, [sp, #15]
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 0);
 80073f4:	f7fa fe92 	bl	800211c <HAL_GPIO_WritePin>
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT); /* most significant byte first */
 80073f8:	f10d 020f 	add.w	r2, sp, #15
 80073fc:	f10d 010e 	add.w	r1, sp, #14
	buffer1 = mosi >> 24;
 8007400:	f88d 700e 	strb.w	r7, [sp, #14]
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT); /* most significant byte first */
 8007404:	4628      	mov	r0, r5
	miso = buffer2;

	// second byte
	buffer1 = mosi >> 16;
 8007406:	0c27      	lsrs	r7, r4, #16
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT); /* most significant byte first */
 8007408:	9600      	str	r6, [sp, #0]
 800740a:	2301      	movs	r3, #1
 800740c:	f7fb fe86 	bl	800311c <HAL_SPI_TransmitReceive>
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 8007410:	f10d 020f 	add.w	r2, sp, #15
 8007414:	f10d 010e 	add.w	r1, sp, #14
 8007418:	9600      	str	r6, [sp, #0]
 800741a:	4628      	mov	r0, r5
 800741c:	2301      	movs	r3, #1
	buffer1 = mosi >> 16;
 800741e:	f88d 700e 	strb.w	r7, [sp, #14]
	miso= ((miso<< 8) | buffer2);

	// third byte
	buffer1 = mosi >> 8;
 8007422:	0a27      	lsrs	r7, r4, #8
	miso = buffer2;
 8007424:	f89d a00f 	ldrb.w	sl, [sp, #15]
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 8007428:	f7fb fe78 	bl	800311c <HAL_SPI_TransmitReceive>
	miso= ((miso<< 8) | buffer2);
 800742c:	f89d 800f 	ldrb.w	r8, [sp, #15]
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 8007430:	f10d 020f 	add.w	r2, sp, #15
 8007434:	f10d 010e 	add.w	r1, sp, #14
 8007438:	9600      	str	r6, [sp, #0]
 800743a:	4628      	mov	r0, r5
 800743c:	2301      	movs	r3, #1
	buffer1 = mosi >> 8;
 800743e:	f88d 700e 	strb.w	r7, [sp, #14]
	miso= ((miso<< 8) | buffer2);
 8007442:	ea48 280a 	orr.w	r8, r8, sl, lsl #8
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 8007446:	f7fb fe69 	bl	800311c <HAL_SPI_TransmitReceive>
	miso= ((miso<< 8) | buffer2);
 800744a:	f89d 700f 	ldrb.w	r7, [sp, #15]

	// last byte
	buffer1 = mosi;
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 800744e:	f10d 020f 	add.w	r2, sp, #15
 8007452:	f10d 010e 	add.w	r1, sp, #14
 8007456:	2301      	movs	r3, #1
 8007458:	9600      	str	r6, [sp, #0]
 800745a:	4628      	mov	r0, r5
	buffer1 = mosi;
 800745c:	f88d 400e 	strb.w	r4, [sp, #14]
	miso= ((miso<< 8) | buffer2);
 8007460:	ea47 2708 	orr.w	r7, r7, r8, lsl #8
	HAL_SPI_TransmitReceive(&hspi2,&buffer1,&buffer2,ONE_BYTE,TIME_OUT);
 8007464:	f7fb fe5a 	bl	800311c <HAL_SPI_TransmitReceive>
	miso= ((miso<< 8) | buffer2);
 8007468:	f89d 400f 	ldrb.w	r4, [sp, #15]
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 1);
 800746c:	4648      	mov	r0, r9
 800746e:	2201      	movs	r2, #1
	miso= ((miso<< 8) | buffer2);
 8007470:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 1);
 8007474:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8007478:	f7fa fe50 	bl	800211c <HAL_GPIO_WritePin>

	// NCS needs to be high for at least 200 ns

	return(miso);
}
 800747c:	4620      	mov	r0, r4
 800747e:	b004      	add	sp, #16
 8007480:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007484:	20002350 	.word	0x20002350
 8007488:	40020400 	.word	0x40020400

0800748c <pga411_XmitSPI.isra.0.constprop.5>:
	out.frame = out.addr;
 800748c:	b2c9      	uxtb	r1, r1
	out.frame = out.frame << 16;
 800748e:	040a      	lsls	r2, r1, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8007490:	0c93      	lsrs	r3, r2, #18
             crc <<= 1;
 8007492:	005b      	lsls	r3, r3, #1
 8007494:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
pga411_spi_frame_t pga411_XmitSPI(uint16_t dir,pga411_regs_t reg,uint16_t wdata) {
 8007498:	b570      	push	{r4, r5, r6, lr}
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800749a:	065e      	lsls	r6, r3, #25
pga411_spi_frame_t pga411_XmitSPI(uint16_t dir,pga411_regs_t reg,uint16_t wdata) {
 800749c:	4604      	mov	r4, r0
 800749e:	bf48      	it	mi
 80074a0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80074a4:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074a6:	065d      	lsls	r5, r3, #25
 80074a8:	d502      	bpl.n	80074b0 <pga411_XmitSPI.isra.0.constprop.5+0x24>
 80074aa:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80074ae:	b29b      	uxth	r3, r3
             crc <<= 1;
 80074b0:	005b      	lsls	r3, r3, #1
 80074b2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074b4:	0658      	lsls	r0, r3, #25
 80074b6:	bf48      	it	mi
 80074b8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80074bc:	005b      	lsls	r3, r3, #1
 80074be:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074c0:	065e      	lsls	r6, r3, #25
 80074c2:	bf48      	it	mi
 80074c4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80074c8:	005b      	lsls	r3, r3, #1
 80074ca:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074cc:	065d      	lsls	r5, r3, #25
 80074ce:	bf48      	it	mi
 80074d0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80074d4:	005b      	lsls	r3, r3, #1
 80074d6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074d8:	0658      	lsls	r0, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80074da:	ea4f 3012 	mov.w	r0, r2, lsr #12
 80074de:	bf48      	it	mi
 80074e0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 80074e4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 80074e8:	4058      	eors	r0, r3
             crc <<= 1;
 80074ea:	0040      	lsls	r0, r0, #1
 80074ec:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074ee:	0642      	lsls	r2, r0, #25
 80074f0:	bf48      	it	mi
 80074f2:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 80074f6:	0040      	lsls	r0, r0, #1
 80074f8:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80074fa:	0643      	lsls	r3, r0, #25
 80074fc:	bf48      	it	mi
 80074fe:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007502:	0040      	lsls	r0, r0, #1
 8007504:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007506:	0646      	lsls	r6, r0, #25
 8007508:	bf48      	it	mi
 800750a:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800750e:	0040      	lsls	r0, r0, #1
 8007510:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007512:	0645      	lsls	r5, r0, #25
 8007514:	bf48      	it	mi
 8007516:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800751a:	0040      	lsls	r0, r0, #1
 800751c:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800751e:	0642      	lsls	r2, r0, #25
 8007520:	bf48      	it	mi
 8007522:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007526:	0040      	lsls	r0, r0, #1
 8007528:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800752a:	0643      	lsls	r3, r0, #25
 800752c:	bf48      	it	mi
 800752e:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007532:	0040      	lsls	r0, r0, #1
 8007534:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007536:	0646      	lsls	r6, r0, #25
 8007538:	bf48      	it	mi
 800753a:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800753e:	0040      	lsls	r0, r0, #1
 8007540:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007542:	0645      	lsls	r5, r0, #25
 8007544:	bf48      	it	mi
 8007546:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800754a:	0040      	lsls	r0, r0, #1
 800754c:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800754e:	0642      	lsls	r2, r0, #25
 8007550:	bf48      	it	mi
 8007552:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007556:	0040      	lsls	r0, r0, #1
 8007558:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800755a:	0643      	lsls	r3, r0, #25
 800755c:	bf48      	it	mi
 800755e:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007562:	0040      	lsls	r0, r0, #1
 8007564:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007566:	0646      	lsls	r6, r0, #25
 8007568:	bf48      	it	mi
 800756a:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800756e:	0040      	lsls	r0, r0, #1
 8007570:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007572:	0645      	lsls	r5, r0, #25
 8007574:	bf48      	it	mi
 8007576:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800757a:	0040      	lsls	r0, r0, #1
 800757c:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800757e:	0642      	lsls	r2, r0, #25
 8007580:	bf48      	it	mi
 8007582:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007586:	0040      	lsls	r0, r0, #1
 8007588:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800758a:	0643      	lsls	r3, r0, #25
 800758c:	bf48      	it	mi
 800758e:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 8007592:	0040      	lsls	r0, r0, #1
 8007594:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007596:	0646      	lsls	r6, r0, #25
 8007598:	bf48      	it	mi
 800759a:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 800759e:	0040      	lsls	r0, r0, #1
 80075a0:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075a2:	0645      	lsls	r5, r0, #25
 80075a4:	bf48      	it	mi
 80075a6:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 80075aa:	0040      	lsls	r0, r0, #1
 80075ac:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075ae:	0642      	lsls	r2, r0, #25
 80075b0:	bf48      	it	mi
 80075b2:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
             crc <<= 1;
 80075b6:	0040      	lsls	r0, r0, #1
 80075b8:	b280      	uxth	r0, r0
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075ba:	0643      	lsls	r3, r0, #25
 80075bc:	bf48      	it	mi
 80075be:	f080 005b 	eormi.w	r0, r0, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 80075c2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 80075c6:	ea40 6001 	orr.w	r0, r0, r1, lsl #24
 80075ca:	f7ff ff01 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 80075ce:	f000 013f 	and.w	r1, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 80075d2:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 80075d4:	0a02      	lsrs	r2, r0, #8
             crc <<= 1;
 80075d6:	005b      	lsls	r3, r3, #1
 80075d8:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075dc:	065e      	lsls	r6, r3, #25
 80075de:	bf48      	it	mi
 80075e0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80075e4:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075e6:	065d      	lsls	r5, r3, #25
 80075e8:	d502      	bpl.n	80075f0 <pga411_XmitSPI.isra.0.constprop.5+0x164>
 80075ea:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80075ee:	b29b      	uxth	r3, r3
             crc <<= 1;
 80075f0:	005b      	lsls	r3, r3, #1
 80075f2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80075f4:	065e      	lsls	r6, r3, #25
 80075f6:	bf48      	it	mi
 80075f8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80075fc:	005b      	lsls	r3, r3, #1
 80075fe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007600:	065d      	lsls	r5, r3, #25
 8007602:	bf48      	it	mi
 8007604:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007608:	005b      	lsls	r3, r3, #1
 800760a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800760c:	065e      	lsls	r6, r3, #25
 800760e:	bf48      	it	mi
 8007610:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007614:	005b      	lsls	r3, r3, #1
 8007616:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007618:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 800761a:	f3c0 5505 	ubfx	r5, r0, #20, #6
 800761e:	bf48      	it	mi
 8007620:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8007624:	406b      	eors	r3, r5
             crc <<= 1;
 8007626:	005b      	lsls	r3, r3, #1
 8007628:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800762a:	065e      	lsls	r6, r3, #25
 800762c:	bf48      	it	mi
 800762e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007632:	005b      	lsls	r3, r3, #1
 8007634:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007636:	065d      	lsls	r5, r3, #25
 8007638:	bf48      	it	mi
 800763a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800763e:	005b      	lsls	r3, r3, #1
 8007640:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007642:	065e      	lsls	r6, r3, #25
 8007644:	bf48      	it	mi
 8007646:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800764a:	005b      	lsls	r3, r3, #1
 800764c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800764e:	065d      	lsls	r5, r3, #25
 8007650:	bf48      	it	mi
 8007652:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007656:	005b      	lsls	r3, r3, #1
 8007658:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800765a:	065e      	lsls	r6, r3, #25
 800765c:	bf48      	it	mi
 800765e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007662:	005b      	lsls	r3, r3, #1
 8007664:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007666:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007668:	f3c0 3585 	ubfx	r5, r0, #14, #6
	in.addr = in.frame >> 16;
 800766c:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8007670:	bf48      	it	mi
 8007672:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007676:	406b      	eors	r3, r5
             crc <<= 1;
 8007678:	005b      	lsls	r3, r3, #1
 800767a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800767c:	065e      	lsls	r6, r3, #25
 800767e:	bf48      	it	mi
 8007680:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007684:	005b      	lsls	r3, r3, #1
 8007686:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007688:	065d      	lsls	r5, r3, #25
 800768a:	bf48      	it	mi
 800768c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007690:	005b      	lsls	r3, r3, #1
 8007692:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007694:	065e      	lsls	r6, r3, #25
 8007696:	bf48      	it	mi
 8007698:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800769c:	005b      	lsls	r3, r3, #1
 800769e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076a0:	065d      	lsls	r5, r3, #25
 80076a2:	bf48      	it	mi
 80076a4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076a8:	005b      	lsls	r3, r3, #1
 80076aa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076ac:	065e      	lsls	r6, r3, #25
 80076ae:	bf48      	it	mi
 80076b0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076b4:	005b      	lsls	r3, r3, #1
 80076b6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076b8:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80076ba:	b295      	uxth	r5, r2
 80076bc:	bf48      	it	mi
 80076be:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 80076c2:	f005 063f 	and.w	r6, r5, #63	; 0x3f
 80076c6:	4073      	eors	r3, r6
             crc <<= 1;
 80076c8:	005b      	lsls	r3, r3, #1
 80076ca:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076cc:	065e      	lsls	r6, r3, #25
 80076ce:	bf48      	it	mi
 80076d0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076d4:	005b      	lsls	r3, r3, #1
 80076d6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076d8:	065e      	lsls	r6, r3, #25
 80076da:	bf48      	it	mi
 80076dc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076e0:	005b      	lsls	r3, r3, #1
 80076e2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076e4:	065e      	lsls	r6, r3, #25
 80076e6:	bf48      	it	mi
 80076e8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076ec:	005b      	lsls	r3, r3, #1
 80076ee:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076f0:	065e      	lsls	r6, r3, #25
 80076f2:	bf48      	it	mi
 80076f4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80076f8:	005b      	lsls	r3, r3, #1
 80076fa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80076fc:	065e      	lsls	r6, r3, #25
 80076fe:	bf48      	it	mi
 8007700:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007704:	005b      	lsls	r3, r3, #1
 8007706:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007708:	065e      	lsls	r6, r3, #25
 800770a:	bf48      	it	mi
 800770c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8007710:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8007714:	428b      	cmp	r3, r1
 8007716:	d000      	beq.n	800771a <pga411_XmitSPI.isra.0.constprop.5+0x28e>
		asm("NOP"); /* if error -> terminate */
 8007718:	bf00      	nop
	return in;
 800771a:	7020      	strb	r0, [r4, #0]
}
 800771c:	4620      	mov	r0, r4
	return in;
 800771e:	71a1      	strb	r1, [r4, #6]
 8007720:	8125      	strh	r5, [r4, #8]
 8007722:	60e2      	str	r2, [r4, #12]
}
 8007724:	bd70      	pop	{r4, r5, r6, pc}
 8007726:	bf00      	nop

08007728 <pga411_XmitSPI.isra.0.constprop.6>:
	out.frame = out.addr;
 8007728:	b2d2      	uxtb	r2, r2
	out.frame ^= (out.dataout & 0x00FFFF);
 800772a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
           crc ^= (datin >> byte_idx) & 0x3F;
 800772e:	0c9a      	lsrs	r2, r3, #18
             crc <<= 1;
 8007730:	0052      	lsls	r2, r2, #1
 8007732:	f082 027e 	eor.w	r2, r2, #126	; 0x7e
pga411_spi_frame_t pga411_XmitSPI(uint16_t dir,pga411_regs_t reg,uint16_t wdata) {
 8007736:	b570      	push	{r4, r5, r6, lr}
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007738:	0656      	lsls	r6, r2, #25
pga411_spi_frame_t pga411_XmitSPI(uint16_t dir,pga411_regs_t reg,uint16_t wdata) {
 800773a:	4604      	mov	r4, r0
 800773c:	bf48      	it	mi
 800773e:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007742:	0052      	lsls	r2, r2, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007744:	0655      	lsls	r5, r2, #25
 8007746:	d502      	bpl.n	800774e <pga411_XmitSPI.isra.0.constprop.6+0x26>
 8007748:	f082 025b 	eor.w	r2, r2, #91	; 0x5b
 800774c:	b292      	uxth	r2, r2
             crc <<= 1;
 800774e:	0052      	lsls	r2, r2, #1
 8007750:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007752:	0650      	lsls	r0, r2, #25
 8007754:	bf48      	it	mi
 8007756:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 800775a:	0052      	lsls	r2, r2, #1
 800775c:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800775e:	0651      	lsls	r1, r2, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007760:	f3c3 3105 	ubfx	r1, r3, #12, #6
 8007764:	bf48      	it	mi
 8007766:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 800776a:	0052      	lsls	r2, r2, #1
 800776c:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800776e:	0656      	lsls	r6, r2, #25
 8007770:	bf48      	it	mi
 8007772:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007776:	0052      	lsls	r2, r2, #1
 8007778:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800777a:	0655      	lsls	r5, r2, #25
 800777c:	bf48      	it	mi
 800777e:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007782:	404a      	eors	r2, r1
             crc <<= 1;
 8007784:	0052      	lsls	r2, r2, #1
 8007786:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007788:	0650      	lsls	r0, r2, #25
 800778a:	bf48      	it	mi
 800778c:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007790:	0052      	lsls	r2, r2, #1
 8007792:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007794:	0651      	lsls	r1, r2, #25
 8007796:	bf48      	it	mi
 8007798:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 800779c:	0052      	lsls	r2, r2, #1
 800779e:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077a0:	0656      	lsls	r6, r2, #25
 80077a2:	bf48      	it	mi
 80077a4:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077a8:	0052      	lsls	r2, r2, #1
 80077aa:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077ac:	0655      	lsls	r5, r2, #25
 80077ae:	bf48      	it	mi
 80077b0:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077b4:	0052      	lsls	r2, r2, #1
 80077b6:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077b8:	0650      	lsls	r0, r2, #25
 80077ba:	bf48      	it	mi
 80077bc:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077c0:	0052      	lsls	r2, r2, #1
 80077c2:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077c4:	0651      	lsls	r1, r2, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80077c6:	f3c3 1185 	ubfx	r1, r3, #6, #6
 80077ca:	bf48      	it	mi
 80077cc:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
 80077d0:	404a      	eors	r2, r1
             crc <<= 1;
 80077d2:	0052      	lsls	r2, r2, #1
 80077d4:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077d6:	0656      	lsls	r6, r2, #25
 80077d8:	bf48      	it	mi
 80077da:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077de:	0052      	lsls	r2, r2, #1
 80077e0:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077e2:	0655      	lsls	r5, r2, #25
 80077e4:	bf48      	it	mi
 80077e6:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077ea:	0052      	lsls	r2, r2, #1
 80077ec:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077ee:	0650      	lsls	r0, r2, #25
 80077f0:	bf48      	it	mi
 80077f2:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80077f6:	0052      	lsls	r2, r2, #1
 80077f8:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80077fa:	0651      	lsls	r1, r2, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80077fc:	f003 013f 	and.w	r1, r3, #63	; 0x3f
 8007800:	bf48      	it	mi
 8007802:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007806:	0052      	lsls	r2, r2, #1
 8007808:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800780a:	0656      	lsls	r6, r2, #25
 800780c:	bf48      	it	mi
 800780e:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007812:	0052      	lsls	r2, r2, #1
 8007814:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007816:	0655      	lsls	r5, r2, #25
 8007818:	bf48      	it	mi
 800781a:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 800781e:	404a      	eors	r2, r1
             crc <<= 1;
 8007820:	0052      	lsls	r2, r2, #1
 8007822:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007824:	0650      	lsls	r0, r2, #25
 8007826:	bf48      	it	mi
 8007828:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 800782c:	0052      	lsls	r2, r2, #1
 800782e:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007830:	0651      	lsls	r1, r2, #25
 8007832:	bf48      	it	mi
 8007834:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007838:	0052      	lsls	r2, r2, #1
 800783a:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800783c:	0656      	lsls	r6, r2, #25
 800783e:	bf48      	it	mi
 8007840:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007844:	0052      	lsls	r2, r2, #1
 8007846:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007848:	0655      	lsls	r5, r2, #25
 800784a:	bf48      	it	mi
 800784c:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8007850:	0052      	lsls	r2, r2, #1
 8007852:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007854:	0650      	lsls	r0, r2, #25
 8007856:	bf48      	it	mi
 8007858:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 800785c:	0052      	lsls	r2, r2, #1
 800785e:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007860:	0651      	lsls	r1, r2, #25
 8007862:	bf48      	it	mi
 8007864:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 8007868:	f002 003f 	and.w	r0, r2, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 800786c:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8007870:	f7ff fdae 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8007874:	f000 013f 	and.w	r1, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 8007878:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 800787a:	0a02      	lsrs	r2, r0, #8
             crc <<= 1;
 800787c:	005b      	lsls	r3, r3, #1
 800787e:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007882:	065e      	lsls	r6, r3, #25
 8007884:	bf48      	it	mi
 8007886:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800788a:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800788c:	065d      	lsls	r5, r3, #25
 800788e:	d502      	bpl.n	8007896 <pga411_XmitSPI.isra.0.constprop.6+0x16e>
 8007890:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8007894:	b29b      	uxth	r3, r3
             crc <<= 1;
 8007896:	005b      	lsls	r3, r3, #1
 8007898:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800789a:	065e      	lsls	r6, r3, #25
 800789c:	bf48      	it	mi
 800789e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078a2:	005b      	lsls	r3, r3, #1
 80078a4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078a6:	065d      	lsls	r5, r3, #25
 80078a8:	bf48      	it	mi
 80078aa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078ae:	005b      	lsls	r3, r3, #1
 80078b0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078b2:	065e      	lsls	r6, r3, #25
 80078b4:	bf48      	it	mi
 80078b6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078ba:	005b      	lsls	r3, r3, #1
 80078bc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078be:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80078c0:	f3c0 5505 	ubfx	r5, r0, #20, #6
 80078c4:	bf48      	it	mi
 80078c6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 80078ca:	406b      	eors	r3, r5
             crc <<= 1;
 80078cc:	005b      	lsls	r3, r3, #1
 80078ce:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078d0:	065e      	lsls	r6, r3, #25
 80078d2:	bf48      	it	mi
 80078d4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078d8:	005b      	lsls	r3, r3, #1
 80078da:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078dc:	065d      	lsls	r5, r3, #25
 80078de:	bf48      	it	mi
 80078e0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078e4:	005b      	lsls	r3, r3, #1
 80078e6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078e8:	065e      	lsls	r6, r3, #25
 80078ea:	bf48      	it	mi
 80078ec:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078f0:	005b      	lsls	r3, r3, #1
 80078f2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80078f4:	065d      	lsls	r5, r3, #25
 80078f6:	bf48      	it	mi
 80078f8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80078fc:	005b      	lsls	r3, r3, #1
 80078fe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007900:	065e      	lsls	r6, r3, #25
 8007902:	bf48      	it	mi
 8007904:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007908:	005b      	lsls	r3, r3, #1
 800790a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800790c:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 800790e:	f3c0 3585 	ubfx	r5, r0, #14, #6
	in.addr = in.frame >> 16;
 8007912:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8007916:	bf48      	it	mi
 8007918:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 800791c:	406b      	eors	r3, r5
             crc <<= 1;
 800791e:	005b      	lsls	r3, r3, #1
 8007920:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007922:	065e      	lsls	r6, r3, #25
 8007924:	bf48      	it	mi
 8007926:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800792a:	005b      	lsls	r3, r3, #1
 800792c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800792e:	065d      	lsls	r5, r3, #25
 8007930:	bf48      	it	mi
 8007932:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007936:	005b      	lsls	r3, r3, #1
 8007938:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800793a:	065e      	lsls	r6, r3, #25
 800793c:	bf48      	it	mi
 800793e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007942:	005b      	lsls	r3, r3, #1
 8007944:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007946:	065d      	lsls	r5, r3, #25
 8007948:	bf48      	it	mi
 800794a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800794e:	005b      	lsls	r3, r3, #1
 8007950:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007952:	065e      	lsls	r6, r3, #25
 8007954:	bf48      	it	mi
 8007956:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800795a:	005b      	lsls	r3, r3, #1
 800795c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800795e:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007960:	b295      	uxth	r5, r2
 8007962:	bf48      	it	mi
 8007964:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8007968:	f005 063f 	and.w	r6, r5, #63	; 0x3f
 800796c:	4073      	eors	r3, r6
             crc <<= 1;
 800796e:	005b      	lsls	r3, r3, #1
 8007970:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007972:	065e      	lsls	r6, r3, #25
 8007974:	bf48      	it	mi
 8007976:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800797a:	005b      	lsls	r3, r3, #1
 800797c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800797e:	065e      	lsls	r6, r3, #25
 8007980:	bf48      	it	mi
 8007982:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007986:	005b      	lsls	r3, r3, #1
 8007988:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800798a:	065e      	lsls	r6, r3, #25
 800798c:	bf48      	it	mi
 800798e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007992:	005b      	lsls	r3, r3, #1
 8007994:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007996:	065e      	lsls	r6, r3, #25
 8007998:	bf48      	it	mi
 800799a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800799e:	005b      	lsls	r3, r3, #1
 80079a0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80079a2:	065e      	lsls	r6, r3, #25
 80079a4:	bf48      	it	mi
 80079a6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80079aa:	005b      	lsls	r3, r3, #1
 80079ac:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80079ae:	065e      	lsls	r6, r3, #25
 80079b0:	bf48      	it	mi
 80079b2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 80079b6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80079ba:	428b      	cmp	r3, r1
 80079bc:	d000      	beq.n	80079c0 <pga411_XmitSPI.isra.0.constprop.6+0x298>
		asm("NOP"); /* if error -> terminate */
 80079be:	bf00      	nop
	return in;
 80079c0:	7020      	strb	r0, [r4, #0]
}
 80079c2:	4620      	mov	r0, r4
	return in;
 80079c4:	71a1      	strb	r1, [r4, #6]
 80079c6:	8125      	strh	r5, [r4, #8]
 80079c8:	60e2      	str	r2, [r4, #12]
}
 80079ca:	bd70      	pop	{r4, r5, r6, pc}

080079cc <fast_txrx>:
}

/*
 * Send and recieve 4 bytes (32 bits - the size of the frame sent to/from the PGA411)
 */
uint32_t fast_txrx(uint32_t mosi) {
 80079cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t miso = 0; /* in coming data*/
	uint8_t buffer1 = 0;
 80079ce:	2400      	movs	r4, #0
uint32_t fast_txrx(uint32_t mosi) {
 80079d0:	b083      	sub	sp, #12
 80079d2:	4605      	mov	r5, r0
	uint8_t buffer2 = 0;
	uint8_t crc_in,crc_calc;

	/* Send data byte by byte */
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 0);
 80079d4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80079d8:	4622      	mov	r2, r4
 80079da:	48b3      	ldr	r0, [pc, #716]	; (8007ca8 <fast_txrx+0x2dc>)
	uint8_t buffer1 = 0;
 80079dc:	f88d 4006 	strb.w	r4, [sp, #6]
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80079e0:	f10d 0607 	add.w	r6, sp, #7
	uint8_t buffer2 = 0;
 80079e4:	f88d 4007 	strb.w	r4, [sp, #7]
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 0);
 80079e8:	f7fa fb98 	bl	800211c <HAL_GPIO_WritePin>
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80079ec:	4baf      	ldr	r3, [pc, #700]	; (8007cac <fast_txrx+0x2e0>)
	hspi->RxXferCount = ONE_BYTE;
 80079ee:	2101      	movs	r1, #1
	miso = buffer2;
	// first byte
	buffer1 = mosi >> 24;
 80079f0:	ea4f 6c15 	mov.w	ip, r5, lsr #24
	hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80079f4:	f10d 0006 	add.w	r0, sp, #6
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80079f8:	681a      	ldr	r2, [r3, #0]
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80079fa:	661c      	str	r4, [r3, #96]	; 0x60
	hspi->RxXferCount = ONE_BYTE;
 80079fc:	f8a3 1046 	strh.w	r1, [r3, #70]	; 0x46
	hspi->TxXferCount = ONE_BYTE;
 8007a00:	87d9      	strh	r1, [r3, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a02:	6857      	ldr	r7, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8007a04:	6398      	str	r0, [r3, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a06:	f447 5780 	orr.w	r7, r7, #4096	; 0x1000
	hspi->RxISR       = NULL;
 8007a0a:	64dc      	str	r4, [r3, #76]	; 0x4c
	hspi->TxISR       = NULL;
 8007a0c:	651c      	str	r4, [r3, #80]	; 0x50
	hspi->RxXferSize  = ONE_BYTE;
 8007a0e:	f8a3 1044 	strh.w	r1, [r3, #68]	; 0x44
	hspi->TxXferSize  = ONE_BYTE;
 8007a12:	8799      	strh	r1, [r3, #60]	; 0x3c
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8007a14:	641e      	str	r6, [r3, #64]	; 0x40
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a16:	6057      	str	r7, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8007a18:	f882 c00c 	strb.w	ip, [r2, #12]
	hspi->TxXferCount--;
 8007a1c:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8007a1e:	6b9c      	ldr	r4, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007a20:	3901      	subs	r1, #1
	buffer1 = mosi >> 24;
 8007a22:	f88d c006 	strb.w	ip, [sp, #6]
	hspi->pTxBuffPtr++;
 8007a26:	3401      	adds	r4, #1
	hspi->TxXferCount--;
 8007a28:	b289      	uxth	r1, r1
	hspi->pTxBuffPtr++;
 8007a2a:	639c      	str	r4, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007a2c:	87d9      	strh	r1, [r3, #62]	; 0x3e
 8007a2e:	e003      	b.n	8007a38 <fast_txrx+0x6c>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007a30:	6891      	ldr	r1, [r2, #8]
 8007a32:	07cf      	lsls	r7, r1, #31
 8007a34:	f100 812a 	bmi.w	8007c8c <fast_txrx+0x2c0>
	while (hspi->RxXferCount > 0U)
 8007a38:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8007a3c:	b289      	uxth	r1, r1
 8007a3e:	2900      	cmp	r1, #0
 8007a40:	d1f6      	bne.n	8007a30 <fast_txrx+0x64>
	hspi->RxXferCount = ONE_BYTE;
 8007a42:	2401      	movs	r4, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8007a44:	6619      	str	r1, [r3, #96]	; 0x60
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8007a46:	641e      	str	r6, [r3, #64]	; 0x40
	hspi->RxXferCount = ONE_BYTE;
 8007a48:	f8a3 4046 	strh.w	r4, [r3, #70]	; 0x46
	hspi->TxXferCount = ONE_BYTE;
 8007a4c:	87dc      	strh	r4, [r3, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a4e:	6857      	ldr	r7, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8007a50:	6398      	str	r0, [r3, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a52:	f447 5780 	orr.w	r7, r7, #4096	; 0x1000
	hspi->RxXferSize  = ONE_BYTE;
 8007a56:	f8a3 4044 	strh.w	r4, [r3, #68]	; 0x44
	hspi->TxXferSize  = ONE_BYTE;
 8007a5a:	879c      	strh	r4, [r3, #60]	; 0x3c
	spi_txrx_byte(&hspi2,&buffer1,&buffer2); /* most significant byte first */
	miso = buffer2;

	// second byte
	buffer1 = mosi >> 16;
 8007a5c:	f88d 1006 	strb.w	r1, [sp, #6]
	miso = buffer2;
 8007a60:	f89d c007 	ldrb.w	ip, [sp, #7]
	hspi->TxISR       = NULL;
 8007a64:	e9c3 1113 	strd	r1, r1, [r3, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a68:	6057      	str	r7, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8007a6a:	7311      	strb	r1, [r2, #12]
	hspi->TxXferCount--;
 8007a6c:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8007a6e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007a70:	3c01      	subs	r4, #1
	hspi->pTxBuffPtr++;
 8007a72:	3701      	adds	r7, #1
	hspi->TxXferCount--;
 8007a74:	b2a1      	uxth	r1, r4
	hspi->pTxBuffPtr++;
 8007a76:	639f      	str	r7, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007a78:	87d9      	strh	r1, [r3, #62]	; 0x3e
 8007a7a:	e003      	b.n	8007a84 <fast_txrx+0xb8>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007a7c:	6891      	ldr	r1, [r2, #8]
 8007a7e:	07cc      	lsls	r4, r1, #31
 8007a80:	f100 8118 	bmi.w	8007cb4 <fast_txrx+0x2e8>
	while (hspi->RxXferCount > 0U)
 8007a84:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8007a88:	b289      	uxth	r1, r1
 8007a8a:	2900      	cmp	r1, #0
 8007a8c:	d1f6      	bne.n	8007a7c <fast_txrx+0xb0>
	hspi->RxXferCount = ONE_BYTE;
 8007a8e:	2401      	movs	r4, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8007a90:	6619      	str	r1, [r3, #96]	; 0x60
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8007a92:	641e      	str	r6, [r3, #64]	; 0x40
	hspi->RxXferCount = ONE_BYTE;
 8007a94:	f8a3 4046 	strh.w	r4, [r3, #70]	; 0x46
	hspi->TxXferCount = ONE_BYTE;
 8007a98:	87dc      	strh	r4, [r3, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a9a:	6857      	ldr	r7, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8007a9c:	6398      	str	r0, [r3, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007a9e:	f447 5780 	orr.w	r7, r7, #4096	; 0x1000
	hspi->RxXferSize  = ONE_BYTE;
 8007aa2:	f8a3 4044 	strh.w	r4, [r3, #68]	; 0x44
	hspi->TxXferSize  = ONE_BYTE;
 8007aa6:	879c      	strh	r4, [r3, #60]	; 0x3c
	spi_txrx_byte(&hspi2,&buffer1,&buffer2);
	miso= ((miso<< 8) | buffer2);

	// third byte
	buffer1 = mosi >> 8;
 8007aa8:	f88d 1006 	strb.w	r1, [sp, #6]
	miso= ((miso<< 8) | buffer2);
 8007aac:	f89d e007 	ldrb.w	lr, [sp, #7]
	hspi->TxISR       = NULL;
 8007ab0:	e9c3 1113 	strd	r1, r1, [r3, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007ab4:	6057      	str	r7, [r2, #4]
	miso= ((miso<< 8) | buffer2);
 8007ab6:	ea4e 2c0c 	orr.w	ip, lr, ip, lsl #8
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8007aba:	7311      	strb	r1, [r2, #12]
	hspi->TxXferCount--;
 8007abc:	8fdf      	ldrh	r7, [r3, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8007abe:	6b9c      	ldr	r4, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007ac0:	3f01      	subs	r7, #1
	hspi->pTxBuffPtr++;
 8007ac2:	3401      	adds	r4, #1
	hspi->TxXferCount--;
 8007ac4:	b2b9      	uxth	r1, r7
	hspi->pTxBuffPtr++;
 8007ac6:	639c      	str	r4, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007ac8:	87d9      	strh	r1, [r3, #62]	; 0x3e
 8007aca:	e003      	b.n	8007ad4 <fast_txrx+0x108>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007acc:	6891      	ldr	r1, [r2, #8]
 8007ace:	07c9      	lsls	r1, r1, #31
 8007ad0:	f100 80fe 	bmi.w	8007cd0 <fast_txrx+0x304>
	while (hspi->RxXferCount > 0U)
 8007ad4:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8007ad8:	b289      	uxth	r1, r1
 8007ada:	2900      	cmp	r1, #0
 8007adc:	d1f6      	bne.n	8007acc <fast_txrx+0x100>
	hspi->RxXferCount = ONE_BYTE;
 8007ade:	2401      	movs	r4, #1
	hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8007ae0:	6619      	str	r1, [r3, #96]	; 0x60
	hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8007ae2:	641e      	str	r6, [r3, #64]	; 0x40
	spi_txrx_byte(&hspi2,&buffer1,&buffer2);
	miso= ((miso<< 8) | buffer2);

	// last byte
	buffer1 = mosi;
 8007ae4:	b2ed      	uxtb	r5, r5
	hspi->RxXferCount = ONE_BYTE;
 8007ae6:	f8a3 4046 	strh.w	r4, [r3, #70]	; 0x46
	hspi->TxXferCount = ONE_BYTE;
 8007aea:	87dc      	strh	r4, [r3, #62]	; 0x3e
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007aec:	6856      	ldr	r6, [r2, #4]
	hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8007aee:	6398      	str	r0, [r3, #56]	; 0x38
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007af0:	f446 5680 	orr.w	r6, r6, #4096	; 0x1000
	hspi->RxXferSize  = ONE_BYTE;
 8007af4:	f8a3 4044 	strh.w	r4, [r3, #68]	; 0x44
	hspi->TxXferSize  = ONE_BYTE;
 8007af8:	879c      	strh	r4, [r3, #60]	; 0x3c
	miso= ((miso<< 8) | buffer2);
 8007afa:	f89d 4007 	ldrb.w	r4, [sp, #7]
	buffer1 = mosi;
 8007afe:	f88d 5006 	strb.w	r5, [sp, #6]
	miso= ((miso<< 8) | buffer2);
 8007b02:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
	hspi->TxISR       = NULL;
 8007b06:	e9c3 1113 	strd	r1, r1, [r3, #76]	; 0x4c
	SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8007b0a:	6056      	str	r6, [r2, #4]
	*(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8007b0c:	7315      	strb	r5, [r2, #12]
	hspi->TxXferCount--;
 8007b0e:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
	hspi->pTxBuffPtr++;
 8007b10:	6b98      	ldr	r0, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007b12:	3901      	subs	r1, #1
	hspi->pTxBuffPtr++;
 8007b14:	3001      	adds	r0, #1
	hspi->TxXferCount--;
 8007b16:	b289      	uxth	r1, r1
	hspi->pTxBuffPtr++;
 8007b18:	6398      	str	r0, [r3, #56]	; 0x38
	hspi->TxXferCount--;
 8007b1a:	87d9      	strh	r1, [r3, #62]	; 0x3e
 8007b1c:	e003      	b.n	8007b26 <fast_txrx+0x15a>
	  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8007b1e:	6891      	ldr	r1, [r2, #8]
 8007b20:	07cf      	lsls	r7, r1, #31
 8007b22:	f100 80e3 	bmi.w	8007cec <fast_txrx+0x320>
	while (hspi->RxXferCount > 0U)
 8007b26:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
 8007b2a:	b289      	uxth	r1, r1
 8007b2c:	2900      	cmp	r1, #0
 8007b2e:	d1f6      	bne.n	8007b1e <fast_txrx+0x152>
           crc ^= (datin >> byte_idx) & 0x3F;
 8007b30:	0ca3      	lsrs	r3, r4, #18
	spi_txrx_byte(&hspi2,&buffer1,&buffer2);
	// dont need the last byte, it's the crc
	crc_in = buffer2;
 8007b32:	f89d 2007 	ldrb.w	r2, [sp, #7]
             crc <<= 1;
 8007b36:	005b      	lsls	r3, r3, #1
 8007b38:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b3c:	065e      	lsls	r6, r3, #25
 8007b3e:	bf48      	it	mi
 8007b40:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b44:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b46:	065d      	lsls	r5, r3, #25
 8007b48:	d502      	bpl.n	8007b50 <fast_txrx+0x184>
 8007b4a:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8007b4e:	b29b      	uxth	r3, r3
             crc <<= 1;
 8007b50:	005b      	lsls	r3, r3, #1
 8007b52:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b54:	0658      	lsls	r0, r3, #25
 8007b56:	bf48      	it	mi
 8007b58:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b5c:	005b      	lsls	r3, r3, #1
 8007b5e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b60:	0659      	lsls	r1, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007b62:	f3c4 3105 	ubfx	r1, r4, #12, #6
 8007b66:	bf48      	it	mi
 8007b68:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b6c:	005b      	lsls	r3, r3, #1
 8007b6e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b70:	065f      	lsls	r7, r3, #25
 8007b72:	bf48      	it	mi
 8007b74:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b78:	005b      	lsls	r3, r3, #1
 8007b7a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b7c:	065e      	lsls	r6, r3, #25
 8007b7e:	bf48      	it	mi
 8007b80:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007b84:	404b      	eors	r3, r1
             crc <<= 1;
 8007b86:	005b      	lsls	r3, r3, #1
 8007b88:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b8a:	065d      	lsls	r5, r3, #25
 8007b8c:	bf48      	it	mi
 8007b8e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b92:	005b      	lsls	r3, r3, #1
 8007b94:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007b96:	0658      	lsls	r0, r3, #25
 8007b98:	bf48      	it	mi
 8007b9a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007b9e:	005b      	lsls	r3, r3, #1
 8007ba0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007ba2:	0659      	lsls	r1, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007ba4:	f3c4 1185 	ubfx	r1, r4, #6, #6
 8007ba8:	bf48      	it	mi
 8007baa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007bae:	005b      	lsls	r3, r3, #1
 8007bb0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007bb2:	065f      	lsls	r7, r3, #25
 8007bb4:	bf48      	it	mi
 8007bb6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007bba:	005b      	lsls	r3, r3, #1
 8007bbc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007bbe:	065e      	lsls	r6, r3, #25
 8007bc0:	bf48      	it	mi
 8007bc2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007bc6:	005b      	lsls	r3, r3, #1
 8007bc8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007bca:	065d      	lsls	r5, r3, #25
 8007bcc:	bf48      	it	mi
 8007bce:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007bd2:	404b      	eors	r3, r1
             crc <<= 1;
 8007bd4:	005b      	lsls	r3, r3, #1
 8007bd6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007bd8:	0658      	lsls	r0, r3, #25
 8007bda:	bf48      	it	mi
 8007bdc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007be0:	005b      	lsls	r3, r3, #1
 8007be2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007be4:	0659      	lsls	r1, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007be6:	f004 013f 	and.w	r1, r4, #63	; 0x3f
 8007bea:	bf48      	it	mi
 8007bec:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007bf0:	005b      	lsls	r3, r3, #1
 8007bf2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007bf4:	065f      	lsls	r7, r3, #25
 8007bf6:	bf48      	it	mi
 8007bf8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007bfc:	005b      	lsls	r3, r3, #1
 8007bfe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c00:	065e      	lsls	r6, r3, #25
 8007c02:	bf48      	it	mi
 8007c04:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c08:	005b      	lsls	r3, r3, #1
 8007c0a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c0c:	065d      	lsls	r5, r3, #25
 8007c0e:	bf48      	it	mi
 8007c10:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c14:	005b      	lsls	r3, r3, #1
 8007c16:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c18:	0658      	lsls	r0, r3, #25
 8007c1a:	bf48      	it	mi
 8007c1c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007c20:	404b      	eors	r3, r1
             crc <<= 1;
 8007c22:	005b      	lsls	r3, r3, #1
 8007c24:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c26:	0659      	lsls	r1, r3, #25
 8007c28:	bf48      	it	mi
 8007c2a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c2e:	005b      	lsls	r3, r3, #1
 8007c30:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c32:	065f      	lsls	r7, r3, #25
 8007c34:	bf48      	it	mi
 8007c36:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c3a:	005b      	lsls	r3, r3, #1
 8007c3c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c3e:	065e      	lsls	r6, r3, #25
 8007c40:	bf48      	it	mi
 8007c42:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c46:	005b      	lsls	r3, r3, #1
 8007c48:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c4a:	065d      	lsls	r5, r3, #25
 8007c4c:	bf48      	it	mi
 8007c4e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c52:	005b      	lsls	r3, r3, #1
 8007c54:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c56:	0658      	lsls	r0, r3, #25
 8007c58:	bf48      	it	mi
 8007c5a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007c5e:	005b      	lsls	r3, r3, #1
 8007c60:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007c62:	0659      	lsls	r1, r3, #25
 8007c64:	bf48      	it	mi
 8007c66:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	crc_calc = pga411_crc2(miso);

	if (crc_in != crc_calc && !ignore_crc_error) {
 8007c6a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8007c6e:	4293      	cmp	r3, r2
 8007c70:	d003      	beq.n	8007c7a <fast_txrx+0x2ae>
 8007c72:	4b0f      	ldr	r3, [pc, #60]	; (8007cb0 <fast_txrx+0x2e4>)
 8007c74:	781b      	ldrb	r3, [r3, #0]
 8007c76:	2b00      	cmp	r3, #0
 8007c78:	d046      	beq.n	8007d08 <fast_txrx+0x33c>
		mc_vars.fault_reg1 |= 1 << RDC_CRC_FLAG_BIT;
		Error_Handler();
	}

	//miso= ((miso<< 8) | buffer2);
	HAL_GPIO_WritePin(GPIOB, RDC_CS_Pin, 1);
 8007c7a:	2201      	movs	r2, #1
 8007c7c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8007c80:	4809      	ldr	r0, [pc, #36]	; (8007ca8 <fast_txrx+0x2dc>)
 8007c82:	f7fa fa4b 	bl	800211c <HAL_GPIO_WritePin>

	// NCS needs to be high for at least 200 ns

	return(miso);
}
 8007c86:	4620      	mov	r0, r4
 8007c88:	b003      	add	sp, #12
 8007c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007c8c:	7b11      	ldrb	r1, [r2, #12]
 8007c8e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007c90:	7011      	strb	r1, [r2, #0]
		  hspi->RxXferCount--;
 8007c92:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007c96:	6c1c      	ldr	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007c98:	3901      	subs	r1, #1
 8007c9a:	681a      	ldr	r2, [r3, #0]
		  hspi->pRxBuffPtr++;
 8007c9c:	3401      	adds	r4, #1
		  hspi->RxXferCount--;
 8007c9e:	b289      	uxth	r1, r1
		  hspi->pRxBuffPtr++;
 8007ca0:	641c      	str	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007ca2:	f8a3 1046 	strh.w	r1, [r3, #70]	; 0x46
 8007ca6:	e6c7      	b.n	8007a38 <fast_txrx+0x6c>
 8007ca8:	40020400 	.word	0x40020400
 8007cac:	20002350 	.word	0x20002350
 8007cb0:	2006963c 	.word	0x2006963c
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007cb4:	7b11      	ldrb	r1, [r2, #12]
 8007cb6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007cb8:	7011      	strb	r1, [r2, #0]
		  hspi->RxXferCount--;
 8007cba:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007cbe:	6c1c      	ldr	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007cc0:	3901      	subs	r1, #1
 8007cc2:	681a      	ldr	r2, [r3, #0]
		  hspi->pRxBuffPtr++;
 8007cc4:	3401      	adds	r4, #1
		  hspi->RxXferCount--;
 8007cc6:	b289      	uxth	r1, r1
		  hspi->pRxBuffPtr++;
 8007cc8:	641c      	str	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007cca:	f8a3 1046 	strh.w	r1, [r3, #70]	; 0x46
 8007cce:	e6d9      	b.n	8007a84 <fast_txrx+0xb8>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007cd0:	7b11      	ldrb	r1, [r2, #12]
 8007cd2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007cd4:	7011      	strb	r1, [r2, #0]
		  hspi->RxXferCount--;
 8007cd6:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007cda:	6c1c      	ldr	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007cdc:	3901      	subs	r1, #1
 8007cde:	681a      	ldr	r2, [r3, #0]
		  hspi->pRxBuffPtr++;
 8007ce0:	3401      	adds	r4, #1
		  hspi->RxXferCount--;
 8007ce2:	b289      	uxth	r1, r1
		  hspi->pRxBuffPtr++;
 8007ce4:	641c      	str	r4, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007ce6:	f8a3 1046 	strh.w	r1, [r3, #70]	; 0x46
 8007cea:	e6f3      	b.n	8007ad4 <fast_txrx+0x108>
		  (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8007cec:	7b11      	ldrb	r1, [r2, #12]
 8007cee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007cf0:	7011      	strb	r1, [r2, #0]
		  hspi->RxXferCount--;
 8007cf2:	f8b3 1046 	ldrh.w	r1, [r3, #70]	; 0x46
		  hspi->pRxBuffPtr++;
 8007cf6:	6c18      	ldr	r0, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007cf8:	3901      	subs	r1, #1
 8007cfa:	681a      	ldr	r2, [r3, #0]
		  hspi->pRxBuffPtr++;
 8007cfc:	3001      	adds	r0, #1
		  hspi->RxXferCount--;
 8007cfe:	b289      	uxth	r1, r1
		  hspi->pRxBuffPtr++;
 8007d00:	6418      	str	r0, [r3, #64]	; 0x40
		  hspi->RxXferCount--;
 8007d02:	f8a3 1046 	strh.w	r1, [r3, #70]	; 0x46
 8007d06:	e70e      	b.n	8007b26 <fast_txrx+0x15a>
		mc_vars.fault_reg1 |= 1 << RDC_CRC_FLAG_BIT;
 8007d08:	4a04      	ldr	r2, [pc, #16]	; (8007d1c <fast_txrx+0x350>)
 8007d0a:	f8b2 3070 	ldrh.w	r3, [r2, #112]	; 0x70
 8007d0e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007d12:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
		Error_Handler();
 8007d16:	f7fd fccb 	bl	80056b0 <Error_Handler>
 8007d1a:	e7ae      	b.n	8007c7a <fast_txrx+0x2ae>
 8007d1c:	200021cc 	.word	0x200021cc

08007d20 <pga411_ReadAll>:
void pga411_ReadAll(void) {
 8007d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007d22:	2500      	movs	r5, #0
 8007d24:	4caf      	ldr	r4, [pc, #700]	; (8007fe4 <pga411_ReadAll+0x2c4>)
		if (i<27) {
 8007d26:	2d1b      	cmp	r5, #27
 8007d28:	4626      	mov	r6, r4
 8007d2a:	b2af      	uxth	r7, r5
 8007d2c:	f000 815c 	beq.w	8007fe8 <pga411_ReadAll+0x2c8>
	out.frame = out.addr;
 8007d30:	78b2      	ldrb	r2, [r6, #2]
	out.frame = out.frame << 16;
 8007d32:	0411      	lsls	r1, r2, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8007d34:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 8007d36:	005b      	lsls	r3, r3, #1
 8007d38:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d3c:	0658      	lsls	r0, r3, #25
 8007d3e:	bf48      	it	mi
 8007d40:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007d44:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d46:	0658      	lsls	r0, r3, #25
 8007d48:	d502      	bpl.n	8007d50 <pga411_ReadAll+0x30>
 8007d4a:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8007d4e:	b29b      	uxth	r3, r3
             crc <<= 1;
 8007d50:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8007d52:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 8007d54:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 8007d56:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d5a:	0658      	lsls	r0, r3, #25
 8007d5c:	bf48      	it	mi
 8007d5e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007d62:	005b      	lsls	r3, r3, #1
 8007d64:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d66:	0658      	lsls	r0, r3, #25
 8007d68:	bf48      	it	mi
 8007d6a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007d6e:	005b      	lsls	r3, r3, #1
 8007d70:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d72:	0658      	lsls	r0, r3, #25
 8007d74:	bf48      	it	mi
 8007d76:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007d7a:	005b      	lsls	r3, r3, #1
 8007d7c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d7e:	0658      	lsls	r0, r3, #25
 8007d80:	bf48      	it	mi
 8007d82:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007d86:	404b      	eors	r3, r1
             crc <<= 1;
 8007d88:	005b      	lsls	r3, r3, #1
 8007d8a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d8c:	0658      	lsls	r0, r3, #25
 8007d8e:	bf48      	it	mi
 8007d90:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007d94:	005b      	lsls	r3, r3, #1
 8007d96:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007d98:	0659      	lsls	r1, r3, #25
 8007d9a:	bf48      	it	mi
 8007d9c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007da0:	005b      	lsls	r3, r3, #1
 8007da2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007da4:	0658      	lsls	r0, r3, #25
 8007da6:	bf48      	it	mi
 8007da8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007dac:	005b      	lsls	r3, r3, #1
 8007dae:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007db0:	0659      	lsls	r1, r3, #25
 8007db2:	bf48      	it	mi
 8007db4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007db8:	005b      	lsls	r3, r3, #1
 8007dba:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007dbc:	0658      	lsls	r0, r3, #25
 8007dbe:	bf48      	it	mi
 8007dc0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007dc4:	005b      	lsls	r3, r3, #1
 8007dc6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007dc8:	0659      	lsls	r1, r3, #25
 8007dca:	bf48      	it	mi
 8007dcc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007dd0:	005b      	lsls	r3, r3, #1
 8007dd2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007dd4:	0658      	lsls	r0, r3, #25
 8007dd6:	bf48      	it	mi
 8007dd8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007ddc:	005b      	lsls	r3, r3, #1
 8007dde:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007de0:	0659      	lsls	r1, r3, #25
 8007de2:	bf48      	it	mi
 8007de4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007de8:	005b      	lsls	r3, r3, #1
 8007dea:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007dec:	0658      	lsls	r0, r3, #25
 8007dee:	bf48      	it	mi
 8007df0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007df4:	005b      	lsls	r3, r3, #1
 8007df6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007df8:	0659      	lsls	r1, r3, #25
 8007dfa:	bf48      	it	mi
 8007dfc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e00:	005b      	lsls	r3, r3, #1
 8007e02:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e04:	0658      	lsls	r0, r3, #25
 8007e06:	bf48      	it	mi
 8007e08:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e0c:	005b      	lsls	r3, r3, #1
 8007e0e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e10:	0659      	lsls	r1, r3, #25
 8007e12:	bf48      	it	mi
 8007e14:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e18:	005b      	lsls	r3, r3, #1
 8007e1a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e1c:	0658      	lsls	r0, r3, #25
 8007e1e:	bf48      	it	mi
 8007e20:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e24:	005b      	lsls	r3, r3, #1
 8007e26:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e28:	0659      	lsls	r1, r3, #25
 8007e2a:	bf48      	it	mi
 8007e2c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e30:	005b      	lsls	r3, r3, #1
 8007e32:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e34:	0658      	lsls	r0, r3, #25
 8007e36:	bf48      	it	mi
 8007e38:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e3c:	005b      	lsls	r3, r3, #1
 8007e3e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e40:	0659      	lsls	r1, r3, #25
 8007e42:	bf48      	it	mi
 8007e44:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e48:	005b      	lsls	r3, r3, #1
 8007e4a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e4c:	0658      	lsls	r0, r3, #25
 8007e4e:	bf48      	it	mi
 8007e50:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e54:	005b      	lsls	r3, r3, #1
 8007e56:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e58:	0659      	lsls	r1, r3, #25
 8007e5a:	bf48      	it	mi
 8007e5c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 8007e60:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 8007e64:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 8007e68:	f7ff fab2 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8007e6c:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 8007e70:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 8007e72:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 8007e74:	005b      	lsls	r3, r3, #1
 8007e76:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e7a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007e7e:	bf18      	it	ne
 8007e80:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007e84:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007e86:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007e8a:	d002      	beq.n	8007e92 <pga411_ReadAll+0x172>
 8007e8c:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8007e90:	b29b      	uxth	r3, r3
             crc <<= 1;
 8007e92:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8007e94:	f3c0 5c05 	ubfx	ip, r0, #20, #6
 8007e98:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8007e9c:	b289      	uxth	r1, r1
             crc <<= 1;
 8007e9e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007ea0:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007ea4:	bf18      	it	ne
 8007ea6:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007eaa:	005b      	lsls	r3, r3, #1
 8007eac:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007eae:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007eb2:	bf18      	it	ne
 8007eb4:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007eb8:	005b      	lsls	r3, r3, #1
 8007eba:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007ebc:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007ec0:	bf18      	it	ne
 8007ec2:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007ec6:	005b      	lsls	r3, r3, #1
 8007ec8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007eca:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007ece:	bf18      	it	ne
 8007ed0:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007ed4:	ea83 030c 	eor.w	r3, r3, ip
             crc <<= 1;
 8007ed8:	005b      	lsls	r3, r3, #1
 8007eda:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007edc:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007ee0:	bf18      	it	ne
 8007ee2:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007ee6:	005b      	lsls	r3, r3, #1
 8007ee8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007eea:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007eee:	bf18      	it	ne
 8007ef0:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007ef4:	005b      	lsls	r3, r3, #1
 8007ef6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007ef8:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007efc:	bf18      	it	ne
 8007efe:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f02:	005b      	lsls	r3, r3, #1
 8007f04:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f06:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007f0a:	bf18      	it	ne
 8007f0c:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f10:	005b      	lsls	r3, r3, #1
 8007f12:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f14:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007f18:	bf18      	it	ne
 8007f1a:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f1e:	005b      	lsls	r3, r3, #1
 8007f20:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f22:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007f26:	bf18      	it	ne
 8007f28:	f083 035b 	eorne.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8007f2c:	4043      	eors	r3, r0
             crc <<= 1;
 8007f2e:	005b      	lsls	r3, r3, #1
 8007f30:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f32:	0658      	lsls	r0, r3, #25
 8007f34:	bf48      	it	mi
 8007f36:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f3a:	005b      	lsls	r3, r3, #1
 8007f3c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f3e:	0658      	lsls	r0, r3, #25
 8007f40:	bf48      	it	mi
 8007f42:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f46:	005b      	lsls	r3, r3, #1
 8007f48:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f4a:	0658      	lsls	r0, r3, #25
 8007f4c:	bf48      	it	mi
 8007f4e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f52:	005b      	lsls	r3, r3, #1
 8007f54:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f56:	0658      	lsls	r0, r3, #25
 8007f58:	bf48      	it	mi
 8007f5a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f5e:	005b      	lsls	r3, r3, #1
 8007f60:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f62:	0658      	lsls	r0, r3, #25
 8007f64:	bf48      	it	mi
 8007f66:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f6a:	005b      	lsls	r3, r3, #1
 8007f6c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f6e:	0658      	lsls	r0, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8007f70:	f001 003f 	and.w	r0, r1, #63	; 0x3f
 8007f74:	bf48      	it	mi
 8007f76:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8007f7a:	4043      	eors	r3, r0
             crc <<= 1;
 8007f7c:	005b      	lsls	r3, r3, #1
 8007f7e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f80:	0658      	lsls	r0, r3, #25
 8007f82:	bf48      	it	mi
 8007f84:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f88:	005b      	lsls	r3, r3, #1
 8007f8a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f8c:	0658      	lsls	r0, r3, #25
 8007f8e:	bf48      	it	mi
 8007f90:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007f94:	005b      	lsls	r3, r3, #1
 8007f96:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007f98:	0658      	lsls	r0, r3, #25
 8007f9a:	bf48      	it	mi
 8007f9c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007fa0:	005b      	lsls	r3, r3, #1
 8007fa2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007fa4:	0658      	lsls	r0, r3, #25
 8007fa6:	bf48      	it	mi
 8007fa8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007fac:	005b      	lsls	r3, r3, #1
 8007fae:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007fb0:	0658      	lsls	r0, r3, #25
 8007fb2:	bf48      	it	mi
 8007fb4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007fb8:	005b      	lsls	r3, r3, #1
 8007fba:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007fbc:	0658      	lsls	r0, r3, #25
 8007fbe:	bf48      	it	mi
 8007fc0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8007fc4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8007fc8:	4293      	cmp	r3, r2
 8007fca:	d000      	beq.n	8007fce <pga411_ReadAll+0x2ae>
		asm("NOP"); /* if error -> terminate */
 8007fcc:	bf00      	nop
		if(i) {
 8007fce:	b10f      	cbz	r7, 8007fd4 <pga411_ReadAll+0x2b4>
			pga411_regs[i-1].real_val= rx_data;
 8007fd0:	f826 1c02 	strh.w	r1, [r6, #-2]
 8007fd4:	3501      	adds	r5, #1
 8007fd6:	360a      	adds	r6, #10
		if (i<27) {
 8007fd8:	2d1b      	cmp	r5, #27
 8007fda:	b2af      	uxth	r7, r5
 8007fdc:	f47f aea8 	bne.w	8007d30 <pga411_ReadAll+0x10>
 8007fe0:	e002      	b.n	8007fe8 <pga411_ReadAll+0x2c8>
 8007fe2:	bf00      	nop
 8007fe4:	20001f50 	.word	0x20001f50
	out.frame = out.addr;
 8007fe8:	f894 0106 	ldrb.w	r0, [r4, #262]	; 0x106
	out.frame = out.frame << 16;
 8007fec:	0401      	lsls	r1, r0, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8007fee:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 8007ff0:	005b      	lsls	r3, r3, #1
 8007ff2:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8007ff6:	065f      	lsls	r7, r3, #25
 8007ff8:	bf48      	it	mi
 8007ffa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8007ffe:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008000:	065d      	lsls	r5, r3, #25
 8008002:	d502      	bpl.n	800800a <pga411_ReadAll+0x2ea>
 8008004:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008008:	b29b      	uxth	r3, r3
             crc <<= 1;
 800800a:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 800800c:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 800800e:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 8008010:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008014:	065c      	lsls	r4, r3, #25
 8008016:	bf48      	it	mi
 8008018:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800801c:	005b      	lsls	r3, r3, #1
 800801e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008020:	065a      	lsls	r2, r3, #25
 8008022:	bf48      	it	mi
 8008024:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008028:	005b      	lsls	r3, r3, #1
 800802a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800802c:	065f      	lsls	r7, r3, #25
 800802e:	bf48      	it	mi
 8008030:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008034:	005b      	lsls	r3, r3, #1
 8008036:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008038:	065d      	lsls	r5, r3, #25
 800803a:	bf48      	it	mi
 800803c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008040:	404b      	eors	r3, r1
             crc <<= 1;
 8008042:	005b      	lsls	r3, r3, #1
 8008044:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008046:	065c      	lsls	r4, r3, #25
 8008048:	bf48      	it	mi
 800804a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800804e:	005b      	lsls	r3, r3, #1
 8008050:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008052:	0659      	lsls	r1, r3, #25
 8008054:	bf48      	it	mi
 8008056:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800805a:	005b      	lsls	r3, r3, #1
 800805c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800805e:	065a      	lsls	r2, r3, #25
 8008060:	bf48      	it	mi
 8008062:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008066:	005b      	lsls	r3, r3, #1
 8008068:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800806a:	065f      	lsls	r7, r3, #25
 800806c:	bf48      	it	mi
 800806e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008072:	005b      	lsls	r3, r3, #1
 8008074:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008076:	065d      	lsls	r5, r3, #25
 8008078:	bf48      	it	mi
 800807a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800807e:	005b      	lsls	r3, r3, #1
 8008080:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008082:	065c      	lsls	r4, r3, #25
 8008084:	bf48      	it	mi
 8008086:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800808a:	005b      	lsls	r3, r3, #1
 800808c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800808e:	0659      	lsls	r1, r3, #25
 8008090:	bf48      	it	mi
 8008092:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008096:	005b      	lsls	r3, r3, #1
 8008098:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800809a:	065a      	lsls	r2, r3, #25
 800809c:	bf48      	it	mi
 800809e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080a2:	005b      	lsls	r3, r3, #1
 80080a4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080a6:	065f      	lsls	r7, r3, #25
 80080a8:	bf48      	it	mi
 80080aa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080ae:	005b      	lsls	r3, r3, #1
 80080b0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080b2:	065d      	lsls	r5, r3, #25
 80080b4:	bf48      	it	mi
 80080b6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080ba:	005b      	lsls	r3, r3, #1
 80080bc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080be:	065c      	lsls	r4, r3, #25
 80080c0:	bf48      	it	mi
 80080c2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080c6:	005b      	lsls	r3, r3, #1
 80080c8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080ca:	0659      	lsls	r1, r3, #25
 80080cc:	bf48      	it	mi
 80080ce:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080d2:	005b      	lsls	r3, r3, #1
 80080d4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080d6:	065a      	lsls	r2, r3, #25
 80080d8:	bf48      	it	mi
 80080da:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080de:	005b      	lsls	r3, r3, #1
 80080e0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080e2:	065f      	lsls	r7, r3, #25
 80080e4:	bf48      	it	mi
 80080e6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080ea:	005b      	lsls	r3, r3, #1
 80080ec:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080ee:	065d      	lsls	r5, r3, #25
 80080f0:	bf48      	it	mi
 80080f2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80080f6:	005b      	lsls	r3, r3, #1
 80080f8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80080fa:	065c      	lsls	r4, r3, #25
 80080fc:	bf48      	it	mi
 80080fe:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008102:	005b      	lsls	r3, r3, #1
 8008104:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008106:	0659      	lsls	r1, r3, #25
 8008108:	bf48      	it	mi
 800810a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800810e:	005b      	lsls	r3, r3, #1
 8008110:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008112:	065a      	lsls	r2, r3, #25
 8008114:	bf48      	it	mi
 8008116:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 800811a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 800811e:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
 8008122:	f7ff f955 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8008126:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 800812a:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 800812c:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 800812e:	005b      	lsls	r3, r3, #1
 8008130:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008134:	065f      	lsls	r7, r3, #25
 8008136:	bf48      	it	mi
 8008138:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800813c:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800813e:	065d      	lsls	r5, r3, #25
 8008140:	d502      	bpl.n	8008148 <pga411_ReadAll+0x428>
 8008142:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008146:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008148:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 800814a:	b289      	uxth	r1, r1
             crc <<= 1;
 800814c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800814e:	065c      	lsls	r4, r3, #25
 8008150:	bf48      	it	mi
 8008152:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008156:	005b      	lsls	r3, r3, #1
 8008158:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800815a:	065f      	lsls	r7, r3, #25
 800815c:	bf48      	it	mi
 800815e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008162:	005b      	lsls	r3, r3, #1
 8008164:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008166:	065d      	lsls	r5, r3, #25
 8008168:	bf48      	it	mi
 800816a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800816e:	005b      	lsls	r3, r3, #1
 8008170:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008172:	065c      	lsls	r4, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008174:	f3c0 5405 	ubfx	r4, r0, #20, #6
 8008178:	f3c0 3085 	ubfx	r0, r0, #14, #6
 800817c:	bf48      	it	mi
 800817e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008182:	4063      	eors	r3, r4
             crc <<= 1;
 8008184:	005b      	lsls	r3, r3, #1
 8008186:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008188:	065f      	lsls	r7, r3, #25
 800818a:	bf48      	it	mi
 800818c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008190:	005b      	lsls	r3, r3, #1
 8008192:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008194:	065d      	lsls	r5, r3, #25
 8008196:	bf48      	it	mi
 8008198:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800819c:	005b      	lsls	r3, r3, #1
 800819e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081a0:	065c      	lsls	r4, r3, #25
 80081a2:	bf48      	it	mi
 80081a4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081a8:	005b      	lsls	r3, r3, #1
 80081aa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081ac:	065f      	lsls	r7, r3, #25
 80081ae:	bf48      	it	mi
 80081b0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081b4:	005b      	lsls	r3, r3, #1
 80081b6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081b8:	065d      	lsls	r5, r3, #25
 80081ba:	bf48      	it	mi
 80081bc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081c0:	005b      	lsls	r3, r3, #1
 80081c2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081c4:	065c      	lsls	r4, r3, #25
 80081c6:	bf48      	it	mi
 80081c8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 80081cc:	4043      	eors	r3, r0
             crc <<= 1;
 80081ce:	005b      	lsls	r3, r3, #1
 80081d0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081d2:	065f      	lsls	r7, r3, #25
 80081d4:	bf48      	it	mi
 80081d6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081da:	005b      	lsls	r3, r3, #1
 80081dc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081de:	065d      	lsls	r5, r3, #25
 80081e0:	bf48      	it	mi
 80081e2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081e6:	005b      	lsls	r3, r3, #1
 80081e8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081ea:	065c      	lsls	r4, r3, #25
 80081ec:	bf48      	it	mi
 80081ee:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80081f2:	005b      	lsls	r3, r3, #1
 80081f4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80081f6:	0658      	lsls	r0, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80081f8:	f001 003f 	and.w	r0, r1, #63	; 0x3f
 80081fc:	bf48      	it	mi
 80081fe:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008202:	005b      	lsls	r3, r3, #1
 8008204:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008206:	065f      	lsls	r7, r3, #25
 8008208:	bf48      	it	mi
 800820a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800820e:	005b      	lsls	r3, r3, #1
 8008210:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008212:	065d      	lsls	r5, r3, #25
 8008214:	bf48      	it	mi
 8008216:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 800821a:	4043      	eors	r3, r0
             crc <<= 1;
 800821c:	005b      	lsls	r3, r3, #1
 800821e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008220:	065c      	lsls	r4, r3, #25
 8008222:	bf48      	it	mi
 8008224:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008228:	005b      	lsls	r3, r3, #1
 800822a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800822c:	0658      	lsls	r0, r3, #25
 800822e:	bf48      	it	mi
 8008230:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008234:	005b      	lsls	r3, r3, #1
 8008236:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008238:	065f      	lsls	r7, r3, #25
 800823a:	bf48      	it	mi
 800823c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008240:	005b      	lsls	r3, r3, #1
 8008242:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008244:	065d      	lsls	r5, r3, #25
 8008246:	bf48      	it	mi
 8008248:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800824c:	005b      	lsls	r3, r3, #1
 800824e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008250:	065c      	lsls	r4, r3, #25
 8008252:	bf48      	it	mi
 8008254:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008258:	005b      	lsls	r3, r3, #1
 800825a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800825c:	0658      	lsls	r0, r3, #25
 800825e:	bf48      	it	mi
 8008260:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8008264:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008268:	4293      	cmp	r3, r2
 800826a:	d000      	beq.n	800826e <pga411_ReadAll+0x54e>
		asm("NOP"); /* if error -> terminate */
 800826c:	bf00      	nop
			pga411_regs[i-1].real_val= rx_data;
 800826e:	f826 1c02 	strh.w	r1, [r6, #-2]
}
 8008272:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08008274 <pga411_Init>:
void pga411_Init(void) {
 8008274:	b5f0      	push	{r4, r5, r6, r7, lr}
	HAL_GPIO_WritePin(GPIOD, RDC_NRST_Pin, LOW); /* RESET_Nlow */
 8008276:	2200      	movs	r2, #0
void pga411_Init(void) {
 8008278:	b085      	sub	sp, #20
	HAL_GPIO_WritePin(GPIOD, RDC_NRST_Pin, LOW); /* RESET_Nlow */
 800827a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800827e:	48bf      	ldr	r0, [pc, #764]	; (800857c <pga411_Init+0x308>)
 8008280:	f7f9 ff4c 	bl	800211c <HAL_GPIO_WritePin>
	HAL_Delay(1); /* hold in reset for 500us*/
 8008284:	2001      	movs	r0, #1
 8008286:	f7f8 f999 	bl	80005bc <HAL_Delay>
	HAL_GPIO_WritePin(GPIOD, RDC_NRST_Pin, HIGH); /* release from reset */
 800828a:	2201      	movs	r2, #1
 800828c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008290:	48ba      	ldr	r0, [pc, #744]	; (800857c <pga411_Init+0x308>)
 8008292:	f7f9 ff43 	bl	800211c <HAL_GPIO_WritePin>
	HAL_Delay(10); /* wait at least 10 ms */
 8008296:	200a      	movs	r0, #10
 8008298:	f7f8 f990 	bl	80005bc <HAL_Delay>
	pga411_XmitSPI(WRITE,reg,data);
 800829c:	4eb8      	ldr	r6, [pc, #736]	; (8008580 <pga411_Init+0x30c>)
	HAL_Delay(100);
 800829e:	2064      	movs	r0, #100	; 0x64
 80082a0:	f7f8 f98c 	bl	80005bc <HAL_Delay>
	HAL_GPIO_WritePin(GPIOB, RDC_FAULTRES_Pin, LOW); /* assert FAULTRES low - open collector */
 80082a4:	2200      	movs	r2, #0
 80082a6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80082aa:	48b6      	ldr	r0, [pc, #728]	; (8008584 <pga411_Init+0x310>)
 80082ac:	f7f9 ff36 	bl	800211c <HAL_GPIO_WritePin>
	pga411_XmitSPI(WRITE,reg,data);
 80082b0:	f8b6 207c 	ldrh.w	r2, [r6, #124]	; 0x7c
 80082b4:	2304      	movs	r3, #4
 80082b6:	f8b6 107a 	ldrh.w	r1, [r6, #122]	; 0x7a
 80082ba:	4668      	mov	r0, sp
 80082bc:	4634      	mov	r4, r6
 80082be:	f7ff fa33 	bl	8007728 <pga411_XmitSPI.isra.0.constprop.6>
	hal_Xmit4BSPI(0x95000F39);
 80082c2:	48b1      	ldr	r0, [pc, #708]	; (8008588 <pga411_Init+0x314>)
 80082c4:	f7ff f884 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x95005522);
 80082c8:	48b0      	ldr	r0, [pc, #704]	; (800858c <pga411_Init+0x318>)
 80082ca:	f7ff f881 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x9500AA25);
 80082ce:	48b0      	ldr	r0, [pc, #704]	; (8008590 <pga411_Init+0x31c>)
 80082d0:	f7ff f87e 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x9500F03E);
 80082d4:	48af      	ldr	r0, [pc, #700]	; (8008594 <pga411_Init+0x320>)
 80082d6:	f106 0578 	add.w	r5, r6, #120	; 0x78
 80082da:	f7ff f879 	bl	80073d0 <hal_Xmit4BSPI>
		pga411_XmitSPI(WRITE, pga411_regs[i], pga411_regs[i].def_val);
 80082de:	88e3      	ldrh	r3, [r4, #6]
 80082e0:	4668      	mov	r0, sp
 80082e2:	88a2      	ldrh	r2, [r4, #4]
 80082e4:	8861      	ldrh	r1, [r4, #2]
 80082e6:	f7ff fa1f 	bl	8007728 <pga411_XmitSPI.isra.0.constprop.6>
		pga411_ReadReg(pga411_regs[i]);
 80082ea:	8867      	ldrh	r7, [r4, #2]
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80082ec:	88a2      	ldrh	r2, [r4, #4]
 80082ee:	4668      	mov	r0, sp
 80082f0:	4639      	mov	r1, r7
	out.frame = out.addr;
 80082f2:	b2ff      	uxtb	r7, r7
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80082f4:	f7ff f8ca 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.frame << 16;
 80082f8:	0439      	lsls	r1, r7, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 80082fa:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 80082fc:	005b      	lsls	r3, r3, #1
 80082fe:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008302:	0658      	lsls	r0, r3, #25
 8008304:	bf48      	it	mi
 8008306:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800830a:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800830c:	065a      	lsls	r2, r3, #25
 800830e:	d502      	bpl.n	8008316 <pga411_Init+0xa2>
 8008310:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008314:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008316:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008318:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 800831a:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 800831c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008320:	0658      	lsls	r0, r3, #25
 8008322:	bf48      	it	mi
 8008324:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008328:	005b      	lsls	r3, r3, #1
 800832a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800832c:	065a      	lsls	r2, r3, #25
 800832e:	bf48      	it	mi
 8008330:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008334:	005b      	lsls	r3, r3, #1
 8008336:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008338:	0658      	lsls	r0, r3, #25
 800833a:	bf48      	it	mi
 800833c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008340:	005b      	lsls	r3, r3, #1
 8008342:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008344:	065a      	lsls	r2, r3, #25
 8008346:	bf48      	it	mi
 8008348:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 800834c:	404b      	eors	r3, r1
             crc <<= 1;
 800834e:	005b      	lsls	r3, r3, #1
 8008350:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008352:	0658      	lsls	r0, r3, #25
 8008354:	bf48      	it	mi
 8008356:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800835a:	005b      	lsls	r3, r3, #1
 800835c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800835e:	0659      	lsls	r1, r3, #25
 8008360:	bf48      	it	mi
 8008362:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008366:	005b      	lsls	r3, r3, #1
 8008368:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800836a:	065a      	lsls	r2, r3, #25
 800836c:	bf48      	it	mi
 800836e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008372:	005b      	lsls	r3, r3, #1
 8008374:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008376:	0658      	lsls	r0, r3, #25
 8008378:	bf48      	it	mi
 800837a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800837e:	005b      	lsls	r3, r3, #1
 8008380:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008382:	0659      	lsls	r1, r3, #25
 8008384:	bf48      	it	mi
 8008386:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800838a:	005b      	lsls	r3, r3, #1
 800838c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800838e:	065a      	lsls	r2, r3, #25
 8008390:	bf48      	it	mi
 8008392:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008396:	005b      	lsls	r3, r3, #1
 8008398:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800839a:	0658      	lsls	r0, r3, #25
 800839c:	bf48      	it	mi
 800839e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083a2:	005b      	lsls	r3, r3, #1
 80083a4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083a6:	0659      	lsls	r1, r3, #25
 80083a8:	bf48      	it	mi
 80083aa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083ae:	005b      	lsls	r3, r3, #1
 80083b0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083b2:	065a      	lsls	r2, r3, #25
 80083b4:	bf48      	it	mi
 80083b6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083ba:	005b      	lsls	r3, r3, #1
 80083bc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083be:	0658      	lsls	r0, r3, #25
 80083c0:	bf48      	it	mi
 80083c2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083c6:	005b      	lsls	r3, r3, #1
 80083c8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083ca:	0659      	lsls	r1, r3, #25
 80083cc:	bf48      	it	mi
 80083ce:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083d2:	005b      	lsls	r3, r3, #1
 80083d4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083d6:	065a      	lsls	r2, r3, #25
 80083d8:	bf48      	it	mi
 80083da:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083de:	005b      	lsls	r3, r3, #1
 80083e0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083e2:	0658      	lsls	r0, r3, #25
 80083e4:	bf48      	it	mi
 80083e6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083ea:	005b      	lsls	r3, r3, #1
 80083ec:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083ee:	0659      	lsls	r1, r3, #25
 80083f0:	bf48      	it	mi
 80083f2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80083f6:	005b      	lsls	r3, r3, #1
 80083f8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80083fa:	065a      	lsls	r2, r3, #25
 80083fc:	bf48      	it	mi
 80083fe:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008402:	005b      	lsls	r3, r3, #1
 8008404:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008406:	0658      	lsls	r0, r3, #25
 8008408:	bf48      	it	mi
 800840a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800840e:	005b      	lsls	r3, r3, #1
 8008410:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008412:	0659      	lsls	r1, r3, #25
 8008414:	bf48      	it	mi
 8008416:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800841a:	005b      	lsls	r3, r3, #1
 800841c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800841e:	065a      	lsls	r2, r3, #25
 8008420:	bf48      	it	mi
 8008422:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 8008426:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 800842a:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
 800842e:	f7fe ffcf 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8008432:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 8008436:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 8008438:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 800843a:	005b      	lsls	r3, r3, #1
 800843c:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008440:	065f      	lsls	r7, r3, #25
 8008442:	bf48      	it	mi
 8008444:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008448:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800844a:	065f      	lsls	r7, r3, #25
 800844c:	d502      	bpl.n	8008454 <pga411_Init+0x1e0>
 800844e:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008452:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008454:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008456:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc <<= 1;
 800845a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800845c:	065f      	lsls	r7, r3, #25
 800845e:	bf48      	it	mi
 8008460:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008464:	005b      	lsls	r3, r3, #1
 8008466:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008468:	065f      	lsls	r7, r3, #25
 800846a:	bf48      	it	mi
 800846c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008470:	005b      	lsls	r3, r3, #1
 8008472:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008474:	065f      	lsls	r7, r3, #25
 8008476:	bf48      	it	mi
 8008478:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800847c:	005b      	lsls	r3, r3, #1
 800847e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008480:	065f      	lsls	r7, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008482:	f3c0 5705 	ubfx	r7, r0, #20, #6
 8008486:	f3c0 3085 	ubfx	r0, r0, #14, #6
 800848a:	bf48      	it	mi
 800848c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008490:	407b      	eors	r3, r7
             crc <<= 1;
 8008492:	005b      	lsls	r3, r3, #1
 8008494:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008496:	065f      	lsls	r7, r3, #25
 8008498:	bf48      	it	mi
 800849a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800849e:	005b      	lsls	r3, r3, #1
 80084a0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084a2:	065f      	lsls	r7, r3, #25
 80084a4:	bf48      	it	mi
 80084a6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084aa:	005b      	lsls	r3, r3, #1
 80084ac:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084ae:	065f      	lsls	r7, r3, #25
 80084b0:	bf48      	it	mi
 80084b2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084b6:	005b      	lsls	r3, r3, #1
 80084b8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084ba:	065f      	lsls	r7, r3, #25
 80084bc:	bf48      	it	mi
 80084be:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084c2:	005b      	lsls	r3, r3, #1
 80084c4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084c6:	065f      	lsls	r7, r3, #25
 80084c8:	bf48      	it	mi
 80084ca:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084ce:	005b      	lsls	r3, r3, #1
 80084d0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084d2:	065f      	lsls	r7, r3, #25
 80084d4:	bf48      	it	mi
 80084d6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 80084da:	4043      	eors	r3, r0
             crc <<= 1;
 80084dc:	005b      	lsls	r3, r3, #1
 80084de:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084e0:	0658      	lsls	r0, r3, #25
 80084e2:	bf48      	it	mi
 80084e4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084e8:	005b      	lsls	r3, r3, #1
 80084ea:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084ec:	065f      	lsls	r7, r3, #25
 80084ee:	bf48      	it	mi
 80084f0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80084f4:	005b      	lsls	r3, r3, #1
 80084f6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80084f8:	0658      	lsls	r0, r3, #25
 80084fa:	bf48      	it	mi
 80084fc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008500:	005b      	lsls	r3, r3, #1
 8008502:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008504:	065f      	lsls	r7, r3, #25
 8008506:	bf48      	it	mi
 8008508:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800850c:	005b      	lsls	r3, r3, #1
 800850e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008510:	0658      	lsls	r0, r3, #25
 8008512:	bf48      	it	mi
 8008514:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008518:	005b      	lsls	r3, r3, #1
 800851a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800851c:	065f      	lsls	r7, r3, #25
 800851e:	bf48      	it	mi
 8008520:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008524:	404b      	eors	r3, r1
             crc <<= 1;
 8008526:	005b      	lsls	r3, r3, #1
 8008528:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800852a:	0658      	lsls	r0, r3, #25
 800852c:	bf48      	it	mi
 800852e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008532:	005b      	lsls	r3, r3, #1
 8008534:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008536:	0659      	lsls	r1, r3, #25
 8008538:	bf48      	it	mi
 800853a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800853e:	005b      	lsls	r3, r3, #1
 8008540:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008542:	065f      	lsls	r7, r3, #25
 8008544:	bf48      	it	mi
 8008546:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800854a:	005b      	lsls	r3, r3, #1
 800854c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800854e:	0658      	lsls	r0, r3, #25
 8008550:	bf48      	it	mi
 8008552:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008556:	005b      	lsls	r3, r3, #1
 8008558:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800855a:	0659      	lsls	r1, r3, #25
 800855c:	bf48      	it	mi
 800855e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008562:	005b      	lsls	r3, r3, #1
 8008564:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008566:	065f      	lsls	r7, r3, #25
 8008568:	bf48      	it	mi
 800856a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 800856e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008572:	4293      	cmp	r3, r2
 8008574:	d010      	beq.n	8008598 <pga411_Init+0x324>
		asm("NOP"); /* if error -> terminate */
 8008576:	bf00      	nop
 8008578:	e00e      	b.n	8008598 <pga411_Init+0x324>
 800857a:	bf00      	nop
 800857c:	40020c00 	.word	0x40020c00
 8008580:	20001f50 	.word	0x20001f50
 8008584:	40020400 	.word	0x40020400
 8008588:	95000f39 	.word	0x95000f39
 800858c:	95005522 	.word	0x95005522
 8008590:	9500aa25 	.word	0x9500aa25
 8008594:	9500f03e 	.word	0x9500f03e
 8008598:	340a      	adds	r4, #10
	for (i = 0; i < 12; i++) {
 800859a:	42a5      	cmp	r5, r4
 800859c:	f47f ae9f 	bne.w	80082de <pga411_Init+0x6a>
		reg = pga411_regs[DEV_CONTROL1];
 80085a0:	f8b6 4066 	ldrh.w	r4, [r6, #102]	; 0x66
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80085a4:	4668      	mov	r0, sp
		reg = pga411_regs[DEV_CONTROL1];
 80085a6:	f8b6 5068 	ldrh.w	r5, [r6, #104]	; 0x68
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80085aa:	4621      	mov	r1, r4
 80085ac:	462a      	mov	r2, r5
 80085ae:	f7fe ff6d 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.addr;
 80085b2:	b2e0      	uxtb	r0, r4
	out.frame = out.frame << 16;
 80085b4:	0401      	lsls	r1, r0, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 80085b6:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 80085b8:	005b      	lsls	r3, r3, #1
 80085ba:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80085be:	065e      	lsls	r6, r3, #25
 80085c0:	bf48      	it	mi
 80085c2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80085c6:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80085c8:	065a      	lsls	r2, r3, #25
 80085ca:	d502      	bpl.n	80085d2 <pga411_Init+0x35e>
 80085cc:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80085d0:	b29b      	uxth	r3, r3
             crc <<= 1;
 80085d2:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 80085d4:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 80085d6:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 80085d8:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80085dc:	065f      	lsls	r7, r3, #25
 80085de:	bf48      	it	mi
 80085e0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80085e4:	005b      	lsls	r3, r3, #1
 80085e6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80085e8:	065e      	lsls	r6, r3, #25
 80085ea:	bf48      	it	mi
 80085ec:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80085f0:	005b      	lsls	r3, r3, #1
 80085f2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80085f4:	065a      	lsls	r2, r3, #25
 80085f6:	bf48      	it	mi
 80085f8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80085fc:	005b      	lsls	r3, r3, #1
 80085fe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008600:	065f      	lsls	r7, r3, #25
 8008602:	bf48      	it	mi
 8008604:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008608:	404b      	eors	r3, r1
             crc <<= 1;
 800860a:	005b      	lsls	r3, r3, #1
 800860c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800860e:	065e      	lsls	r6, r3, #25
 8008610:	bf48      	it	mi
 8008612:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008616:	005b      	lsls	r3, r3, #1
 8008618:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800861a:	0659      	lsls	r1, r3, #25
 800861c:	bf48      	it	mi
 800861e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008622:	005b      	lsls	r3, r3, #1
 8008624:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008626:	065a      	lsls	r2, r3, #25
 8008628:	bf48      	it	mi
 800862a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800862e:	005b      	lsls	r3, r3, #1
 8008630:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008632:	065f      	lsls	r7, r3, #25
 8008634:	bf48      	it	mi
 8008636:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800863a:	005b      	lsls	r3, r3, #1
 800863c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800863e:	065e      	lsls	r6, r3, #25
 8008640:	bf48      	it	mi
 8008642:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008646:	005b      	lsls	r3, r3, #1
 8008648:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800864a:	0659      	lsls	r1, r3, #25
 800864c:	bf48      	it	mi
 800864e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008652:	005b      	lsls	r3, r3, #1
 8008654:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008656:	065a      	lsls	r2, r3, #25
 8008658:	bf48      	it	mi
 800865a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800865e:	005b      	lsls	r3, r3, #1
 8008660:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008662:	065f      	lsls	r7, r3, #25
 8008664:	bf48      	it	mi
 8008666:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800866a:	005b      	lsls	r3, r3, #1
 800866c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800866e:	065e      	lsls	r6, r3, #25
 8008670:	bf48      	it	mi
 8008672:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008676:	005b      	lsls	r3, r3, #1
 8008678:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800867a:	0659      	lsls	r1, r3, #25
 800867c:	bf48      	it	mi
 800867e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008682:	005b      	lsls	r3, r3, #1
 8008684:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008686:	065a      	lsls	r2, r3, #25
 8008688:	bf48      	it	mi
 800868a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800868e:	005b      	lsls	r3, r3, #1
 8008690:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008692:	065f      	lsls	r7, r3, #25
 8008694:	bf48      	it	mi
 8008696:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800869a:	005b      	lsls	r3, r3, #1
 800869c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800869e:	065e      	lsls	r6, r3, #25
 80086a0:	bf48      	it	mi
 80086a2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80086a6:	005b      	lsls	r3, r3, #1
 80086a8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086aa:	0659      	lsls	r1, r3, #25
 80086ac:	bf48      	it	mi
 80086ae:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80086b2:	005b      	lsls	r3, r3, #1
 80086b4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086b6:	065a      	lsls	r2, r3, #25
 80086b8:	bf48      	it	mi
 80086ba:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80086be:	005b      	lsls	r3, r3, #1
 80086c0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086c2:	065f      	lsls	r7, r3, #25
 80086c4:	bf48      	it	mi
 80086c6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80086ca:	005b      	lsls	r3, r3, #1
 80086cc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086ce:	065e      	lsls	r6, r3, #25
 80086d0:	bf48      	it	mi
 80086d2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80086d6:	005b      	lsls	r3, r3, #1
 80086d8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086da:	0659      	lsls	r1, r3, #25
 80086dc:	bf48      	it	mi
 80086de:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 80086e2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 80086e6:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
 80086ea:	f7fe fe71 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 80086ee:	f000 013f 	and.w	r1, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 80086f2:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 80086f4:	0a06      	lsrs	r6, r0, #8
             crc <<= 1;
 80086f6:	005b      	lsls	r3, r3, #1
 80086f8:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80086fc:	065a      	lsls	r2, r3, #25
 80086fe:	bf48      	it	mi
 8008700:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008704:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008706:	065f      	lsls	r7, r3, #25
 8008708:	d502      	bpl.n	8008710 <pga411_Init+0x49c>
 800870a:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 800870e:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008710:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008712:	b2b6      	uxth	r6, r6
             crc <<= 1;
 8008714:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008716:	065a      	lsls	r2, r3, #25
 8008718:	bf48      	it	mi
 800871a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800871e:	005b      	lsls	r3, r3, #1
 8008720:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008722:	065f      	lsls	r7, r3, #25
 8008724:	bf48      	it	mi
 8008726:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800872a:	005b      	lsls	r3, r3, #1
 800872c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800872e:	065a      	lsls	r2, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008730:	f3c0 5205 	ubfx	r2, r0, #20, #6
 8008734:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8008738:	bf48      	it	mi
 800873a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800873e:	005b      	lsls	r3, r3, #1
 8008740:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008742:	065f      	lsls	r7, r3, #25
 8008744:	bf48      	it	mi
 8008746:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 800874a:	4053      	eors	r3, r2
             crc <<= 1;
 800874c:	005b      	lsls	r3, r3, #1
 800874e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008750:	065a      	lsls	r2, r3, #25
 8008752:	bf48      	it	mi
 8008754:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008758:	005b      	lsls	r3, r3, #1
 800875a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800875c:	065f      	lsls	r7, r3, #25
 800875e:	bf48      	it	mi
 8008760:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008764:	005b      	lsls	r3, r3, #1
 8008766:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008768:	065a      	lsls	r2, r3, #25
 800876a:	bf48      	it	mi
 800876c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008770:	005b      	lsls	r3, r3, #1
 8008772:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008774:	065f      	lsls	r7, r3, #25
 8008776:	bf48      	it	mi
 8008778:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800877c:	005b      	lsls	r3, r3, #1
 800877e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008780:	065a      	lsls	r2, r3, #25
 8008782:	bf48      	it	mi
 8008784:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008788:	005b      	lsls	r3, r3, #1
 800878a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800878c:	065f      	lsls	r7, r3, #25
 800878e:	bf48      	it	mi
 8008790:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008794:	4043      	eors	r3, r0
             crc <<= 1;
 8008796:	005b      	lsls	r3, r3, #1
 8008798:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800879a:	0658      	lsls	r0, r3, #25
 800879c:	bf48      	it	mi
 800879e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80087a2:	005b      	lsls	r3, r3, #1
 80087a4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087a6:	065a      	lsls	r2, r3, #25
 80087a8:	bf48      	it	mi
 80087aa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80087ae:	005b      	lsls	r3, r3, #1
 80087b0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087b2:	065f      	lsls	r7, r3, #25
 80087b4:	bf48      	it	mi
 80087b6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80087ba:	005b      	lsls	r3, r3, #1
 80087bc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087be:	0658      	lsls	r0, r3, #25
 80087c0:	bf48      	it	mi
 80087c2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80087c6:	005b      	lsls	r3, r3, #1
 80087c8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087ca:	065a      	lsls	r2, r3, #25
 80087cc:	bf48      	it	mi
 80087ce:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80087d2:	005b      	lsls	r3, r3, #1
 80087d4:	b29a      	uxth	r2, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087d6:	0653      	lsls	r3, r2, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 80087d8:	f006 033f 	and.w	r3, r6, #63	; 0x3f
 80087dc:	bf48      	it	mi
 80087de:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
 80087e2:	405a      	eors	r2, r3
             crc <<= 1;
 80087e4:	0052      	lsls	r2, r2, #1
 80087e6:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087e8:	0657      	lsls	r7, r2, #25
 80087ea:	bf48      	it	mi
 80087ec:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80087f0:	0052      	lsls	r2, r2, #1
 80087f2:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80087f4:	0650      	lsls	r0, r2, #25
 80087f6:	bf48      	it	mi
 80087f8:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 80087fc:	0052      	lsls	r2, r2, #1
 80087fe:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008800:	0653      	lsls	r3, r2, #25
 8008802:	bf48      	it	mi
 8008804:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8008808:	0052      	lsls	r2, r2, #1
 800880a:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800880c:	0657      	lsls	r7, r2, #25
 800880e:	bf48      	it	mi
 8008810:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8008814:	0052      	lsls	r2, r2, #1
 8008816:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008818:	0650      	lsls	r0, r2, #25
 800881a:	bf48      	it	mi
 800881c:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
             crc <<= 1;
 8008820:	0052      	lsls	r2, r2, #1
 8008822:	b292      	uxth	r2, r2
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008824:	0653      	lsls	r3, r2, #25
 8008826:	bf48      	it	mi
 8008828:	f082 025b 	eormi.w	r2, r2, #91	; 0x5b
	if (crc2!= in.scrc) {
 800882c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8008830:	428a      	cmp	r2, r1
 8008832:	d000      	beq.n	8008836 <pga411_Init+0x5c2>
		asm("NOP"); /* if error -> terminate */
 8008834:	bf00      	nop
	hal_Xmit4BSPI(0x95000F39);
 8008836:	4815      	ldr	r0, [pc, #84]	; (800888c <pga411_Init+0x618>)
 8008838:	f7fe fdca 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x95005522);
 800883c:	4814      	ldr	r0, [pc, #80]	; (8008890 <pga411_Init+0x61c>)
 800883e:	f7fe fdc7 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x9500AA25);
 8008842:	4814      	ldr	r0, [pc, #80]	; (8008894 <pga411_Init+0x620>)
 8008844:	f7fe fdc4 	bl	80073d0 <hal_Xmit4BSPI>
	hal_Xmit4BSPI(0x9500F03E);
 8008848:	4813      	ldr	r0, [pc, #76]	; (8008898 <pga411_Init+0x624>)
 800884a:	f7fe fdc1 	bl	80073d0 <hal_Xmit4BSPI>
	pga411_XmitSPI(WRITE,reg,data);
 800884e:	f046 0301 	orr.w	r3, r6, #1
 8008852:	462a      	mov	r2, r5
 8008854:	4621      	mov	r1, r4
 8008856:	4668      	mov	r0, sp
	ignore_crc_error = TRUE;
 8008858:	4c10      	ldr	r4, [pc, #64]	; (800889c <pga411_Init+0x628>)
	pga411_XmitSPI(WRITE,reg,data);
 800885a:	f7fe ff65 	bl	8007728 <pga411_XmitSPI.isra.0.constprop.6>
	HAL_Delay(100);
 800885e:	2064      	movs	r0, #100	; 0x64
 8008860:	f7f7 feac 	bl	80005bc <HAL_Delay>
	HAL_GPIO_WritePin(GPIOB, RDC_FAULTRES_Pin, HIGH); /* return back to high-z*/
 8008864:	2201      	movs	r2, #1
 8008866:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800886a:	480d      	ldr	r0, [pc, #52]	; (80088a0 <pga411_Init+0x62c>)
 800886c:	f7f9 fc56 	bl	800211c <HAL_GPIO_WritePin>
	HAL_Delay(100);
 8008870:	2064      	movs	r0, #100	; 0x64
 8008872:	f7f7 fea3 	bl	80005bc <HAL_Delay>
	pga411_ReadAll();
 8008876:	f7ff fa53 	bl	8007d20 <pga411_ReadAll>
	ignore_crc_error = TRUE;
 800887a:	2301      	movs	r3, #1
	fast_txrx(VELOCITY_FRAME); 	// get theta ask for velocity
 800887c:	4809      	ldr	r0, [pc, #36]	; (80088a4 <pga411_Init+0x630>)
	ignore_crc_error = TRUE;
 800887e:	7023      	strb	r3, [r4, #0]
	fast_txrx(VELOCITY_FRAME); 	// get theta ask for velocity
 8008880:	f7ff f8a4 	bl	80079cc <fast_txrx>
	ignore_crc_error = FALSE;
 8008884:	2300      	movs	r3, #0
 8008886:	7023      	strb	r3, [r4, #0]
}
 8008888:	b005      	add	sp, #20
 800888a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800888c:	95000f39 	.word	0x95000f39
 8008890:	95005522 	.word	0x95005522
 8008894:	9500aa25 	.word	0x9500aa25
 8008898:	9500f03e 	.word	0x9500f03e
 800889c:	2006963c 	.word	0x2006963c
 80088a0:	40020400 	.word	0x40020400
 80088a4:	6f000003 	.word	0x6f000003

080088a8 <pga411_checkFaults>:
void pga411_checkFaults(void) {
 80088a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	mc_faults.rdc_faults_reg1 = pga411_ReadReg(pga411_regs[DEV_STAT1]);
 80088aa:	4db3      	ldr	r5, [pc, #716]	; (8008b78 <pga411_checkFaults+0x2d0>)
void pga411_checkFaults(void) {
 80088ac:	b085      	sub	sp, #20
	mc_faults.rdc_faults_reg1 = pga411_ReadReg(pga411_regs[DEV_STAT1]);
 80088ae:	f8b5 4084 	ldrh.w	r4, [r5, #132]	; 0x84
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80088b2:	4668      	mov	r0, sp
 80088b4:	f8b5 2086 	ldrh.w	r2, [r5, #134]	; 0x86
 80088b8:	4621      	mov	r1, r4
	out.frame = out.addr;
 80088ba:	b2e4      	uxtb	r4, r4
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 80088bc:	f7fe fde6 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.frame << 16;
 80088c0:	0421      	lsls	r1, r4, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 80088c2:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 80088c4:	005b      	lsls	r3, r3, #1
 80088c6:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80088ca:	065e      	lsls	r6, r3, #25
 80088cc:	bf48      	it	mi
 80088ce:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80088d2:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80088d4:	0658      	lsls	r0, r3, #25
 80088d6:	d502      	bpl.n	80088de <pga411_checkFaults+0x36>
 80088d8:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80088dc:	b29b      	uxth	r3, r3
             crc <<= 1;
 80088de:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 80088e0:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 80088e2:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 80088e4:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80088e8:	065a      	lsls	r2, r3, #25
 80088ea:	bf48      	it	mi
 80088ec:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80088f0:	005b      	lsls	r3, r3, #1
 80088f2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80088f4:	065f      	lsls	r7, r3, #25
 80088f6:	bf48      	it	mi
 80088f8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80088fc:	005b      	lsls	r3, r3, #1
 80088fe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008900:	065e      	lsls	r6, r3, #25
 8008902:	bf48      	it	mi
 8008904:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008908:	005b      	lsls	r3, r3, #1
 800890a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800890c:	0658      	lsls	r0, r3, #25
 800890e:	bf48      	it	mi
 8008910:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008914:	404b      	eors	r3, r1
             crc <<= 1;
 8008916:	005b      	lsls	r3, r3, #1
 8008918:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800891a:	0659      	lsls	r1, r3, #25
 800891c:	bf48      	it	mi
 800891e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008922:	005b      	lsls	r3, r3, #1
 8008924:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008926:	065a      	lsls	r2, r3, #25
 8008928:	bf48      	it	mi
 800892a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800892e:	005b      	lsls	r3, r3, #1
 8008930:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008932:	065f      	lsls	r7, r3, #25
 8008934:	bf48      	it	mi
 8008936:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800893a:	005b      	lsls	r3, r3, #1
 800893c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800893e:	065e      	lsls	r6, r3, #25
 8008940:	bf48      	it	mi
 8008942:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008946:	005b      	lsls	r3, r3, #1
 8008948:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800894a:	0658      	lsls	r0, r3, #25
 800894c:	bf48      	it	mi
 800894e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008952:	005b      	lsls	r3, r3, #1
 8008954:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008956:	0659      	lsls	r1, r3, #25
 8008958:	bf48      	it	mi
 800895a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800895e:	005b      	lsls	r3, r3, #1
 8008960:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008962:	065a      	lsls	r2, r3, #25
 8008964:	bf48      	it	mi
 8008966:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800896a:	005b      	lsls	r3, r3, #1
 800896c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800896e:	065f      	lsls	r7, r3, #25
 8008970:	bf48      	it	mi
 8008972:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008976:	005b      	lsls	r3, r3, #1
 8008978:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800897a:	065e      	lsls	r6, r3, #25
 800897c:	bf48      	it	mi
 800897e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008982:	005b      	lsls	r3, r3, #1
 8008984:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008986:	0658      	lsls	r0, r3, #25
 8008988:	bf48      	it	mi
 800898a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800898e:	005b      	lsls	r3, r3, #1
 8008990:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008992:	0659      	lsls	r1, r3, #25
 8008994:	bf48      	it	mi
 8008996:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800899a:	005b      	lsls	r3, r3, #1
 800899c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800899e:	065a      	lsls	r2, r3, #25
 80089a0:	bf48      	it	mi
 80089a2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089a6:	005b      	lsls	r3, r3, #1
 80089a8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089aa:	065f      	lsls	r7, r3, #25
 80089ac:	bf48      	it	mi
 80089ae:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089b2:	005b      	lsls	r3, r3, #1
 80089b4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089b6:	065e      	lsls	r6, r3, #25
 80089b8:	bf48      	it	mi
 80089ba:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089be:	005b      	lsls	r3, r3, #1
 80089c0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089c2:	0658      	lsls	r0, r3, #25
 80089c4:	bf48      	it	mi
 80089c6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089ca:	005b      	lsls	r3, r3, #1
 80089cc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089ce:	0659      	lsls	r1, r3, #25
 80089d0:	bf48      	it	mi
 80089d2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089d6:	005b      	lsls	r3, r3, #1
 80089d8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089da:	065a      	lsls	r2, r3, #25
 80089dc:	bf48      	it	mi
 80089de:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80089e2:	005b      	lsls	r3, r3, #1
 80089e4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80089e6:	065f      	lsls	r7, r3, #25
 80089e8:	bf48      	it	mi
 80089ea:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 80089ee:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 80089f2:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 80089f6:	f7fe fceb 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 80089fa:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 80089fe:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 8008a00:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 8008a02:	005b      	lsls	r3, r3, #1
 8008a04:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a08:	065e      	lsls	r6, r3, #25
 8008a0a:	bf48      	it	mi
 8008a0c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a10:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a12:	065c      	lsls	r4, r3, #25
 8008a14:	d502      	bpl.n	8008a1c <pga411_checkFaults+0x174>
 8008a16:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008a1a:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008a1c:	005b      	lsls	r3, r3, #1
 8008a1e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a20:	065f      	lsls	r7, r3, #25
 8008a22:	bf48      	it	mi
 8008a24:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a28:	005b      	lsls	r3, r3, #1
 8008a2a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a2c:	065e      	lsls	r6, r3, #25
 8008a2e:	bf48      	it	mi
 8008a30:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a34:	005b      	lsls	r3, r3, #1
 8008a36:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a38:	065c      	lsls	r4, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008a3a:	f3c0 5405 	ubfx	r4, r0, #20, #6
 8008a3e:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8008a42:	bf48      	it	mi
 8008a44:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a48:	005b      	lsls	r3, r3, #1
 8008a4a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a4c:	065f      	lsls	r7, r3, #25
 8008a4e:	bf48      	it	mi
 8008a50:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008a54:	4063      	eors	r3, r4
             crc <<= 1;
 8008a56:	005b      	lsls	r3, r3, #1
 8008a58:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a5a:	065e      	lsls	r6, r3, #25
 8008a5c:	bf48      	it	mi
 8008a5e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a62:	005b      	lsls	r3, r3, #1
 8008a64:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a66:	065c      	lsls	r4, r3, #25
 8008a68:	bf48      	it	mi
 8008a6a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a6e:	005b      	lsls	r3, r3, #1
 8008a70:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a72:	065f      	lsls	r7, r3, #25
 8008a74:	bf48      	it	mi
 8008a76:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a7a:	005b      	lsls	r3, r3, #1
 8008a7c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a7e:	065e      	lsls	r6, r3, #25
 8008a80:	bf48      	it	mi
 8008a82:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a86:	005b      	lsls	r3, r3, #1
 8008a88:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a8a:	065c      	lsls	r4, r3, #25
 8008a8c:	bf48      	it	mi
 8008a8e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008a92:	005b      	lsls	r3, r3, #1
 8008a94:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008a96:	065f      	lsls	r7, r3, #25
 8008a98:	bf48      	it	mi
 8008a9a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008a9e:	4043      	eors	r3, r0
             crc <<= 1;
 8008aa0:	005b      	lsls	r3, r3, #1
 8008aa2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008aa4:	065e      	lsls	r6, r3, #25
 8008aa6:	bf48      	it	mi
 8008aa8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008aac:	005b      	lsls	r3, r3, #1
 8008aae:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ab0:	065c      	lsls	r4, r3, #25
 8008ab2:	bf48      	it	mi
 8008ab4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ab8:	005b      	lsls	r3, r3, #1
 8008aba:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008abc:	0658      	lsls	r0, r3, #25
 8008abe:	bf48      	it	mi
 8008ac0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ac4:	005b      	lsls	r3, r3, #1
 8008ac6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ac8:	065f      	lsls	r7, r3, #25
 8008aca:	bf48      	it	mi
 8008acc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ad0:	005b      	lsls	r3, r3, #1
 8008ad2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ad4:	065e      	lsls	r6, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008ad6:	b28e      	uxth	r6, r1
 8008ad8:	bf48      	it	mi
 8008ada:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008ade:	f006 013f 	and.w	r1, r6, #63	; 0x3f
             crc <<= 1;
 8008ae2:	005b      	lsls	r3, r3, #1
 8008ae4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ae6:	065c      	lsls	r4, r3, #25
 8008ae8:	bf48      	it	mi
 8008aea:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008aee:	404b      	eors	r3, r1
             crc <<= 1;
 8008af0:	005b      	lsls	r3, r3, #1
 8008af2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008af4:	0658      	lsls	r0, r3, #25
 8008af6:	bf48      	it	mi
 8008af8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008afc:	005b      	lsls	r3, r3, #1
 8008afe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b00:	0659      	lsls	r1, r3, #25
 8008b02:	bf48      	it	mi
 8008b04:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b08:	005b      	lsls	r3, r3, #1
 8008b0a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b0c:	065f      	lsls	r7, r3, #25
 8008b0e:	bf48      	it	mi
 8008b10:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b14:	005b      	lsls	r3, r3, #1
 8008b16:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b18:	065c      	lsls	r4, r3, #25
 8008b1a:	bf48      	it	mi
 8008b1c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b20:	005b      	lsls	r3, r3, #1
 8008b22:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b24:	0658      	lsls	r0, r3, #25
 8008b26:	bf48      	it	mi
 8008b28:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b2c:	005b      	lsls	r3, r3, #1
 8008b2e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b30:	0659      	lsls	r1, r3, #25
 8008b32:	bf48      	it	mi
 8008b34:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8008b38:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008b3c:	4293      	cmp	r3, r2
 8008b3e:	d000      	beq.n	8008b42 <pga411_checkFaults+0x29a>
		asm("NOP"); /* if error -> terminate */
 8008b40:	bf00      	nop
	mc_faults.rdc_faults_reg2 = pga411_ReadReg(pga411_regs[DEV_STAT3]);
 8008b42:	f8b5 7098 	ldrh.w	r7, [r5, #152]	; 0x98
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008b46:	4668      	mov	r0, sp
	mc_faults.rdc_faults_reg1 = pga411_ReadReg(pga411_regs[DEV_STAT1]);
 8008b48:	4c0c      	ldr	r4, [pc, #48]	; (8008b7c <pga411_checkFaults+0x2d4>)
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008b4a:	4639      	mov	r1, r7
	out.frame = out.addr;
 8008b4c:	b2ff      	uxtb	r7, r7
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008b4e:	f8b5 209a 	ldrh.w	r2, [r5, #154]	; 0x9a
	mc_faults.rdc_faults_reg1 = pga411_ReadReg(pga411_regs[DEV_STAT1]);
 8008b52:	8026      	strh	r6, [r4, #0]
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008b54:	f7fe fc9a 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.frame << 16;
 8008b58:	0439      	lsls	r1, r7, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8008b5a:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 8008b5c:	005b      	lsls	r3, r3, #1
 8008b5e:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b62:	065a      	lsls	r2, r3, #25
 8008b64:	bf48      	it	mi
 8008b66:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b6a:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b6c:	065e      	lsls	r6, r3, #25
 8008b6e:	d507      	bpl.n	8008b80 <pga411_checkFaults+0x2d8>
 8008b70:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008b74:	b29b      	uxth	r3, r3
 8008b76:	e003      	b.n	8008b80 <pga411_checkFaults+0x2d8>
 8008b78:	20001f50 	.word	0x20001f50
 8008b7c:	20002120 	.word	0x20002120
             crc <<= 1;
 8008b80:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008b82:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 8008b84:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 8008b86:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b8a:	0658      	lsls	r0, r3, #25
 8008b8c:	bf48      	it	mi
 8008b8e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b92:	005b      	lsls	r3, r3, #1
 8008b94:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008b96:	065a      	lsls	r2, r3, #25
 8008b98:	bf48      	it	mi
 8008b9a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008b9e:	005b      	lsls	r3, r3, #1
 8008ba0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ba2:	065e      	lsls	r6, r3, #25
 8008ba4:	bf48      	it	mi
 8008ba6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008baa:	005b      	lsls	r3, r3, #1
 8008bac:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bae:	0658      	lsls	r0, r3, #25
 8008bb0:	bf48      	it	mi
 8008bb2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008bb6:	404b      	eors	r3, r1
             crc <<= 1;
 8008bb8:	005b      	lsls	r3, r3, #1
 8008bba:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bbc:	0659      	lsls	r1, r3, #25
 8008bbe:	bf48      	it	mi
 8008bc0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008bc4:	005b      	lsls	r3, r3, #1
 8008bc6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bc8:	065a      	lsls	r2, r3, #25
 8008bca:	bf48      	it	mi
 8008bcc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008bd0:	005b      	lsls	r3, r3, #1
 8008bd2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bd4:	065e      	lsls	r6, r3, #25
 8008bd6:	bf48      	it	mi
 8008bd8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008bdc:	005b      	lsls	r3, r3, #1
 8008bde:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008be0:	0658      	lsls	r0, r3, #25
 8008be2:	bf48      	it	mi
 8008be4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008be8:	005b      	lsls	r3, r3, #1
 8008bea:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bec:	0659      	lsls	r1, r3, #25
 8008bee:	bf48      	it	mi
 8008bf0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008bf4:	005b      	lsls	r3, r3, #1
 8008bf6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008bf8:	065a      	lsls	r2, r3, #25
 8008bfa:	bf48      	it	mi
 8008bfc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c00:	005b      	lsls	r3, r3, #1
 8008c02:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c04:	065e      	lsls	r6, r3, #25
 8008c06:	bf48      	it	mi
 8008c08:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c0c:	005b      	lsls	r3, r3, #1
 8008c0e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c10:	0658      	lsls	r0, r3, #25
 8008c12:	bf48      	it	mi
 8008c14:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c18:	005b      	lsls	r3, r3, #1
 8008c1a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c1c:	0659      	lsls	r1, r3, #25
 8008c1e:	bf48      	it	mi
 8008c20:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c24:	005b      	lsls	r3, r3, #1
 8008c26:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c28:	065a      	lsls	r2, r3, #25
 8008c2a:	bf48      	it	mi
 8008c2c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c30:	005b      	lsls	r3, r3, #1
 8008c32:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c34:	065e      	lsls	r6, r3, #25
 8008c36:	bf48      	it	mi
 8008c38:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c3c:	005b      	lsls	r3, r3, #1
 8008c3e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c40:	0658      	lsls	r0, r3, #25
 8008c42:	bf48      	it	mi
 8008c44:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c48:	005b      	lsls	r3, r3, #1
 8008c4a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c4c:	0659      	lsls	r1, r3, #25
 8008c4e:	bf48      	it	mi
 8008c50:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c54:	005b      	lsls	r3, r3, #1
 8008c56:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c58:	065a      	lsls	r2, r3, #25
 8008c5a:	bf48      	it	mi
 8008c5c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c60:	005b      	lsls	r3, r3, #1
 8008c62:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c64:	065e      	lsls	r6, r3, #25
 8008c66:	bf48      	it	mi
 8008c68:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c6c:	005b      	lsls	r3, r3, #1
 8008c6e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c70:	0658      	lsls	r0, r3, #25
 8008c72:	bf48      	it	mi
 8008c74:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c78:	005b      	lsls	r3, r3, #1
 8008c7a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c7c:	0659      	lsls	r1, r3, #25
 8008c7e:	bf48      	it	mi
 8008c80:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008c84:	005b      	lsls	r3, r3, #1
 8008c86:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008c88:	065a      	lsls	r2, r3, #25
 8008c8a:	bf48      	it	mi
 8008c8c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 8008c90:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 8008c94:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
 8008c98:	f7fe fb9a 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8008c9c:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 8008ca0:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 8008ca2:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 8008ca4:	005b      	lsls	r3, r3, #1
 8008ca6:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008caa:	065f      	lsls	r7, r3, #25
 8008cac:	bf48      	it	mi
 8008cae:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008cb2:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008cb4:	065e      	lsls	r6, r3, #25
 8008cb6:	d502      	bpl.n	8008cbe <pga411_checkFaults+0x416>
 8008cb8:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008cbc:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008cbe:	005b      	lsls	r3, r3, #1
 8008cc0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008cc2:	065f      	lsls	r7, r3, #25
 8008cc4:	bf48      	it	mi
 8008cc6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008cca:	005b      	lsls	r3, r3, #1
 8008ccc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008cce:	065e      	lsls	r6, r3, #25
 8008cd0:	bf48      	it	mi
 8008cd2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008cd6:	005b      	lsls	r3, r3, #1
 8008cd8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008cda:	065f      	lsls	r7, r3, #25
 8008cdc:	bf48      	it	mi
 8008cde:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ce2:	005b      	lsls	r3, r3, #1
 8008ce4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ce6:	065e      	lsls	r6, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008ce8:	f3c0 5605 	ubfx	r6, r0, #20, #6
 8008cec:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8008cf0:	bf48      	it	mi
 8008cf2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008cf6:	4073      	eors	r3, r6
             crc <<= 1;
 8008cf8:	005b      	lsls	r3, r3, #1
 8008cfa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008cfc:	065f      	lsls	r7, r3, #25
 8008cfe:	bf48      	it	mi
 8008d00:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d04:	005b      	lsls	r3, r3, #1
 8008d06:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d08:	065e      	lsls	r6, r3, #25
 8008d0a:	bf48      	it	mi
 8008d0c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d10:	005b      	lsls	r3, r3, #1
 8008d12:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d14:	065f      	lsls	r7, r3, #25
 8008d16:	bf48      	it	mi
 8008d18:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d1c:	005b      	lsls	r3, r3, #1
 8008d1e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d20:	065e      	lsls	r6, r3, #25
 8008d22:	bf48      	it	mi
 8008d24:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d28:	005b      	lsls	r3, r3, #1
 8008d2a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d2c:	065f      	lsls	r7, r3, #25
 8008d2e:	bf48      	it	mi
 8008d30:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d34:	005b      	lsls	r3, r3, #1
 8008d36:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d38:	065e      	lsls	r6, r3, #25
 8008d3a:	bf48      	it	mi
 8008d3c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008d40:	4043      	eors	r3, r0
             crc <<= 1;
 8008d42:	005b      	lsls	r3, r3, #1
 8008d44:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d46:	065f      	lsls	r7, r3, #25
 8008d48:	bf48      	it	mi
 8008d4a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d4e:	005b      	lsls	r3, r3, #1
 8008d50:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d52:	065e      	lsls	r6, r3, #25
 8008d54:	bf48      	it	mi
 8008d56:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d5a:	005b      	lsls	r3, r3, #1
 8008d5c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d5e:	0658      	lsls	r0, r3, #25
 8008d60:	bf48      	it	mi
 8008d62:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d66:	005b      	lsls	r3, r3, #1
 8008d68:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d6a:	065f      	lsls	r7, r3, #25
 8008d6c:	bf48      	it	mi
 8008d6e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d72:	005b      	lsls	r3, r3, #1
 8008d74:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d76:	065e      	lsls	r6, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008d78:	b28e      	uxth	r6, r1
 8008d7a:	bf48      	it	mi
 8008d7c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008d80:	f006 013f 	and.w	r1, r6, #63	; 0x3f
             crc <<= 1;
 8008d84:	005b      	lsls	r3, r3, #1
 8008d86:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d88:	0658      	lsls	r0, r3, #25
 8008d8a:	bf48      	it	mi
 8008d8c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008d90:	404b      	eors	r3, r1
             crc <<= 1;
 8008d92:	005b      	lsls	r3, r3, #1
 8008d94:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008d96:	065f      	lsls	r7, r3, #25
 8008d98:	bf48      	it	mi
 8008d9a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008d9e:	005b      	lsls	r3, r3, #1
 8008da0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008da2:	0658      	lsls	r0, r3, #25
 8008da4:	bf48      	it	mi
 8008da6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008daa:	005b      	lsls	r3, r3, #1
 8008dac:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008dae:	0659      	lsls	r1, r3, #25
 8008db0:	bf48      	it	mi
 8008db2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008db6:	005b      	lsls	r3, r3, #1
 8008db8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008dba:	065f      	lsls	r7, r3, #25
 8008dbc:	bf48      	it	mi
 8008dbe:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008dc2:	005b      	lsls	r3, r3, #1
 8008dc4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008dc6:	0658      	lsls	r0, r3, #25
 8008dc8:	bf48      	it	mi
 8008dca:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008dce:	005b      	lsls	r3, r3, #1
 8008dd0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008dd2:	0659      	lsls	r1, r3, #25
 8008dd4:	bf48      	it	mi
 8008dd6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8008dda:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008dde:	4293      	cmp	r3, r2
 8008de0:	d000      	beq.n	8008de4 <pga411_checkFaults+0x53c>
		asm("NOP"); /* if error -> terminate */
 8008de2:	bf00      	nop
	mc_faults.rdc_faults_reg3 = pga411_ReadReg(pga411_regs[DEV_STAT4]);
 8008de4:	f8b5 70a2 	ldrh.w	r7, [r5, #162]	; 0xa2
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008de8:	4668      	mov	r0, sp
 8008dea:	f8b5 20a4 	ldrh.w	r2, [r5, #164]	; 0xa4
 8008dee:	4639      	mov	r1, r7
	out.frame = out.addr;
 8008df0:	b2ff      	uxtb	r7, r7
	mc_faults.rdc_faults_reg2 = pga411_ReadReg(pga411_regs[DEV_STAT3]);
 8008df2:	8066      	strh	r6, [r4, #2]
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8008df4:	f7fe fb4a 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.frame << 16;
 8008df8:	0439      	lsls	r1, r7, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8008dfa:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 8008dfc:	005b      	lsls	r3, r3, #1
 8008dfe:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e02:	065a      	lsls	r2, r3, #25
 8008e04:	bf48      	it	mi
 8008e06:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e0a:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e0c:	065e      	lsls	r6, r3, #25
 8008e0e:	d502      	bpl.n	8008e16 <pga411_checkFaults+0x56e>
 8008e10:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008e14:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008e16:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008e18:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 8008e1a:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 8008e1c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e20:	0658      	lsls	r0, r3, #25
 8008e22:	bf48      	it	mi
 8008e24:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e28:	005b      	lsls	r3, r3, #1
 8008e2a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e2c:	065a      	lsls	r2, r3, #25
 8008e2e:	bf48      	it	mi
 8008e30:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e34:	005b      	lsls	r3, r3, #1
 8008e36:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e38:	065e      	lsls	r6, r3, #25
 8008e3a:	bf48      	it	mi
 8008e3c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e40:	005b      	lsls	r3, r3, #1
 8008e42:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e44:	0658      	lsls	r0, r3, #25
 8008e46:	bf48      	it	mi
 8008e48:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008e4c:	404b      	eors	r3, r1
             crc <<= 1;
 8008e4e:	005b      	lsls	r3, r3, #1
 8008e50:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e52:	0659      	lsls	r1, r3, #25
 8008e54:	bf48      	it	mi
 8008e56:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e5a:	005b      	lsls	r3, r3, #1
 8008e5c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e5e:	065a      	lsls	r2, r3, #25
 8008e60:	bf48      	it	mi
 8008e62:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e66:	005b      	lsls	r3, r3, #1
 8008e68:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e6a:	065e      	lsls	r6, r3, #25
 8008e6c:	bf48      	it	mi
 8008e6e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e72:	005b      	lsls	r3, r3, #1
 8008e74:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e76:	0658      	lsls	r0, r3, #25
 8008e78:	bf48      	it	mi
 8008e7a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e7e:	005b      	lsls	r3, r3, #1
 8008e80:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e82:	0659      	lsls	r1, r3, #25
 8008e84:	bf48      	it	mi
 8008e86:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e8a:	005b      	lsls	r3, r3, #1
 8008e8c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e8e:	065a      	lsls	r2, r3, #25
 8008e90:	bf48      	it	mi
 8008e92:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008e96:	005b      	lsls	r3, r3, #1
 8008e98:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008e9a:	065e      	lsls	r6, r3, #25
 8008e9c:	bf48      	it	mi
 8008e9e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ea2:	005b      	lsls	r3, r3, #1
 8008ea4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ea6:	0658      	lsls	r0, r3, #25
 8008ea8:	bf48      	it	mi
 8008eaa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008eae:	005b      	lsls	r3, r3, #1
 8008eb0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008eb2:	0659      	lsls	r1, r3, #25
 8008eb4:	bf48      	it	mi
 8008eb6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008eba:	005b      	lsls	r3, r3, #1
 8008ebc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ebe:	065a      	lsls	r2, r3, #25
 8008ec0:	bf48      	it	mi
 8008ec2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ec6:	005b      	lsls	r3, r3, #1
 8008ec8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008eca:	065e      	lsls	r6, r3, #25
 8008ecc:	bf48      	it	mi
 8008ece:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ed2:	005b      	lsls	r3, r3, #1
 8008ed4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ed6:	0658      	lsls	r0, r3, #25
 8008ed8:	bf48      	it	mi
 8008eda:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ede:	005b      	lsls	r3, r3, #1
 8008ee0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ee2:	0659      	lsls	r1, r3, #25
 8008ee4:	bf48      	it	mi
 8008ee6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008eea:	005b      	lsls	r3, r3, #1
 8008eec:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008eee:	065a      	lsls	r2, r3, #25
 8008ef0:	bf48      	it	mi
 8008ef2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ef6:	005b      	lsls	r3, r3, #1
 8008ef8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008efa:	065e      	lsls	r6, r3, #25
 8008efc:	bf48      	it	mi
 8008efe:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f02:	005b      	lsls	r3, r3, #1
 8008f04:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f06:	0658      	lsls	r0, r3, #25
 8008f08:	bf48      	it	mi
 8008f0a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f0e:	005b      	lsls	r3, r3, #1
 8008f10:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f12:	0659      	lsls	r1, r3, #25
 8008f14:	bf48      	it	mi
 8008f16:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f1a:	005b      	lsls	r3, r3, #1
 8008f1c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f1e:	065a      	lsls	r2, r3, #25
 8008f20:	bf48      	it	mi
 8008f22:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 8008f26:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 8008f2a:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
 8008f2e:	f7fe fa4f 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 8008f32:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 8008f36:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 8008f38:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 8008f3a:	005b      	lsls	r3, r3, #1
 8008f3c:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f40:	065f      	lsls	r7, r3, #25
 8008f42:	bf48      	it	mi
 8008f44:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f48:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f4a:	065e      	lsls	r6, r3, #25
 8008f4c:	d502      	bpl.n	8008f54 <pga411_checkFaults+0x6ac>
 8008f4e:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 8008f52:	b29b      	uxth	r3, r3
             crc <<= 1;
 8008f54:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 8008f56:	b289      	uxth	r1, r1
             crc <<= 1;
 8008f58:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f5a:	065f      	lsls	r7, r3, #25
 8008f5c:	bf48      	it	mi
 8008f5e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f62:	005b      	lsls	r3, r3, #1
 8008f64:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f66:	065e      	lsls	r6, r3, #25
 8008f68:	bf48      	it	mi
 8008f6a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f6e:	005b      	lsls	r3, r3, #1
 8008f70:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f72:	065f      	lsls	r7, r3, #25
 8008f74:	bf48      	it	mi
 8008f76:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f7a:	005b      	lsls	r3, r3, #1
 8008f7c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f7e:	065e      	lsls	r6, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 8008f80:	f3c0 5605 	ubfx	r6, r0, #20, #6
 8008f84:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8008f88:	bf48      	it	mi
 8008f8a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8008f8e:	4073      	eors	r3, r6
             crc <<= 1;
 8008f90:	005b      	lsls	r3, r3, #1
 8008f92:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008f94:	065f      	lsls	r7, r3, #25
 8008f96:	bf48      	it	mi
 8008f98:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008f9c:	005b      	lsls	r3, r3, #1
 8008f9e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fa0:	065e      	lsls	r6, r3, #25
 8008fa2:	bf48      	it	mi
 8008fa4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008fa8:	005b      	lsls	r3, r3, #1
 8008faa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fac:	065f      	lsls	r7, r3, #25
 8008fae:	bf48      	it	mi
 8008fb0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008fb4:	005b      	lsls	r3, r3, #1
 8008fb6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fb8:	065e      	lsls	r6, r3, #25
 8008fba:	bf48      	it	mi
 8008fbc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008fc0:	005b      	lsls	r3, r3, #1
 8008fc2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fc4:	065f      	lsls	r7, r3, #25
 8008fc6:	bf48      	it	mi
 8008fc8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008fcc:	005b      	lsls	r3, r3, #1
 8008fce:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fd0:	065e      	lsls	r6, r3, #25
 8008fd2:	bf48      	it	mi
 8008fd4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8008fd8:	4043      	eors	r3, r0
             crc <<= 1;
 8008fda:	005b      	lsls	r3, r3, #1
 8008fdc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fde:	065f      	lsls	r7, r3, #25
 8008fe0:	bf48      	it	mi
 8008fe2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008fe6:	005b      	lsls	r3, r3, #1
 8008fe8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008fea:	065e      	lsls	r6, r3, #25
 8008fec:	bf48      	it	mi
 8008fee:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ff2:	005b      	lsls	r3, r3, #1
 8008ff4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8008ff6:	0658      	lsls	r0, r3, #25
 8008ff8:	bf48      	it	mi
 8008ffa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8008ffe:	005b      	lsls	r3, r3, #1
 8009000:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009002:	065f      	lsls	r7, r3, #25
 8009004:	bf48      	it	mi
 8009006:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800900a:	005b      	lsls	r3, r3, #1
 800900c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800900e:	065e      	lsls	r6, r3, #25
 8009010:	bf48      	it	mi
 8009012:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009016:	005b      	lsls	r3, r3, #1
 8009018:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800901a:	0658      	lsls	r0, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 800901c:	f001 003f 	and.w	r0, r1, #63	; 0x3f
 8009020:	bf48      	it	mi
 8009022:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8009026:	4043      	eors	r3, r0
             crc <<= 1;
 8009028:	005b      	lsls	r3, r3, #1
 800902a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800902c:	065f      	lsls	r7, r3, #25
 800902e:	bf48      	it	mi
 8009030:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009034:	005b      	lsls	r3, r3, #1
 8009036:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009038:	065e      	lsls	r6, r3, #25
 800903a:	bf48      	it	mi
 800903c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009040:	005b      	lsls	r3, r3, #1
 8009042:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009044:	0658      	lsls	r0, r3, #25
 8009046:	bf48      	it	mi
 8009048:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800904c:	005b      	lsls	r3, r3, #1
 800904e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009050:	065f      	lsls	r7, r3, #25
 8009052:	bf48      	it	mi
 8009054:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009058:	005b      	lsls	r3, r3, #1
 800905a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800905c:	065e      	lsls	r6, r3, #25
 800905e:	bf48      	it	mi
 8009060:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009064:	005b      	lsls	r3, r3, #1
 8009066:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009068:	0658      	lsls	r0, r3, #25
 800906a:	bf48      	it	mi
 800906c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 8009070:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009074:	4293      	cmp	r3, r2
 8009076:	d000      	beq.n	800907a <pga411_checkFaults+0x7d2>
		asm("NOP"); /* if error -> terminate */
 8009078:	bf00      	nop
	mc_faults.rdc_faults_reg4 = pga411_ReadReg(pga411_regs[DEV_STAT7]);
 800907a:	f8b5 60c0 	ldrh.w	r6, [r5, #192]	; 0xc0
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 800907e:	4668      	mov	r0, sp
	mc_faults.rdc_faults_reg3 &= DEV_STAT4_FAULT_BITS;
 8009080:	4bb3      	ldr	r3, [pc, #716]	; (8009350 <pga411_checkFaults+0xaa8>)
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8009082:	f8b5 20c2 	ldrh.w	r2, [r5, #194]	; 0xc2
	mc_faults.rdc_faults_reg3 &= DEV_STAT4_FAULT_BITS;
 8009086:	400b      	ands	r3, r1
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 8009088:	4631      	mov	r1, r6
	out.frame = out.addr;
 800908a:	b2f6      	uxtb	r6, r6
	mc_faults.rdc_faults_reg3 &= DEV_STAT4_FAULT_BITS;
 800908c:	80a3      	strh	r3, [r4, #4]
	pga411_XmitSPI(READ, reg, SPI_DUMMY);
 800908e:	f7fe f9fd 	bl	800748c <pga411_XmitSPI.isra.0.constprop.5>
	out.frame = out.frame << 16;
 8009092:	0431      	lsls	r1, r6, #16
           crc ^= (datin >> byte_idx) & 0x3F;
 8009094:	0c8b      	lsrs	r3, r1, #18
             crc <<= 1;
 8009096:	005b      	lsls	r3, r3, #1
 8009098:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800909c:	065f      	lsls	r7, r3, #25
 800909e:	bf48      	it	mi
 80090a0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80090a4:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090a6:	065d      	lsls	r5, r3, #25
 80090a8:	d502      	bpl.n	80090b0 <pga411_checkFaults+0x808>
 80090aa:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80090ae:	b29b      	uxth	r3, r3
             crc <<= 1;
 80090b0:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 80090b2:	0b09      	lsrs	r1, r1, #12
             crc <<= 1;
 80090b4:	b29b      	uxth	r3, r3
           crc ^= (datin >> byte_idx) & 0x3F;
 80090b6:	f001 013f 	and.w	r1, r1, #63	; 0x3f
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090ba:	0658      	lsls	r0, r3, #25
 80090bc:	bf48      	it	mi
 80090be:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80090c2:	005b      	lsls	r3, r3, #1
 80090c4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090c6:	065a      	lsls	r2, r3, #25
 80090c8:	bf48      	it	mi
 80090ca:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80090ce:	005b      	lsls	r3, r3, #1
 80090d0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090d2:	065f      	lsls	r7, r3, #25
 80090d4:	bf48      	it	mi
 80090d6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80090da:	005b      	lsls	r3, r3, #1
 80090dc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090de:	065d      	lsls	r5, r3, #25
 80090e0:	bf48      	it	mi
 80090e2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 80090e6:	404b      	eors	r3, r1
             crc <<= 1;
 80090e8:	005b      	lsls	r3, r3, #1
 80090ea:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090ec:	0658      	lsls	r0, r3, #25
 80090ee:	bf48      	it	mi
 80090f0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80090f4:	005b      	lsls	r3, r3, #1
 80090f6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80090f8:	0659      	lsls	r1, r3, #25
 80090fa:	bf48      	it	mi
 80090fc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009100:	005b      	lsls	r3, r3, #1
 8009102:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009104:	065a      	lsls	r2, r3, #25
 8009106:	bf48      	it	mi
 8009108:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800910c:	005b      	lsls	r3, r3, #1
 800910e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009110:	065f      	lsls	r7, r3, #25
 8009112:	bf48      	it	mi
 8009114:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009118:	005b      	lsls	r3, r3, #1
 800911a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800911c:	065d      	lsls	r5, r3, #25
 800911e:	bf48      	it	mi
 8009120:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009124:	005b      	lsls	r3, r3, #1
 8009126:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009128:	0658      	lsls	r0, r3, #25
 800912a:	bf48      	it	mi
 800912c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009130:	005b      	lsls	r3, r3, #1
 8009132:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009134:	0659      	lsls	r1, r3, #25
 8009136:	bf48      	it	mi
 8009138:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800913c:	005b      	lsls	r3, r3, #1
 800913e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009140:	065a      	lsls	r2, r3, #25
 8009142:	bf48      	it	mi
 8009144:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009148:	005b      	lsls	r3, r3, #1
 800914a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800914c:	065f      	lsls	r7, r3, #25
 800914e:	bf48      	it	mi
 8009150:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009154:	005b      	lsls	r3, r3, #1
 8009156:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009158:	065d      	lsls	r5, r3, #25
 800915a:	bf48      	it	mi
 800915c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009160:	005b      	lsls	r3, r3, #1
 8009162:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009164:	0658      	lsls	r0, r3, #25
 8009166:	bf48      	it	mi
 8009168:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800916c:	005b      	lsls	r3, r3, #1
 800916e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009170:	0659      	lsls	r1, r3, #25
 8009172:	bf48      	it	mi
 8009174:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009178:	005b      	lsls	r3, r3, #1
 800917a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800917c:	065a      	lsls	r2, r3, #25
 800917e:	bf48      	it	mi
 8009180:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009184:	005b      	lsls	r3, r3, #1
 8009186:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009188:	065f      	lsls	r7, r3, #25
 800918a:	bf48      	it	mi
 800918c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009190:	005b      	lsls	r3, r3, #1
 8009192:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009194:	065d      	lsls	r5, r3, #25
 8009196:	bf48      	it	mi
 8009198:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800919c:	005b      	lsls	r3, r3, #1
 800919e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091a0:	0658      	lsls	r0, r3, #25
 80091a2:	bf48      	it	mi
 80091a4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80091a8:	005b      	lsls	r3, r3, #1
 80091aa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091ac:	0659      	lsls	r1, r3, #25
 80091ae:	bf48      	it	mi
 80091b0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80091b4:	005b      	lsls	r3, r3, #1
 80091b6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091b8:	065a      	lsls	r2, r3, #25
 80091ba:	bf48      	it	mi
 80091bc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	out.frame ^= (out.mcrc&0x00000003F);
 80091c0:	f003 003f 	and.w	r0, r3, #63	; 0x3f
	in.frame = hal_Xmit4BSPI(out.frame);
 80091c4:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
 80091c8:	f7fe f902 	bl	80073d0 <hal_Xmit4BSPI>
	in.scrc = in.frame & 0x00000003F;
 80091cc:	f000 023f 	and.w	r2, r0, #63	; 0x3f
           crc ^= (datin >> byte_idx) & 0x3F;
 80091d0:	0e83      	lsrs	r3, r0, #26
	in.frame = in.frame >> 8;
 80091d2:	0a01      	lsrs	r1, r0, #8
             crc <<= 1;
 80091d4:	005b      	lsls	r3, r3, #1
 80091d6:	f083 037e 	eor.w	r3, r3, #126	; 0x7e
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091da:	065f      	lsls	r7, r3, #25
 80091dc:	bf48      	it	mi
 80091de:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80091e2:	005b      	lsls	r3, r3, #1
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091e4:	065e      	lsls	r6, r3, #25
 80091e6:	d502      	bpl.n	80091ee <pga411_checkFaults+0x946>
 80091e8:	f083 035b 	eor.w	r3, r3, #91	; 0x5b
 80091ec:	b29b      	uxth	r3, r3
             crc <<= 1;
 80091ee:	005b      	lsls	r3, r3, #1
           crc ^= (datin >> byte_idx) & 0x3F;
 80091f0:	b289      	uxth	r1, r1
             crc <<= 1;
 80091f2:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80091f4:	065d      	lsls	r5, r3, #25
 80091f6:	bf48      	it	mi
 80091f8:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80091fc:	005b      	lsls	r3, r3, #1
 80091fe:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009200:	065f      	lsls	r7, r3, #25
 8009202:	bf48      	it	mi
 8009204:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009208:	005b      	lsls	r3, r3, #1
 800920a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800920c:	065e      	lsls	r6, r3, #25
 800920e:	bf48      	it	mi
 8009210:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009214:	005b      	lsls	r3, r3, #1
 8009216:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009218:	065d      	lsls	r5, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 800921a:	f3c0 5505 	ubfx	r5, r0, #20, #6
 800921e:	f3c0 3085 	ubfx	r0, r0, #14, #6
 8009222:	bf48      	it	mi
 8009224:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
 8009228:	406b      	eors	r3, r5
             crc <<= 1;
 800922a:	005b      	lsls	r3, r3, #1
 800922c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800922e:	065f      	lsls	r7, r3, #25
 8009230:	bf48      	it	mi
 8009232:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009236:	005b      	lsls	r3, r3, #1
 8009238:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800923a:	065e      	lsls	r6, r3, #25
 800923c:	bf48      	it	mi
 800923e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009242:	005b      	lsls	r3, r3, #1
 8009244:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009246:	065d      	lsls	r5, r3, #25
 8009248:	bf48      	it	mi
 800924a:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800924e:	005b      	lsls	r3, r3, #1
 8009250:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009252:	065f      	lsls	r7, r3, #25
 8009254:	bf48      	it	mi
 8009256:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800925a:	005b      	lsls	r3, r3, #1
 800925c:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800925e:	065e      	lsls	r6, r3, #25
 8009260:	bf48      	it	mi
 8009262:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009266:	005b      	lsls	r3, r3, #1
 8009268:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800926a:	065d      	lsls	r5, r3, #25
 800926c:	bf48      	it	mi
 800926e:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 8009272:	4043      	eors	r3, r0
             crc <<= 1;
 8009274:	005b      	lsls	r3, r3, #1
 8009276:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009278:	065f      	lsls	r7, r3, #25
 800927a:	bf48      	it	mi
 800927c:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009280:	005b      	lsls	r3, r3, #1
 8009282:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009284:	065e      	lsls	r6, r3, #25
 8009286:	bf48      	it	mi
 8009288:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 800928c:	005b      	lsls	r3, r3, #1
 800928e:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009290:	065d      	lsls	r5, r3, #25
 8009292:	bf48      	it	mi
 8009294:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 8009298:	005b      	lsls	r3, r3, #1
 800929a:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 800929c:	0658      	lsls	r0, r3, #25
           crc ^= (datin >> byte_idx) & 0x3F;
 800929e:	f001 003f 	and.w	r0, r1, #63	; 0x3f
 80092a2:	bf48      	it	mi
 80092a4:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092a8:	005b      	lsls	r3, r3, #1
 80092aa:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092ac:	065f      	lsls	r7, r3, #25
 80092ae:	bf48      	it	mi
 80092b0:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092b4:	005b      	lsls	r3, r3, #1
 80092b6:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092b8:	065e      	lsls	r6, r3, #25
 80092ba:	bf48      	it	mi
 80092bc:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
           crc ^= (datin >> byte_idx) & 0x3F;
 80092c0:	4043      	eors	r3, r0
             crc <<= 1;
 80092c2:	005b      	lsls	r3, r3, #1
 80092c4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092c6:	065d      	lsls	r5, r3, #25
 80092c8:	bf48      	it	mi
 80092ca:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092ce:	005b      	lsls	r3, r3, #1
 80092d0:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092d2:	0658      	lsls	r0, r3, #25
 80092d4:	bf48      	it	mi
 80092d6:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092da:	005b      	lsls	r3, r3, #1
 80092dc:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092de:	065f      	lsls	r7, r3, #25
 80092e0:	bf48      	it	mi
 80092e2:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092e6:	005b      	lsls	r3, r3, #1
 80092e8:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092ea:	065e      	lsls	r6, r3, #25
 80092ec:	bf48      	it	mi
 80092ee:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092f2:	005b      	lsls	r3, r3, #1
 80092f4:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 80092f6:	065d      	lsls	r5, r3, #25
 80092f8:	bf48      	it	mi
 80092fa:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
             crc <<= 1;
 80092fe:	005b      	lsls	r3, r3, #1
 8009300:	b29b      	uxth	r3, r3
             crc ^= (crc & 0x40) ? 0x5B : 0;
 8009302:	0658      	lsls	r0, r3, #25
 8009304:	bf48      	it	mi
 8009306:	f083 035b 	eormi.w	r3, r3, #91	; 0x5b
	if (crc2!= in.scrc) {
 800930a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800930e:	4293      	cmp	r3, r2
 8009310:	d000      	beq.n	8009314 <pga411_checkFaults+0xa6c>
		asm("NOP"); /* if error -> terminate */
 8009312:	bf00      	nop
	mc_faults.rdc_faults_reg4 &= FAFECAL_BIT;
 8009314:	f001 0180 	and.w	r1, r1, #128	; 0x80
	if (mc_faults.rdc_faults_reg1 > 0 || mc_faults.rdc_faults_reg2 > 0 ||
 8009318:	8823      	ldrh	r3, [r4, #0]
	mc_faults.rdc_faults_reg4 &= FAFECAL_BIT;
 800931a:	80e1      	strh	r1, [r4, #6]
	if (mc_faults.rdc_faults_reg1 > 0 || mc_faults.rdc_faults_reg2 > 0 ||
 800931c:	b90b      	cbnz	r3, 8009322 <pga411_checkFaults+0xa7a>
 800931e:	8863      	ldrh	r3, [r4, #2]
 8009320:	b193      	cbz	r3, 8009348 <pga411_checkFaults+0xaa0>
		mc_vars.fault_reg1 |= 1 << RDC_FAULT_REG_FLAG_BIT;
 8009322:	4a0c      	ldr	r2, [pc, #48]	; (8009354 <pga411_checkFaults+0xaac>)
 8009324:	f8b2 3070 	ldrh.w	r3, [r2, #112]	; 0x70
 8009328:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800932c:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
		Error_Handler();
 8009330:	f7fc f9be 	bl	80056b0 <Error_Handler>
	ignore_crc_error = TRUE;
 8009334:	4c08      	ldr	r4, [pc, #32]	; (8009358 <pga411_checkFaults+0xab0>)
 8009336:	2301      	movs	r3, #1
	fast_txrx(VELOCITY_FRAME); 	// get theta ask for velocity
 8009338:	4808      	ldr	r0, [pc, #32]	; (800935c <pga411_checkFaults+0xab4>)
	ignore_crc_error = TRUE;
 800933a:	7023      	strb	r3, [r4, #0]
	fast_txrx(VELOCITY_FRAME); 	// get theta ask for velocity
 800933c:	f7fe fb46 	bl	80079cc <fast_txrx>
	ignore_crc_error = FALSE;
 8009340:	2300      	movs	r3, #0
 8009342:	7023      	strb	r3, [r4, #0]
}
 8009344:	b005      	add	sp, #20
 8009346:	bdf0      	pop	{r4, r5, r6, r7, pc}
		mc_faults.rdc_faults_reg3 > 0 || mc_faults.rdc_faults_reg4 > 0) {
 8009348:	88a3      	ldrh	r3, [r4, #4]
 800934a:	430b      	orrs	r3, r1
 800934c:	d1e9      	bne.n	8009322 <pga411_checkFaults+0xa7a>
 800934e:	e7f1      	b.n	8009334 <pga411_checkFaults+0xa8c>
 8009350:	fffffef0 	.word	0xfffffef0
 8009354:	200021cc 	.word	0x200021cc
 8009358:	2006963c 	.word	0x2006963c
 800935c:	6f000003 	.word	0x6f000003

08009360 <update_rdc_values>:
void update_rdc_values(void) {
 8009360:	b510      	push	{r4, lr}
	velocity_raw = fast_txrx(ANGLE_FRAME); 	// get velocity ask for theta
 8009362:	4849      	ldr	r0, [pc, #292]	; (8009488 <update_rdc_values+0x128>)
 8009364:	f7fe fb32 	bl	80079cc <fast_txrx>
 8009368:	4604      	mov	r4, r0
	theta_raw = fast_txrx(VELOCITY_FRAME); 	// get theta ask for velocity
 800936a:	4848      	ldr	r0, [pc, #288]	; (800948c <update_rdc_values+0x12c>)
 800936c:	f7fe fb2e 	bl	80079cc <fast_txrx>
	theta_raw &=  0x01FFF; 		// keep only 12 bits
 8009370:	f3c0 000c 	ubfx	r0, r0, #0, #13
	mc_vars.theta_e -= mc_params.resolver_offset; // Subtract offset
 8009374:	4a46      	ldr	r2, [pc, #280]	; (8009490 <update_rdc_values+0x130>)
	mc_vars.theta_e = (float) (theta_raw * TWOPI / 4096);	// convert 12 bits to 16 bits to make taking the modulus of two pi easier
 8009376:	ee07 0a90 	vmov	s15, r0
	mc_vars.theta_e -= mc_params.resolver_offset; // Subtract offset
 800937a:	4b46      	ldr	r3, [pc, #280]	; (8009494 <update_rdc_values+0x134>)
 800937c:	edd2 6a25 	vldr	s13, [r2, #148]	; 0x94
	mc_vars.theta_e = (float) (theta_raw * TWOPI / 4096);	// convert 12 bits to 16 bits to make taking the modulus of two pi easier
 8009380:	eeb8 7be7 	vcvt.f64.s32	d7, s15
	mc_vars.theta_e -= mc_params.resolver_offset; // Subtract offset
 8009384:	ed92 6a08 	vldr	s12, [r2, #32]
 8009388:	eef8 6a66 	vcvt.f32.u32	s13, s13
	mc_vars.theta_e = (float) (theta_raw * TWOPI / 4096);	// convert 12 bits to 16 bits to make taking the modulus of two pi easier
 800938c:	ed9f 4b36 	vldr	d4, [pc, #216]	; 8009468 <update_rdc_values+0x108>
	while (mc_vars.theta_e > TWOPI) {
 8009390:	ed9f 5b37 	vldr	d5, [pc, #220]	; 8009470 <update_rdc_values+0x110>
	mc_vars.theta_e = (float) (theta_raw * TWOPI / 4096);	// convert 12 bits to 16 bits to make taking the modulus of two pi easier
 8009394:	ee27 7b04 	vmul.f64	d7, d7, d4
 8009398:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	mc_vars.theta_e -= mc_params.resolver_offset; // Subtract offset
 800939c:	eed7 6a06 	vfnms.f32	s13, s14, s12
	while (mc_vars.theta_e > TWOPI) {
 80093a0:	eeb7 7ae6 	vcvt.f64.f32	d7, s13
	mc_vars.theta_e -= mc_params.resolver_offset; // Subtract offset
 80093a4:	edc3 6a06 	vstr	s13, [r3, #24]
	while (mc_vars.theta_e > TWOPI) {
 80093a8:	eeb4 7bc5 	vcmpe.f64	d7, d5
 80093ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80093b0:	dd0c      	ble.n	80093cc <update_rdc_values+0x6c>
		mc_vars.theta_e -= TWOPI;
 80093b2:	ee37 7b45 	vsub.f64	d7, d7, d5
 80093b6:	eef7 6bc7 	vcvt.f32.f64	s13, d7
	while (mc_vars.theta_e > TWOPI) {
 80093ba:	eeb7 7ae6 	vcvt.f64.f32	d7, s13
 80093be:	eeb4 7bc5 	vcmpe.f64	d7, d5
 80093c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80093c6:	dcf4      	bgt.n	80093b2 <update_rdc_values+0x52>
 80093c8:	edc3 6a06 	vstr	s13, [r3, #24]
	mc_vars.theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 80093cc:	ed9f 6b2a 	vldr	d6, [pc, #168]	; 8009478 <update_rdc_values+0x118>
	if (mc_vars.theta_plus_2PIdiv3 > TWOPI) {
 80093d0:	ed9f 4b27 	vldr	d4, [pc, #156]	; 8009470 <update_rdc_values+0x110>
	mc_vars.theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 80093d4:	ee37 6b06 	vadd.f64	d6, d7, d6
 80093d8:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
	if (mc_vars.theta_plus_2PIdiv3 > TWOPI) {
 80093dc:	eeb7 5ac6 	vcvt.f64.f32	d5, s12
 80093e0:	eeb4 5bc4 	vcmpe.f64	d5, d4
 80093e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80093e8:	dc2d      	bgt.n	8009446 <update_rdc_values+0xe6>
	mc_vars.theta_plus_2PIdiv3 = mc_vars.theta_e + TWOPIDIV3;
 80093ea:	ed83 6a23 	vstr	s12, [r3, #140]	; 0x8c
	mc_vars.theta_minus_2PIdiv3 = mc_vars.theta_e - TWOPIDIV3;
 80093ee:	ed9f 6b22 	vldr	d6, [pc, #136]	; 8009478 <update_rdc_values+0x118>
 80093f2:	ee37 7b46 	vsub.f64	d7, d7, d6
 80093f6:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	if (mc_vars.theta_minus_2PIdiv3 <0) {
 80093fa:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 80093fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009402:	d507      	bpl.n	8009414 <update_rdc_values+0xb4>
		mc_vars.theta_minus_2PIdiv3 += TWOPI;
 8009404:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 8009408:	ed9f 6b19 	vldr	d6, [pc, #100]	; 8009470 <update_rdc_values+0x110>
 800940c:	ee37 7b06 	vadd.f64	d7, d7, d6
 8009410:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	if (velocity_raw & 0x0800) { /* negative number? */
 8009414:	0522      	lsls	r2, r4, #20
		mc_vars.theta_minus_2PIdiv3 += TWOPI;
 8009416:	ed83 7a24 	vstr	s14, [r3, #144]	; 0x90
	if (velocity_raw & 0x0800) { /* negative number? */
 800941a:	d41b      	bmi.n	8009454 <update_rdc_values+0xf4>
		velocity_float= (velocity_raw & 0x07FF);
 800941c:	f3c4 020a 	ubfx	r2, r4, #0, #11
 8009420:	ee07 2a10 	vmov	s14, r2
 8009424:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	mc_vars.wElectrical =  (float) ((velocity_float+1) * VELOCITY_MULTIPLIER * 10.0);
 8009428:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800942c:	ed9f 6b14 	vldr	d6, [pc, #80]	; 8009480 <update_rdc_values+0x120>
 8009430:	ee37 7a27 	vadd.f32	s14, s14, s15
 8009434:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 8009438:	ee27 7b06 	vmul.f64	d7, d7, d6
 800943c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
 8009440:	ed83 7a02 	vstr	s14, [r3, #8]
}
 8009444:	bd10      	pop	{r4, pc}
		mc_vars.theta_plus_2PIdiv3 -= TWOPI;
 8009446:	ee35 5b44 	vsub.f64	d5, d5, d4
 800944a:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
 800944e:	ed83 5a23 	vstr	s10, [r3, #140]	; 0x8c
 8009452:	e7cc      	b.n	80093ee <update_rdc_values+0x8e>
		velocity_float= (((~velocity_raw)+1) & 0x07FF);
 8009454:	4264      	negs	r4, r4
 8009456:	f3c4 020a 	ubfx	r2, r4, #0, #11
 800945a:	ee07 2a10 	vmov	s14, r2
 800945e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
		velocity_float*= -1; /* and makeit negative*/
 8009462:	eeb1 7a47 	vneg.f32	s14, s14
 8009466:	e7df      	b.n	8009428 <update_rdc_values+0xc8>
 8009468:	54442eea 	.word	0x54442eea
 800946c:	3f5921fb 	.word	0x3f5921fb
 8009470:	54442eea 	.word	0x54442eea
 8009474:	401921fb 	.word	0x401921fb
 8009478:	382d574a 	.word	0x382d574a
 800947c:	4000c152 	.word	0x4000c152
 8009480:	a15bd078 	.word	0xa15bd078
 8009484:	4042b9b0 	.word	0x4042b9b0
 8009488:	41000029 	.word	0x41000029
 800948c:	6f000003 	.word	0x6f000003
 8009490:	20002130 	.word	0x20002130
 8009494:	200021cc 	.word	0x200021cc

08009498 <amc1106_init>:
void update_Vdc(void);

/*
 * Initialize the sigma delta channel and filter
 */
void amc1106_init(void) {
 8009498:	b508      	push	{r3, lr}
	HAL_DFSDM_ChannelMspInit(&hdfsdm1_channel3);
 800949a:	481f      	ldr	r0, [pc, #124]	; (8009518 <amc1106_init+0x80>)
 800949c:	f7fc ff32 	bl	8006304 <HAL_DFSDM_ChannelMspInit>
	HAL_DFSDM_FilterMspInit(&hdfsdm1_filter3);
 80094a0:	481e      	ldr	r0, [pc, #120]	; (800951c <amc1106_init+0x84>)
 80094a2:	f7fc fed5 	bl	8006250 <HAL_DFSDM_FilterMspInit>
 * Start Vdc conversion. This is seperate from the update_Vdc() because it takes some time
 * to filter the signal. To save processing time, instead of polling other tasks are done while
 * this completes.
 */
void start_Vdc_conversion(void) {
	HAL_DFSDM_FilterRegularStart(&hdfsdm1_filter3);
 80094a6:	481d      	ldr	r0, [pc, #116]	; (800951c <amc1106_init+0x84>)
 80094a8:	f7f8 f8b4 	bl	8001614 <HAL_DFSDM_FilterRegularStart>

/*
 * Get the filtered sigma delta value for Vdc
 */
void update_Vdc(void) {
	HAL_DFSDM_FilterPollForRegConversion(&hdfsdm1_filter3, 100);
 80094ac:	2164      	movs	r1, #100	; 0x64
 80094ae:	481b      	ldr	r0, [pc, #108]	; (800951c <amc1106_init+0x84>)
 80094b0:	f7f8 f8f4 	bl	800169c <HAL_DFSDM_FilterPollForRegConversion>
	mc_vars.Vdc = (float) HAL_DFSDM_FilterGetRegularValue(&hdfsdm1_filter3, (uint32_t *) &hdfsdm1_channel3);
 80094b4:	4918      	ldr	r1, [pc, #96]	; (8009518 <amc1106_init+0x80>)
 80094b6:	4819      	ldr	r0, [pc, #100]	; (800951c <amc1106_init+0x84>)
 80094b8:	f7f8 f8e6 	bl	8001688 <HAL_DFSDM_FilterGetRegularValue>
 80094bc:	ee07 0a90 	vmov	s15, r0
	mc_vars.Vdc = mc_vars.Vdc * VDC_MULTIPLIER - 176; // the offset -176 can change over time so this might need
													  // to be updated if you notice a difference in the measurement
	if (mc_vars.Vdc > VDC_LIMIT) {
 80094c0:	eddf 5a17 	vldr	s11, [pc, #92]	; 8009520 <amc1106_init+0x88>
	mc_vars.Vdc = (float) HAL_DFSDM_FilterGetRegularValue(&hdfsdm1_filter3, (uint32_t *) &hdfsdm1_channel3);
 80094c4:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
	mc_vars.Vdc = mc_vars.Vdc * VDC_MULTIPLIER - 176; // the offset -176 can change over time so this might need
 80094c8:	4b16      	ldr	r3, [pc, #88]	; (8009524 <amc1106_init+0x8c>)
 80094ca:	ed9f 4b0f 	vldr	d4, [pc, #60]	; 8009508 <amc1106_init+0x70>
 80094ce:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
 80094d2:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 8009510 <amc1106_init+0x78>
 80094d6:	eea6 7b04 	vfma.f64	d7, d6, d4
 80094da:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	if (mc_vars.Vdc > VDC_LIMIT) {
 80094de:	eeb4 7ae5 	vcmpe.f32	s14, s11
	mc_vars.Vdc = mc_vars.Vdc * VDC_MULTIPLIER - 176; // the offset -176 can change over time so this might need
 80094e2:	ed83 7a07 	vstr	s14, [r3, #28]
	if (mc_vars.Vdc > VDC_LIMIT) {
 80094e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80094ea:	dc00      	bgt.n	80094ee <amc1106_init+0x56>
}
 80094ec:	bd08      	pop	{r3, pc}
		mc_vars.fault_reg1 |= 1 << HIGH_VDC_FLAG_BIT;
 80094ee:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 80094f2:	f042 0201 	orr.w	r2, r2, #1
 80094f6:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
}
 80094fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		Error_Handler();
 80094fe:	f7fc b8d7 	b.w	80056b0 <Error_Handler>
 8009502:	bf00      	nop
 8009504:	f3af 8000 	nop.w
 8009508:	8ff75968 	.word	0x8ff75968
 800950c:	3f40e885 	.word	0x3f40e885
 8009510:	00000000 	.word	0x00000000
 8009514:	c0660000 	.word	0xc0660000
 8009518:	2000255c 	.word	0x2000255c
 800951c:	200026d8 	.word	0x200026d8
 8009520:	43a28000 	.word	0x43a28000
 8009524:	200021cc 	.word	0x200021cc

08009528 <start_Vdc_conversion>:
	HAL_DFSDM_FilterRegularStart(&hdfsdm1_filter3);
 8009528:	4801      	ldr	r0, [pc, #4]	; (8009530 <start_Vdc_conversion+0x8>)
 800952a:	f7f8 b873 	b.w	8001614 <HAL_DFSDM_FilterRegularStart>
 800952e:	bf00      	nop
 8009530:	200026d8 	.word	0x200026d8
 8009534:	00000000 	.word	0x00000000

08009538 <update_Vdc>:
void update_Vdc(void) {
 8009538:	b508      	push	{r3, lr}
	HAL_DFSDM_FilterPollForRegConversion(&hdfsdm1_filter3, 100);
 800953a:	2164      	movs	r1, #100	; 0x64
 800953c:	4818      	ldr	r0, [pc, #96]	; (80095a0 <update_Vdc+0x68>)
 800953e:	f7f8 f8ad 	bl	800169c <HAL_DFSDM_FilterPollForRegConversion>
	mc_vars.Vdc = (float) HAL_DFSDM_FilterGetRegularValue(&hdfsdm1_filter3, (uint32_t *) &hdfsdm1_channel3);
 8009542:	4918      	ldr	r1, [pc, #96]	; (80095a4 <update_Vdc+0x6c>)
 8009544:	4816      	ldr	r0, [pc, #88]	; (80095a0 <update_Vdc+0x68>)
 8009546:	f7f8 f89f 	bl	8001688 <HAL_DFSDM_FilterGetRegularValue>
 800954a:	ee07 0a90 	vmov	s15, r0
	if (mc_vars.Vdc > VDC_LIMIT) {
 800954e:	eddf 5a16 	vldr	s11, [pc, #88]	; 80095a8 <update_Vdc+0x70>
	mc_vars.Vdc = (float) HAL_DFSDM_FilterGetRegularValue(&hdfsdm1_filter3, (uint32_t *) &hdfsdm1_channel3);
 8009552:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
	mc_vars.Vdc = mc_vars.Vdc * VDC_MULTIPLIER - 176; // the offset -176 can change over time so this might need
 8009556:	4b15      	ldr	r3, [pc, #84]	; (80095ac <update_Vdc+0x74>)
 8009558:	ed9f 4b0d 	vldr	d4, [pc, #52]	; 8009590 <update_Vdc+0x58>
 800955c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
 8009560:	ed9f 7b0d 	vldr	d7, [pc, #52]	; 8009598 <update_Vdc+0x60>
 8009564:	eea6 7b04 	vfma.f64	d7, d6, d4
 8009568:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
	if (mc_vars.Vdc > VDC_LIMIT) {
 800956c:	eeb4 7ae5 	vcmpe.f32	s14, s11
	mc_vars.Vdc = mc_vars.Vdc * VDC_MULTIPLIER - 176; // the offset -176 can change over time so this might need
 8009570:	ed83 7a07 	vstr	s14, [r3, #28]
	if (mc_vars.Vdc > VDC_LIMIT) {
 8009574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009578:	dc00      	bgt.n	800957c <update_Vdc+0x44>
	}
}
 800957a:	bd08      	pop	{r3, pc}
		mc_vars.fault_reg1 |= 1 << HIGH_VDC_FLAG_BIT;
 800957c:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 8009580:	f042 0201 	orr.w	r2, r2, #1
 8009584:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
}
 8009588:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		Error_Handler();
 800958c:	f7fc b890 	b.w	80056b0 <Error_Handler>
 8009590:	8ff75968 	.word	0x8ff75968
 8009594:	3f40e885 	.word	0x3f40e885
 8009598:	00000000 	.word	0x00000000
 800959c:	c0660000 	.word	0xc0660000
 80095a0:	200026d8 	.word	0x200026d8
 80095a4:	2000255c 	.word	0x2000255c
 80095a8:	43a28000 	.word	0x43a28000
 80095ac:	200021cc 	.word	0x200021cc

080095b0 <update_battery_voltage>:

/*
 * Used to read the battery voltage for brownout protection
 */
void update_battery_voltage(uint32_t adc_reading){
    float result = ((3.3 / 4096) * 51 / 10 * adc_reading);
 80095b0:	ee07 0a90 	vmov	s15, r0
    mc_vars.bat_voltage = result;
    if (result < 10.0){
 80095b4:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
    mc_vars.bat_voltage = result;
 80095b8:	4b0f      	ldr	r3, [pc, #60]	; (80095f8 <update_battery_voltage+0x48>)
    float result = ((3.3 / 4096) * 51 / 10 * adc_reading);
 80095ba:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 80095be:	ed9f 5b0c 	vldr	d5, [pc, #48]	; 80095f0 <update_battery_voltage+0x40>
 80095c2:	ee27 7b05 	vmul.f64	d7, d7, d5
 80095c6:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    if (result < 10.0){
 80095ca:	eeb4 7ae6 	vcmpe.f32	s14, s13
    mc_vars.bat_voltage = result;
 80095ce:	ed83 7a20 	vstr	s14, [r3, #128]	; 0x80
    if (result < 10.0){
 80095d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80095d6:	d400      	bmi.n	80095da <update_battery_voltage+0x2a>
    	mc_vars.fault_reg1 |= 1 << LOW_BATTERY_FAULT_BIT;
        Error_Handler();
    }
}
 80095d8:	4770      	bx	lr
    	mc_vars.fault_reg1 |= 1 << LOW_BATTERY_FAULT_BIT;
 80095da:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 80095de:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80095e2:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
        Error_Handler();
 80095e6:	f7fc b863 	b.w	80056b0 <Error_Handler>
 80095ea:	bf00      	nop
 80095ec:	f3af 8000 	nop.w
 80095f0:	e147ae14 	.word	0xe147ae14
 80095f4:	3f70d47a 	.word	0x3f70d47a
 80095f8:	200021cc 	.word	0x200021cc
 80095fc:	00000000 	.word	0x00000000

08009600 <update_temps>:
		Error_Handler();
	}
}

// Get ADC values from thermistors and calculate temperature for Motor and IGBT
void update_temps(void) {
 8009600:	b570      	push	{r4, r5, r6, lr}
	uint32_t motorTemp_adc;
	uint32_t igbt_adc_voltage;
	HAL_ADC_Start(&hadc3);
 8009602:	4869      	ldr	r0, [pc, #420]	; (80097a8 <update_temps+0x1a8>)
 8009604:	f7f7 f8a2 	bl	800074c <HAL_ADC_Start>
	HAL_ADC_Start(&hadc2);
 8009608:	4868      	ldr	r0, [pc, #416]	; (80097ac <update_temps+0x1ac>)
 800960a:	f7f7 f89f 	bl	800074c <HAL_ADC_Start>
	if (HAL_ADC_PollForConversion(&hadc3, 100) == HAL_OK) {
 800960e:	2164      	movs	r1, #100	; 0x64
 8009610:	4865      	ldr	r0, [pc, #404]	; (80097a8 <update_temps+0x1a8>)
 8009612:	f7f7 f925 	bl	8000860 <HAL_ADC_PollForConversion>
 8009616:	2800      	cmp	r0, #0
 8009618:	d16f      	bne.n	80096fa <update_temps+0xfa>
		motorTemp_adc = HAL_ADC_GetValue(&hadc3);
 800961a:	4863      	ldr	r0, [pc, #396]	; (80097a8 <update_temps+0x1a8>)
 800961c:	f7f7 f972 	bl	8000904 <HAL_ADC_GetValue>
    motor_temp_voltage = motorTemp_adc * 3.3 / 4095; // calculate temperature from ADC value
 8009620:	ee07 0a90 	vmov	s15, r0
 8009624:	ed9f 5b52 	vldr	d5, [pc, #328]	; 8009770 <update_temps+0x170>
 8009628:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    if (motor_temp_voltage<2.2) { // lower temperature section -55 deg C to 60 deg C
 800962c:	ed9f 6b52 	vldr	d6, [pc, #328]	; 8009778 <update_temps+0x178>
    motor_temp_voltage = motorTemp_adc * 3.3 / 4095; // calculate temperature from ADC value
 8009630:	ee27 7b05 	vmul.f64	d7, d7, d5
 8009634:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    if (motor_temp_voltage<2.2) { // lower temperature section -55 deg C to 60 deg C
 8009638:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 800963c:	eeb4 7bc6 	vcmpe.f64	d7, d6
 8009640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009644:	d472      	bmi.n	800972c <update_temps+0x12c>
        motor_temp_degC=(motor_temp_voltage-0.618)/0.00444-273;
 8009646:	ed9f 4b4e 	vldr	d4, [pc, #312]	; 8009780 <update_temps+0x180>
 800964a:	ed9f 5b4f 	vldr	d5, [pc, #316]	; 8009788 <update_temps+0x188>
 800964e:	ed9f 6b50 	vldr	d6, [pc, #320]	; 8009790 <update_temps+0x190>
 8009652:	ee37 7b44 	vsub.f64	d7, d7, d4
 8009656:	eea7 6b05 	vfma.f64	d6, d7, d5
 800965a:	eebc 7bc6 	vcvt.u32.f64	s14, d6
	if (motor_temp_degC > 150) {
 800965e:	ee17 3a10 	vmov	r3, s14
	mc_vars.motorTemp = (float) motor_temp_degC;
 8009662:	eef8 7a47 	vcvt.f32.u32	s15, s14
 8009666:	4c52      	ldr	r4, [pc, #328]	; (80097b0 <update_temps+0x1b0>)
	if (motor_temp_degC > 150) {
 8009668:	2b96      	cmp	r3, #150	; 0x96
	mc_vars.motorTemp = (float) motor_temp_degC;
 800966a:	edc4 7a11 	vstr	s15, [r4, #68]	; 0x44
	if (motor_temp_degC > 150) {
 800966e:	d94d      	bls.n	800970c <update_temps+0x10c>
		mc_vars.fault_reg1  |= 1 << HIGH_MOTOR_TEMP_FLAG_BIT;
 8009670:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 8009674:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009678:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
		Error_Handler();
 800967c:	f7fc f818 	bl	80056b0 <Error_Handler>
		update_motor_temp(motorTemp_adc);
	} else {
		mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
		Error_Handler();
	}
	if (HAL_ADC_PollForConversion(&hadc2, 100) == HAL_OK) {
 8009680:	2164      	movs	r1, #100	; 0x64
 8009682:	484a      	ldr	r0, [pc, #296]	; (80097ac <update_temps+0x1ac>)
 8009684:	f7f7 f8ec 	bl	8000860 <HAL_ADC_PollForConversion>
 8009688:	2800      	cmp	r0, #0
 800968a:	d145      	bne.n	8009718 <update_temps+0x118>
		igbt_adc_voltage = HAL_ADC_GetValue(&hadc2);
 800968c:	4847      	ldr	r0, [pc, #284]	; (80097ac <update_temps+0x1ac>)
 800968e:	f7f7 f939 	bl	8000904 <HAL_ADC_GetValue>
	uint16_t index1 = (igbt_adc_voltage-2000)/40; // convert digital voltage to index of look up table
 8009692:	4a48      	ldr	r2, [pc, #288]	; (80097b4 <update_temps+0x1b4>)
 8009694:	f5a0 63fa 	sub.w	r3, r0, #2000	; 0x7d0
 8009698:	fba2 2303 	umull	r2, r3, r2, r3
 800969c:	095b      	lsrs	r3, r3, #5
	if (index1 < LOOPUP_TABLE_SIZE && index1 > 0) {
 800969e:	1e5a      	subs	r2, r3, #1
 80096a0:	b292      	uxth	r2, r2
 80096a2:	2a30      	cmp	r2, #48	; 0x30
 80096a4:	d84f      	bhi.n	8009746 <update_temps+0x146>
	uint32_t igbt_adc_voltage_rounded = index1 * 40 + 2000; // get the ADC voltage value rounded to the nearest 100th (decimal number)
 80096a6:	b29b      	uxth	r3, r3
		uint8_t temp1 = IGBT_LOOKUP_TABLE[index1]; // get the rounded down voltage temperature
 80096a8:	4d43      	ldr	r5, [pc, #268]	; (80097b8 <update_temps+0x1b8>)
		mc_vars.igbtTemp = (float) (igbt_adc_voltage-igbt_adc_voltage_rounded)*(temp2-temp1)/40+temp1; // interpolate to get temperature
 80096aa:	eddf 5a44 	vldr	s11, [pc, #272]	; 80097bc <update_temps+0x1bc>
	uint32_t igbt_adc_voltage_rounded = index1 * 40 + 2000; // get the ADC voltage value rounded to the nearest 100th (decimal number)
 80096ae:	eb03 0283 	add.w	r2, r3, r3, lsl #2
		mc_vars.igbtTemp = (float) (igbt_adc_voltage-igbt_adc_voltage_rounded)*(temp2-temp1)/40+temp1; // interpolate to get temperature
 80096b2:	f815 1013 	ldrb.w	r1, [r5, r3, lsl #1]
		uint8_t temp2 = IGBT_LOOKUP_TABLE[index1+1]; // get the rounded up voltage temperature
 80096b6:	1c5e      	adds	r6, r3, #1
		if (mc_vars.igbtTemp > 100) {
 80096b8:	ed9f 6a41 	vldr	s12, [pc, #260]	; 80097c0 <update_temps+0x1c0>
	uint32_t igbt_adc_voltage_rounded = index1 * 40 + 2000; // get the ADC voltage value rounded to the nearest 100th (decimal number)
 80096bc:	00d2      	lsls	r2, r2, #3
		mc_vars.igbtTemp = (float) (igbt_adc_voltage-igbt_adc_voltage_rounded)*(temp2-temp1)/40+temp1; // interpolate to get temperature
 80096be:	ee07 1a90 	vmov	s15, r1
 80096c2:	f815 3016 	ldrb.w	r3, [r5, r6, lsl #1]
	uint32_t igbt_adc_voltage_rounded = index1 * 40 + 2000; // get the ADC voltage value rounded to the nearest 100th (decimal number)
 80096c6:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
		mc_vars.igbtTemp = (float) (igbt_adc_voltage-igbt_adc_voltage_rounded)*(temp2-temp1)/40+temp1; // interpolate to get temperature
 80096ca:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80096ce:	1a5b      	subs	r3, r3, r1
 80096d0:	1a82      	subs	r2, r0, r2
 80096d2:	ee07 3a10 	vmov	s14, r3
 80096d6:	ee07 2a90 	vmov	s15, r2
 80096da:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80096de:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80096e2:	ee67 7aa5 	vmul.f32	s15, s15, s11
 80096e6:	eee7 6a87 	vfma.f32	s13, s15, s14
		if (mc_vars.igbtTemp > 100) {
 80096ea:	eef4 6ac6 	vcmpe.f32	s13, s12
		mc_vars.igbtTemp = (float) (igbt_adc_voltage-igbt_adc_voltage_rounded)*(temp2-temp1)/40+temp1; // interpolate to get temperature
 80096ee:	edc4 6a12 	vstr	s13, [r4, #72]	; 0x48
		if (mc_vars.igbtTemp > 100) {
 80096f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80096f6:	dc30      	bgt.n	800975a <update_temps+0x15a>
	} else  {
		mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
		Error_Handler();
	}

}
 80096f8:	bd70      	pop	{r4, r5, r6, pc}
		mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
 80096fa:	4c2d      	ldr	r4, [pc, #180]	; (80097b0 <update_temps+0x1b0>)
 80096fc:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 8009700:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009704:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
		Error_Handler();
 8009708:	f7fb ffd2 	bl	80056b0 <Error_Handler>
	if (HAL_ADC_PollForConversion(&hadc2, 100) == HAL_OK) {
 800970c:	2164      	movs	r1, #100	; 0x64
 800970e:	4827      	ldr	r0, [pc, #156]	; (80097ac <update_temps+0x1ac>)
 8009710:	f7f7 f8a6 	bl	8000860 <HAL_ADC_PollForConversion>
 8009714:	2800      	cmp	r0, #0
 8009716:	d0b9      	beq.n	800968c <update_temps+0x8c>
		mc_vars.fault_reg1 |= 1 << ADC_FLAG_BIT;
 8009718:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 800971c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009720:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
}
 8009724:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		Error_Handler();
 8009728:	f7fb bfc2 	b.w	80056b0 <Error_Handler>
        motor_temp_degC=(motor_temp_voltage+0.908)/0.00836-273;
 800972c:	ed9f 4b1a 	vldr	d4, [pc, #104]	; 8009798 <update_temps+0x198>
 8009730:	ed9f 5b1b 	vldr	d5, [pc, #108]	; 80097a0 <update_temps+0x1a0>
 8009734:	ed9f 6b16 	vldr	d6, [pc, #88]	; 8009790 <update_temps+0x190>
 8009738:	ee37 7b04 	vadd.f64	d7, d7, d4
 800973c:	eea7 6b05 	vfma.f64	d6, d7, d5
 8009740:	eebc 7bc6 	vcvt.u32.f64	s14, d6
 8009744:	e78b      	b.n	800965e <update_temps+0x5e>
		mc_vars.fault_reg1 |= 1 << IGBT_THERMISTOR_FLAG_BIT;
 8009746:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 800974a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800974e:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
}
 8009752:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		Error_Handler();
 8009756:	f7fb bfab 	b.w	80056b0 <Error_Handler>
			mc_vars.fault_reg1 |= 1 << HIGH_IGBT_TEMP_FLAG_BIT;
 800975a:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
 800975e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009762:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
}
 8009766:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			Error_Handler();
 800976a:	f7fb bfa1 	b.w	80056b0 <Error_Handler>
 800976e:	bf00      	nop
 8009770:	e734d9b4 	.word	0xe734d9b4
 8009774:	3f4a680c 	.word	0x3f4a680c
 8009778:	9999999a 	.word	0x9999999a
 800977c:	40019999 	.word	0x40019999
 8009780:	ef9db22d 	.word	0xef9db22d
 8009784:	3fe3c6a7 	.word	0x3fe3c6a7
 8009788:	0b881273 	.word	0x0b881273
 800978c:	406c2735 	.word	0x406c2735
 8009790:	00000000 	.word	0x00000000
 8009794:	c0711000 	.word	0xc0711000
 8009798:	04189375 	.word	0x04189375
 800979c:	3fed0e56 	.word	0x3fed0e56
 80097a0:	9cc8e161 	.word	0x9cc8e161
 80097a4:	405de780 	.word	0x405de780
 80097a8:	20002630 	.word	0x20002630
 80097ac:	200023b4 	.word	0x200023b4
 80097b0:	200021cc 	.word	0x200021cc
 80097b4:	cccccccd 	.word	0xcccccccd
 80097b8:	080099c4 	.word	0x080099c4
 80097bc:	3ccccccd 	.word	0x3ccccccd
 80097c0:	42c80000 	.word	0x42c80000

080097c4 <flash_erase_sector>:
 *  (Ideally this will be VOLTAGE_RANGE_1 but C doesn't let me do function overloads for defaults)
 * Set the Sector to what's specified by the user
 * Set the Number of Sectors to 1
 *
 */
HAL_StatusTypeDef flash_erase_sector(Sector sector, uint8_t voltage_range, void (*error_handler)()){
 80097c4:	b530      	push	{r4, r5, lr}
    FLASH_EraseInitTypeDef EraseInitStruct;
    EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
    EraseInitStruct.VoltageRange = voltage_range;
    EraseInitStruct.Sector = sector; //Specify sector number
    EraseInitStruct.NbSectors = 1; //This is also important!
 80097c6:	2301      	movs	r3, #1
HAL_StatusTypeDef flash_erase_sector(Sector sector, uint8_t voltage_range, void (*error_handler)()){
 80097c8:	b087      	sub	sp, #28
    EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
 80097ca:	2400      	movs	r4, #0
HAL_StatusTypeDef flash_erase_sector(Sector sector, uint8_t voltage_range, void (*error_handler)()){
 80097cc:	4615      	mov	r5, r2
    EraseInitStruct.VoltageRange = voltage_range;
 80097ce:	9105      	str	r1, [sp, #20]
    EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
 80097d0:	9401      	str	r4, [sp, #4]
    EraseInitStruct.NbSectors = 1; //This is also important!
 80097d2:	9304      	str	r3, [sp, #16]
    EraseInitStruct.Sector = sector; //Specify sector number
 80097d4:	9003      	str	r0, [sp, #12]
/**
 * Unlock the flash, erase the sector, lock the flash
 */
HAL_StatusTypeDef flash_erase(FLASH_EraseInitTypeDef* EraseInitStruct, void (*error_handler)()){
    uint32_t SectorError;
    HAL_FLASH_Unlock();
 80097d6:	f7f8 fa6b 	bl	8001cb0 <HAL_FLASH_Unlock>
    HAL_StatusTypeDef result = HAL_FLASHEx_Erase(EraseInitStruct, &SectorError);
 80097da:	4669      	mov	r1, sp
 80097dc:	a801      	add	r0, sp, #4
 80097de:	f7f8 fadd 	bl	8001d9c <HAL_FLASHEx_Erase>
 80097e2:	4604      	mov	r4, r0
    HAL_FLASH_Lock();
 80097e4:	f7f8 fa78 	bl	8001cd8 <HAL_FLASH_Lock>
    if(result != HAL_OK){
 80097e8:	b104      	cbz	r4, 80097ec <flash_erase_sector+0x28>
        error_handler();
 80097ea:	47a8      	blx	r5
}
 80097ec:	4620      	mov	r0, r4
 80097ee:	b007      	add	sp, #28
 80097f0:	bd30      	pop	{r4, r5, pc}
 80097f2:	bf00      	nop

080097f4 <flash_program_sequential>:
}

/**
 * Determine the range of sectors the data belongs in, erase those sectors, and program the data
 */
HAL_StatusTypeDef flash_program_sequential(Address address, Byte bytes[], void (*error_handler)()){
 80097f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(IS_FLASH_SECTOR_0(address)){
 80097f8:	f100 4478 	add.w	r4, r0, #4160749568	; 0xf8000000
 80097fc:	4b17      	ldr	r3, [pc, #92]	; (800985c <flash_program_sequential+0x68>)
 80097fe:	f5b4 1f00 	cmp.w	r4, #2097152	; 0x200000
 8009802:	4403      	add	r3, r0
 8009804:	d304      	bcc.n	8009810 <flash_program_sequential+0x1c>
    uint32_t N = sizeof(bytes) / sizeof(bytes[0]);
    Sector sector_start = sector_from_address(address);
    Sector sector_end = sector_from_address(address + N);
    HAL_StatusTypeDef result;
    if(sector_start == -1 || sector_end == -1){
        return HAL_ERROR;
 8009806:	f04f 0801 	mov.w	r8, #1
        if(result != HAL_OK){
            break;
        }
    }
    return result;
}
 800980a:	4640      	mov	r0, r8
 800980c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(IS_FLASH_SECTOR_0(address)){
 8009810:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009814:	d304      	bcc.n	8009820 <flash_program_sequential+0x2c>
    else if(IS_FLASH_SECTOR_1(address)){
 8009816:	4b12      	ldr	r3, [pc, #72]	; (8009860 <flash_program_sequential+0x6c>)
 8009818:	4403      	add	r3, r0
 800981a:	f5b3 1ffc 	cmp.w	r3, #2064384	; 0x1f8000
 800981e:	d2f2      	bcs.n	8009806 <flash_program_sequential+0x12>
 8009820:	4617      	mov	r7, r2
HAL_StatusTypeDef flash_program_sequential(Address address, Byte bytes[], void (*error_handler)()){
 8009822:	460c      	mov	r4, r1
 8009824:	1d0e      	adds	r6, r1, #4
 8009826:	1a45      	subs	r5, r0, r1
 8009828:	eb05 0904 	add.w	r9, r5, r4
        result = flash_program(address+i, bytes[i], error_handler);
 800982c:	f814 8b01 	ldrb.w	r8, [r4], #1

/**
 * Unlock the flash, program the flash, lock the flash
 */
HAL_StatusTypeDef flash_program(Address address, Byte byte, void (*error_handler)()){
    HAL_FLASH_Unlock();
 8009830:	f7f8 fa3e 	bl	8001cb0 <HAL_FLASH_Unlock>
    HAL_StatusTypeDef result = HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, address, byte);
 8009834:	2000      	movs	r0, #0
 8009836:	4642      	mov	r2, r8
 8009838:	4649      	mov	r1, r9
 800983a:	2300      	movs	r3, #0
 800983c:	f7f8 f936 	bl	8001aac <HAL_FLASH_Program>
 8009840:	4680      	mov	r8, r0
    HAL_FLASH_Lock();
 8009842:	f7f8 fa49 	bl	8001cd8 <HAL_FLASH_Lock>
    if(result != HAL_OK){
 8009846:	f1b8 0f00 	cmp.w	r8, #0
 800984a:	d003      	beq.n	8009854 <flash_program_sequential+0x60>
        error_handler();
 800984c:	47b8      	blx	r7
}
 800984e:	4640      	mov	r0, r8
 8009850:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    for(int i = 0; i < N; i++){
 8009854:	42a6      	cmp	r6, r4
 8009856:	d1e7      	bne.n	8009828 <flash_program_sequential+0x34>
 8009858:	e7d7      	b.n	800980a <flash_program_sequential+0x16>
 800985a:	bf00      	nop
 800985c:	f8000004 	.word	0xf8000004
 8009860:	f7ff8004 	.word	0xf7ff8004

08009864 <Reset_Handler>:
    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

     ldr   sp, =_estack      /* set stack pointer */
 8009864:	f8df d034 	ldr.w	sp, [pc, #52]	; 800989c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8009868:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800986a:	e003      	b.n	8009874 <LoopCopyDataInit>

0800986c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800986c:	4b0c      	ldr	r3, [pc, #48]	; (80098a0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800986e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8009870:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8009872:	3104      	adds	r1, #4

08009874 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8009874:	480b      	ldr	r0, [pc, #44]	; (80098a4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8009876:	4b0c      	ldr	r3, [pc, #48]	; (80098a8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8009878:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800987a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800987c:	d3f6      	bcc.n	800986c <CopyDataInit>
  ldr  r2, =_sbss
 800987e:	4a0b      	ldr	r2, [pc, #44]	; (80098ac <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8009880:	e002      	b.n	8009888 <LoopFillZerobss>

08009882 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8009882:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8009884:	f842 3b04 	str.w	r3, [r2], #4

08009888 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8009888:	4b09      	ldr	r3, [pc, #36]	; (80098b0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800988a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800988c:	d3f9      	bcc.n	8009882 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800988e:	f7fc ff5b 	bl	8006748 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8009892:	f000 f811 	bl	80098b8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8009896:	f7fb ff2b 	bl	80056f0 <main>
  bx  lr    
 800989a:	4770      	bx	lr
     ldr   sp, =_estack      /* set stack pointer */
 800989c:	20080000 	.word	0x20080000
  ldr  r3, =_sidata
 80098a0:	08009a38 	.word	0x08009a38
  ldr  r0, =_sdata
 80098a4:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80098a8:	20002068 	.word	0x20002068
  ldr  r2, =_sbss
 80098ac:	20002068 	.word	0x20002068
  ldr  r3, = _ebss
 80098b0:	20069640 	.word	0x20069640

080098b4 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80098b4:	e7fe      	b.n	80098b4 <ADC_IRQHandler>
	...

080098b8 <__libc_init_array>:
 80098b8:	b570      	push	{r4, r5, r6, lr}
 80098ba:	4e0d      	ldr	r6, [pc, #52]	; (80098f0 <__libc_init_array+0x38>)
 80098bc:	4c0d      	ldr	r4, [pc, #52]	; (80098f4 <__libc_init_array+0x3c>)
 80098be:	1ba4      	subs	r4, r4, r6
 80098c0:	10a4      	asrs	r4, r4, #2
 80098c2:	2500      	movs	r5, #0
 80098c4:	42a5      	cmp	r5, r4
 80098c6:	d109      	bne.n	80098dc <__libc_init_array+0x24>
 80098c8:	4e0b      	ldr	r6, [pc, #44]	; (80098f8 <__libc_init_array+0x40>)
 80098ca:	4c0c      	ldr	r4, [pc, #48]	; (80098fc <__libc_init_array+0x44>)
 80098cc:	f000 f82c 	bl	8009928 <_init>
 80098d0:	1ba4      	subs	r4, r4, r6
 80098d2:	10a4      	asrs	r4, r4, #2
 80098d4:	2500      	movs	r5, #0
 80098d6:	42a5      	cmp	r5, r4
 80098d8:	d105      	bne.n	80098e6 <__libc_init_array+0x2e>
 80098da:	bd70      	pop	{r4, r5, r6, pc}
 80098dc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80098e0:	4798      	blx	r3
 80098e2:	3501      	adds	r5, #1
 80098e4:	e7ee      	b.n	80098c4 <__libc_init_array+0xc>
 80098e6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80098ea:	4798      	blx	r3
 80098ec:	3501      	adds	r5, #1
 80098ee:	e7f2      	b.n	80098d6 <__libc_init_array+0x1e>
 80098f0:	08009a30 	.word	0x08009a30
 80098f4:	08009a30 	.word	0x08009a30
 80098f8:	08009a30 	.word	0x08009a30
 80098fc:	08009a34 	.word	0x08009a34

08009900 <memcpy>:
 8009900:	b510      	push	{r4, lr}
 8009902:	1e43      	subs	r3, r0, #1
 8009904:	440a      	add	r2, r1
 8009906:	4291      	cmp	r1, r2
 8009908:	d100      	bne.n	800990c <memcpy+0xc>
 800990a:	bd10      	pop	{r4, pc}
 800990c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009910:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009914:	e7f7      	b.n	8009906 <memcpy+0x6>

08009916 <memset>:
 8009916:	4402      	add	r2, r0
 8009918:	4603      	mov	r3, r0
 800991a:	4293      	cmp	r3, r2
 800991c:	d100      	bne.n	8009920 <memset+0xa>
 800991e:	4770      	bx	lr
 8009920:	f803 1b01 	strb.w	r1, [r3], #1
 8009924:	e7f9      	b.n	800991a <memset+0x4>
	...

08009928 <_init>:
 8009928:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800992a:	bf00      	nop
 800992c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800992e:	bc08      	pop	{r3}
 8009930:	469e      	mov	lr, r3
 8009932:	4770      	bx	lr

08009934 <_fini>:
 8009934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009936:	bf00      	nop
 8009938:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800993a:	bc08      	pop	{r3}
 800993c:	469e      	mov	lr, r3
 800993e:	4770      	bx	lr
